<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zyunfei63.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12,"display":"post"},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"enable":true,"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="版本1.0">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex Hexo">
<meta property="og:url" content="https://zyunfei63.github.io/page/3/index.html">
<meta property="og:site_name" content="Alex Hexo">
<meta property="og:description" content="版本1.0">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zyunfei">
<meta property="article:tag" content="Java, go,js,Resume">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zyunfei63.github.io/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Alex Hexo</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GF5PJZTEZ"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-5GF5PJZTEZ","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Alex Hexo</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">可以开发出自己的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/home" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fas fa-folder fa-fw"></i>分类</a></li><li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fas fa-briefcase fa-fw"></i>简历</a></li><li class="menu-item menu-item-github"><a href="https://github.com/zyunfei63" rel="section" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zyunfei"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">zyunfei</p>
  <div class="site-description" itemprop="description">版本1.0</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zyunfei63.github.io/2025/07/02/goLang/index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zyunfei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Hexo">
      <meta itemprop="description" content="版本1.0">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Alex Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/goLang/index/" class="post-title-link" itemprop="url">Golang-Learn</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-02 17:35:21" itemprop="dateCreated datePublished" datetime="2025-07-02T17:35:21+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-09-30 14:22:41" itemprop="dateModified" datetime="2025-09-30T14:22:41+08:00">2025-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/%E5%AE%98%E6%96%B9%E9%93%BE%E6%8E%A5/" itemprop="url" rel="index"><span itemprop="name">官方链接</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="涉及官网"><a href="#涉及官网" class="headerlink" title="涉及官网"></a>涉及官网</h1><p>官网1：：<a target="_blank" rel="noopener" href="https://protobuf.dev/">https://protobuf.dev/</a><br><a target="_blank" rel="noopener" href="https://protobuf.com.cn/">https://protobuf.com.cn/</a><br>官网2：：<a target="_blank" rel="noopener" href="https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code">https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code</a><br>go基本库的中文文档：：<a target="_blank" rel="noopener" href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a><br>go代理：：<a target="_blank" rel="noopener" href="https://goproxy.io/zh/">https://goproxy.io/zh/</a><br>go官网：： <a target="_blank" rel="noopener" href="https://golang.org/">https://golang.org/</a><br>go-micro文档：： <a target="_blank" rel="noopener" href="http://m1.topgoer.com/Overview/Architecture.html">http://m1.topgoer.com/Overview/Architecture.html</a><br>go中文首页（2020年更新网友提供）::<a target="_blank" rel="noopener" href="https://www.topgoer.com/">https://www.topgoer.com/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zyunfei63.github.io/2025/07/02/installTool/protocolBuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zyunfei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Hexo">
      <meta itemprop="description" content="版本1.0">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Alex Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/installTool/protocolBuf/" class="post-title-link" itemprop="url">protocolBuf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-02 17:35:21" itemprop="dateCreated datePublished" datetime="2025-07-02T17:35:21+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-09-30 14:22:41" itemprop="dateModified" datetime="2025-09-30T14:22:41+08:00">2025-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/" itemprop="url" rel="index"><span itemprop="name">installTool</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/golang/protocolBuf/" itemprop="url" rel="index"><span itemprop="name">protocolBuf</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简单介绍protocol是什么"><a href="#简单介绍protocol是什么" class="headerlink" title="简单介绍protocol是什么"></a>简单介绍protocol是什么</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">官网：：https://protobuf.com.cn/getting-started/gotutorial/ </span><br><span class="line">https://protobuf.com.cn/</span><br><span class="line">grpc文档：：  https://grpc.io/docs/languages/go/quickstart/#regenerate-grpc-code</span><br></pre></td></tr></table></figure>


<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="win10安装1"><a href="#win10安装1" class="headerlink" title="win10安装1"></a>win10安装1</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">01 前提安装了Chocolatey </span><br><span class="line">02 choco install protoc</span><br><span class="line">03 配置环境系统变量  具体位置，日志会打印</span><br><span class="line">04 protoc-gen-go.exe 的安装 （用于将file.proto文件转译为file.pb.go文件）</span><br><span class="line">   go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------</span><br><span class="line">PS C:\windows\system32&gt; Chocolatey</span><br><span class="line">Chocolatey v0.12.1</span><br><span class="line">Please run &#x27;choco -?&#x27; or &#x27;choco &lt;command&gt; -?&#x27; for help menu.</span><br><span class="line">PS C:\windows\system32&gt; choco install protoc</span><br><span class="line">Chocolatey v0.12.1</span><br><span class="line">Installing the following packages:</span><br><span class="line">protoc</span><br><span class="line">By installing, you accept licenses for the packages.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\windows\system32&gt; choco install protoc</span><br><span class="line">Chocolatey v0.12.1</span><br><span class="line">Installing the following packages:</span><br><span class="line">protoc</span><br><span class="line">By installing, you accept licenses for the packages.</span><br><span class="line">protoc v32.0.0 already installed.</span><br><span class="line"> Use --force to reinstall, specify a version to install, or try upgrade.</span><br><span class="line"></span><br><span class="line">Chocolatey installed 0/1 packages.</span><br><span class="line"> See the log for details (C:\ProgramData\chocolatey\logs\chocolatey.log).</span><br><span class="line"></span><br><span class="line">Warnings:</span><br><span class="line"> - protoc - protoc v32.0.0 already installed.</span><br><span class="line"> Use --force to reinstall, specify a version to install, or try upgrade.</span><br><span class="line">PS C:\windows\system32&gt;</span><br></pre></td></tr></table></figure>



<h1 id="win10安装方式2"><a href="#win10安装方式2" class="headerlink" title="win10安装方式2"></a>win10安装方式2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">01 https://github.com/protocolbuffers/protobuf/releases/tag/v26.1</span><br><span class="line">02 解压</span><br><span class="line">03 与环境变量</span><br><span class="line">04 protoc-gen-go.exe 的安装 （用于将file.proto文件转译为file.pb.go文件）</span><br><span class="line">        命令：： go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br><span class="line">         </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zyunfei63.github.io/2025/07/02/installTool/python-env-ready/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zyunfei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Hexo">
      <meta itemprop="description" content="版本1.0">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Alex Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/installTool/python-env-ready/" class="post-title-link" itemprop="url">protocolBuf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-02 17:35:21" itemprop="dateCreated datePublished" datetime="2025-07-02T17:35:21+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-09-09 18:42:03" itemprop="dateModified" datetime="2025-09-09T18:42:03+08:00">2025-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python-env/" itemprop="url" rel="index"><span itemprop="name">python-env</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>#python环境</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建新环境</span><br><span class="line">conda create -n python-test-only python=3.11 -y</span><br><span class="line">激活新环境</span><br><span class="line">conda activate python-test-only</span><br><span class="line">进入项目目录并安装依赖</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zyunfei63.github.io/2025/07/02/installTool/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zyunfei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Hexo">
      <meta itemprop="description" content="版本1.0">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Alex Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/installTool/docker/" class="post-title-link" itemprop="url">Docker-Install</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-02 17:35:21" itemprop="dateCreated datePublished" datetime="2025-07-02T17:35:21+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-01 16:22:40" itemprop="dateModified" datetime="2025-10-01T16:22:40+08:00">2025-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/" itemprop="url" rel="index"><span itemprop="name">installTool</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/java/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/java/docker-linux-deploy/" itemprop="url" rel="index"><span itemprop="name">docker-linux-deploy</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://docs.qq.com/doc/DUUZBZFJQdGRuV1Rr</span><br><span class="line">https://docs.qq.com/doc/DUVVQTUdGdlh6cWNP?nlc=1</span><br></pre></td></tr></table></figure>

<p>#docker-compose和docker版本兼容问题</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@alex mysql]# docker-compose --version</span><br><span class="line">docker-compose version 1.18.0, build 8dd22a9</span><br><span class="line">[root@alex mysql]# docker -v</span><br><span class="line">Docker version 18.06.1-ce, build e68fc7a</span><br><span class="line">[root@alex mysql]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="centos7-6-1安装"><a href="#centos7-6-1安装" class="headerlink" title="centos7.6.1安装"></a>centos7.6.1安装</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">建议centos7版本高于7.6.1 ，  </span><br><span class="line"></span><br><span class="line">#安装yum源 docker的 </span><br><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">#安装docker  这个命令 手敲 或者复制到本地 去掉空格后 重写加空格 有可能会有乱码的情况 </span><br><span class="line">yum -y install docker-ce-18.06.1.ce-3.el7</span><br><span class="line">启动docker </span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">#效验安装</span><br><span class="line"></span><br><span class="line">​```   docker -v</span><br><span class="line"></span><br><span class="line">##   yum方式安装失败，使用rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>手动安装方式文档  <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ND-h7B5HraEsAAGrdHRPzA">https://mp.weixin.qq.com/s/ND-h7B5HraEsAAGrdHRPzA</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  启动后的数据</span><br><span class="line"></span><br><span class="line">​```shell</span><br><span class="line">[root@bogon Docker]# systemctl status docker.service </span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 日 2025-09-21 11:12:18 CST; 30s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 4040 (dockerd)</span><br><span class="line">   Memory: 58.5M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─4040 /usr/bin/dockerd</span><br><span class="line">           └─4064 docker-containerd --config /var/run/docker/containerd/containerd.toml </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装  docker-compose"></a>安装  docker-compose</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-compose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@alex ~]# docker-compose version</span><br><span class="line">docker-compose version 1.18.0, build 8dd22a9</span><br><span class="line">docker-py version: 2.6.1</span><br><span class="line">CPython version: 3.6.8</span><br><span class="line">OpenSSL version: OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line"></span><br><span class="line">最好可能存在版本兼容问题</span><br><span class="line">         </span><br></pre></td></tr></table></figure>


<h2 id="安装-docker-compose-方式2"><a href="#安装-docker-compose-方式2" class="headerlink" title="安装  docker-compose  方式2"></a>安装  docker-compose  方式2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">浏览器google下载</span><br><span class="line">https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64</span><br><span class="line">传输到cnetos7</span><br><span class="line">移动到指定位置</span><br><span class="line">sudo mv docker-compose-Linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">权限</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">  映射  创建符号链接</span><br><span class="line">  sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose    </span><br><span class="line">  # 4. 验证安装</span><br><span class="line">docker-compose --version   </span><br></pre></td></tr></table></figure>



<p>#执行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">部署</span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">重新加载配置</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">重启</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>



<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 Docker 服务状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果服务未运行，启动 Docker 服务</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 Docker 开机自启</span></span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Docker ps         列出正在运行的容器，可以使用以下命令</span><br><span class="line">docker stop       停止容器的命令。</span><br><span class="line">Docker exec     要在运行中的容器内执行命令，可以使用以下命令</span><br><span class="line"></span><br><span class="line">Docker logs  要查看容器的日志输出，可以使用以下命令         |  docker logs -f name-server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Docker-compose是一个用于定义和运行多个容器应用程序的工具。它使用YAML文件来配置应用程序的服务、网络和卷等。以下是一些与Docker-compose相关的常用命令：</span><br><span class="line">• docker-compose up：构建并启动Docker-compose定义的所有服务。</span><br><span class="line">• docker-compose down：停止并删除Docker-compose定义的所有服务。</span><br><span class="line">• docker-compose build：构建Docker-compose定义的所有服务的镜像。</span><br><span class="line">• docker-compose logs：查看Docker-compose定义的所有服务的日志</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@alex ~]# docker images -a</span><br><span class="line">REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mysql                                           8.0                 94753e67a0a9        4 days ago          780MB</span><br><span class="line"></span><br><span class="line">[root@alex ~]# </span><br></pre></td></tr></table></figure>


<p>#docker删除之前安装过的mysql,安装失败的时候</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">01 到达指定目录</span><br><span class="line">docker-compose down -v  --remove-orphans</span><br><span class="line"></span><br><span class="line">docker ps -a</span><br><span class="line">03</span><br><span class="line">查询相关镜像</span><br><span class="line">docker images | grep mysql</span><br><span class="line"></span><br><span class="line">04</span><br><span class="line">修改脚本</span><br><span class="line">vim</span><br><span class="line"></span><br><span class="line">05</span><br><span class="line">重新拉取镜像 ，会根据当前目录docker-compose.yml文件拉取相关的数docker-compose pull</span><br><span class="line">[root@alex mysql]# docker-compose pull  --ignore-pull-failures</span><br><span class="line">Pulling mysql-node1 ... done</span><br><span class="line">Pulling mysql-node2 ... done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#06 重新启动</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">01 </span><br><span class="line">docker exec -it mysql_mysql-node1_1 mysql -uroot -proot-root-password</span><br><span class="line"></span><br><span class="line">02</span><br><span class="line">CREATE USER &#x27;repl&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;repl-password&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;repl&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="docker-mysql安装"><a href="#docker-mysql安装" class="headerlink" title="docker-mysql安装"></a>docker-mysql安装</h1><h2 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@alex mysql]# docker exec -it mysql_mysql-node1_1 mysql -uroot -proot-password</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 9</span><br><span class="line">Server version: 8.0.43 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2025, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CREATE USER <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;repl-password&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">FLUSH PRIVILEGES;</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW MASTER STATUS\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql-bin.000004</span><br><span class="line">         Position: 896</span><br><span class="line">     Binlog_Do_DB: </span><br><span class="line"> Binlog_Ignore_DB: </span><br><span class="line">Executed_Gtid_Set: e3354b14-9e7a-11f0-8bf0-0242ac1c0002:1-11</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span></span><br></pre></td></tr></table></figure>



<h2 id="从节点设置"><a href="#从节点设置" class="headerlink" title="从节点设置"></a>从节点设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql_mysql-node2_1 mysql -uroot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CHANGE MASTER TO</span></span><br><span class="line">    -&gt; MASTER_HOST=&#x27;mysql-node1&#x27;,</span><br><span class="line">    -&gt; MASTER_USER=&#x27;repl&#x27;,</span><br><span class="line">    -&gt; MASTER_PASSWORD=&#x27;repl-password&#x27;,</span><br><span class="line">    -&gt; MASTER_AUTO_POSITION=1;</span><br><span class="line">Query OK, 0 rows affected, 7 warnings (0.03 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> SLAVE STATUS\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               Slave_IO_State: Connecting <span class="keyword">to</span> source</span><br><span class="line">                  Master_Host: mysql<span class="operator">-</span>node1</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: <span class="number">3306</span></span><br><span class="line">                Connect_Retry: <span class="number">60</span></span><br><span class="line">              Master_Log_File: </span><br><span class="line">          Read_Master_Log_Pos: <span class="number">4</span></span><br><span class="line">               Relay_Log_File: <span class="number">99</span>c3951a31f0<span class="operator">-</span>relay<span class="operator">-</span>bin<span class="number">.000001</span></span><br><span class="line">                Relay_Log_Pos: <span class="number">4</span></span><br><span class="line">        Relay_Master_Log_File: </span><br><span class="line">             Slave_IO_Running: Connecting</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: <span class="number">0</span></span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: <span class="number">0</span></span><br><span class="line">          Exec_Master_Log_Pos: <span class="number">0</span></span><br><span class="line">              Relay_Log_Space: <span class="number">157</span></span><br><span class="line">              Until_Condition: <span class="keyword">None</span></span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: <span class="number">0</span></span><br><span class="line">           Master_SSL_Allowed: <span class="keyword">No</span></span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: <span class="number">0</span></span><br><span class="line">Master_SSL_Verify_Server_Cert: <span class="keyword">No</span></span><br><span class="line">                Last_IO_Errno: <span class="number">2061</span></span><br><span class="line">                Last_IO_Error: Error connecting <span class="keyword">to</span> source <span class="string">&#x27;repl@mysql-node1:3306&#x27;</span>. This was attempt <span class="number">1</span><span class="operator">/</span><span class="number">86400</span>, <span class="keyword">with</span> a delay <span class="keyword">of</span> <span class="number">60</span> seconds <span class="keyword">between</span> attempts. Message: Authentication plugin <span class="string">&#x27;caching_sha2_password&#x27;</span> reported error: Authentication requires secure connection.</span><br><span class="line">               Last_SQL_Errno: <span class="number">0</span></span><br><span class="line">               Last_SQL_Error: </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zyunfei63.github.io/2025/07/02/installTool/nvm-node/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zyunfei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Hexo">
      <meta itemprop="description" content="版本1.0">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Alex Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/installTool/nvm-node/" class="post-title-link" itemprop="url">Docker-Install</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-02 17:35:21" itemprop="dateCreated datePublished" datetime="2025-07-02T17:35:21+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-09-26 11:16:57" itemprop="dateModified" datetime="2025-09-26T11:16:57+08:00">2025-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/" itemprop="url" rel="index"><span itemprop="name">installTool</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/node/" itemprop="url" rel="index"><span itemprop="name">node</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/installTool/node/nvm/" itemprop="url" rel="index"><span itemprop="name">nvm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="注意nvm-1-2管理-node14-存在问题，直接安装nvm1-1"><a href="#注意nvm-1-2管理-node14-存在问题，直接安装nvm1-1" class="headerlink" title="注意nvm 1.2管理  node14 存在问题，直接安装nvm1.1"></a>注意nvm 1.2管理  node14 存在问题，直接安装nvm1.1</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装位置 C:\Users\22166\AppData\Roaming\nvm</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="安装nvm1-1-x成功后"><a href="#安装nvm1-1-x成功后" class="headerlink" title="安装nvm1.1.x成功后"></a>安装nvm1.1.x成功后</h1><h2 id="配置多版本nodejs管理"><a href="#配置多版本nodejs管理" class="headerlink" title="配置多版本nodejs管理"></a>配置多版本nodejs管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建文件夹nodejs-env</span><br><span class="line">C:\Users\22166\AppData\Roaming\nvm\nodejs-env</span><br><span class="line"></span><br><span class="line">创建文件夹node_cache   node_global</span><br><span class="line">C:\Users\22166\AppData\Roaming\nvm\nodejs-env\node_cache</span><br><span class="line">C:\Users\22166\AppData\Roaming\nvm\nodejs-env\node_global</span><br><span class="line"></span><br><span class="line">03 系统环境变量配置参数</span><br><span class="line">系统环境变量   NODE_PATH   C:\Users\22166\AppData\Roaming\nvm\nodejs-env\node_global\node_modules</span><br><span class="line">用户环境变量   PATH  添加一条   C:\Users\22166\AppData\Roaming\nvm\nodejs-env\node_global</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd命令窗口 执行</span><br><span class="line">创建完后，在cmd窗口中输入以下命令（两个路径即是两个文件夹的路径），主要目的是方便后面window机器进行使用方便：</span><br><span class="line">npm config set prefix &quot;C:\Users\22166\AppData\Roaming\nvm\nodejs-env\node_global&quot;</span><br><span class="line">npm config set cache &quot;C:\Users\22166\AppData\Roaming\nvm\nodejs-env\node_cache&quot;</span><br><span class="line"></span><br><span class="line">测试是否配置成功，在cmd窗口中输入以下指定全局安装express模块</span><br><span class="line">npm install -g express</span><br></pre></td></tr></table></figure>







<h2 id="安装node和切换"><a href="#安装node和切换" class="headerlink" title="安装node和切换"></a>安装node和切换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nvm list available查询可插入版本号</span><br><span class="line">nvm install 16.18.1   // 安装node4.6.2版本（附带安装npm）</span><br><span class="line">nvm uninstall 16.18.1 // 卸载node4.6.2版本</span><br><span class="line">nvm list            // 查看已安装node版本</span><br><span class="line">nvm use 16.18.1       // 将node版本切换到4.6.2版本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nvm install 14.21.1 </span><br><span class="line">nvm uninstall 14.21.1 </span><br></pre></td></tr></table></figure>

<p><img src="/./osi.png" alt="osi"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zyunfei63.github.io/2025/07/02/interSummary/intervwSummary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="zyunfei">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Hexo">
      <meta itemprop="description" content="版本1.0">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Alex Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/07/02/interSummary/intervwSummary/" class="post-title-link" itemprop="url">intervmSummary</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-07-02 17:35:21" itemprop="dateCreated datePublished" datetime="2025-07-02T17:35:21+08:00">2025-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-02 12:30:55" itemprop="dateModified" datetime="2025-10-02T12:30:55+08:00">2025-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/inter/" itemprop="url" rel="index"><span itemprop="name">inter</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/inter/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37084904/article/details/109243886">详细理解HashMap数据结构，太齐全了！-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30946244897">一文读懂HashMap高频考点：从哈希碰撞到红黑树优化，为何它总在面试中高频出现？ - 知乎</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Location\技术积累区\tuling线程并发\高并发代码\第三四节monkkey\juc\src\main\java\bat\ke\qq\com</span><br></pre></td></tr></table></figure>



<img src="${images}/hashMap数据结构.png" alt="hashMap数据结构" style="zoom: 50%;" />

<p><img src="${images}/2025-04-10_141635.png" alt="2025-04-10_141635" style="zoom: 67%;" /><img src="/$%7Bimages%7D/image-20250411151525781.png" alt="image-20250411151525781"></p>
<img src="${images}/image-20250410205250313.png" alt="image-20250410205250313" style="zoom:67%;" />

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">1.7  头插入法 会死循环问题 ，1.8之后修正为尾插法</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">1.8之前采用数组加链表的数据结构（1.7没有红黑树结构），1.8采用数组加链表加红黑树的数据结构。</span><br><span class="line">     桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。</span><br><span class="line">     </span><br><span class="line"> a1::</span><br><span class="line"> HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的</span><br><span class="line"> HashMap最多允许有一个键为null，允许多个值为null；</span><br><span class="line"> </span><br><span class="line"> 相反 concurrentHashMap的key value不能是null</span><br><span class="line"> HashTable不允许键或值为null</span><br><span class="line"> </span><br><span class="line"> a2:: 存储过程，链表会存在 哈希碰撞，  jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> a3:: 成员变量 负债因子 初始化容量</span><br><span class="line"> a4:: 当HashMap中的元素个数超过数组长度loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">a5:: 链表切换红黑树 </span><br><span class="line">JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值 （++size &gt; threshold）（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。 当这个链表长度大于阈值8并且数组长度大于64则进行将链表变为红黑树。</span><br><span class="line"> 将链表转换成红黑树前会判断，如果阈值大于8，但是数组长度小64，此时并不会将链表变为红黑树。而是选择进行数组扩容。变为红黑树的目的是为了高效的查询。</span><br><span class="line">    </span><br><span class="line">    a6::如果红黑树节点个数 &lt; 6 ，转为链表（取消树化）</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">flage HashMap特点::</span><br><span class="line">     存取无序的</span><br><span class="line"></span><br><span class="line">键和值位置都可以是null，但是键位置只能是一个null</span><br><span class="line"></span><br><span class="line">键位置是唯一的，底层的数据结构控制键的</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">jdk1.8前数据结构是：链表 + 数组 数据结构 来解决冲突  jdk1.8之后是 ：链表 + 数组  + 红黑树  来解决冲突  </span><br><span class="line">-----------9999</span><br><span class="line">         </span><br><span class="line">         ----</span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     a2::存储过程</span><br><span class="line">   当两个对象的hashCode相等时会怎么样？</span><br><span class="line"></span><br><span class="line">会产生哈希碰撞，若key值内容相同则替换旧的value.否则连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</span><br><span class="line"></span><br><span class="line">何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</span><br><span class="line"></span><br><span class="line">只要两个元素的key计算的哈希值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br><span class="line"></span><br><span class="line">如果两个键的hashcode相同，如何存储键值对？</span><br><span class="line"></span><br><span class="line">hashcode相同，通过equals比较内容是否相同。</span><br><span class="line">         ----相同（String类型情况下：：引用地址相同或者内容相同）：则新的value覆盖之前的value，</span><br><span class="line">         --不相同：则将新的键值对添加到链表或者红黑树下一个节点</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此arr[index]  如:sarr[9]索引位置上的所有数据改为使用红黑树存储。</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         两个对象一样对象 hashCode值一样， 重写equle. 方法   </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">          抖音源码分析分析：：  </span><br><span class="line">https://www.douyin.com/search/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90?aid=4705b39d-8246-4b5a-950f-95973e912c59&amp;modal_id=7298270278071667994&amp;type=general</span><br><span class="line"></span><br><span class="line">  红黑树演示网站：：  https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</span><br></pre></td></tr></table></figure>

<h2 id="延申涉及-hashCode-equle-方法重写"><a href="#延申涉及-hashCode-equle-方法重写" class="headerlink" title="延申涉及 hashCode ()  equle()方法重写"></a>延申涉及 hashCode ()  equle()方法重写</h2><img src="${images}/image-20250506154849973.png" alt="image-20250506154849973" style="zoom:67%;" />

<p><img src="/$%7Bimages%7D/image-20250506190704049.png" alt="image-20250506190704049"></p>
<p><img src="/$%7Bimages%7D/image-20250506190627649.png" alt="image-20250506190627649"></p>
<p><img src="/$%7Bimages%7D/image-20250506235457063.png" alt="image-20250506235457063"></p>
<p><img src="/$%7Bimages%7D/image-20250507142514521.png" alt="自定义的类MarkBoy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结论：： 通过上面的分析，彻底理解了HashMap的原理以及冲突现象，也理解了为什么，要使用HashMap（以及HashSet）来存储的对象类一定要同时重写hashCode和equals方法。</span><br><span class="line"></span><br><span class="line">此外hashcode和equals的关系，</span><br><span class="line">1.hashcode值相等，equals()返回true.  对象一定一样</span><br><span class="line">2.其他三种情况 ，不确定了</span><br><span class="line"></span><br><span class="line">Object 的hashcode()是根據地址來返回值的即使兩個對象内容一樣，地址肯定不一樣，所以返回值也不一樣，</span><br><span class="line"></span><br><span class="line">总结：：  hashcode()和equals()方法在 Object和String，或者自己创建的类Student  里面都继承extends这些方法，</span><br><span class="line">       1. 首先 Object 的hashcode()是根据地址來计算返回值的即使兩個對象内容一樣，地址肯定不一樣，所以返回值hash值也不一樣。</span><br><span class="line">       2.第二Object .equals() 比较的是引用地址</span><br><span class="line">       3. 由于String这个类特别常用，相对于其他类 特殊重写了hashcode和equals()方法,具体可以看jdk8源码，上图也有</span><br><span class="line">       4. key值类型的不一样， 使用的hashcode()和equals()方法也不一样，如果自定义的引用数据类型（例如 Person,id ,name)这种，再重写两个方法时候具体的 方法体内容 自定义</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="headerlink" title="什么是哈希冲突"></a>什么是哈希冲突</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用的散列冲突解决方法有2类：   开放寻址法：例如:ThreadLocalMap；  链地址法：例如:HashMap。</span><br><span class="line"></span><br><span class="line">不同的对象，使用key (可能是字符串) 通过hashcode()方法 获得返回值，  两个对象index 相等</span><br><span class="line"></span><br><span class="line">解决办法 1. 使用 双向循环链表的 next属性 来 解决冲突  2. 使用 红黑树 解决</span><br></pre></td></tr></table></figure>

<h2 id="链表过长-查询效率过低-所以-改为红黑树"><a href="#链表过长-查询效率过低-所以-改为红黑树" class="headerlink" title="链表过长 查询效率过低 所以 改为红黑树"></a>链表过长 查询效率过低 所以 改为红黑树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>-- 这种情况最坏的查找无非也就查找高度次（那如果结点数量为N，它的高度通常保持在logN的水平），所以这样它的时间复杂度就是O（logN)。</span><br><span class="line"><span class="number">2</span>---  但是，避免不了出现这样的情况（单链条）  ，二叉搜索树退化为单支树(或者接近单支)，那这时查找的时间复杂度就应该是O(N)。</span><br><span class="line"> </span><br><span class="line"> 不默认使用红黑树 的原因 红黑苏 需要左旋 右旋  ，变色的操作 数据结构复杂，在冲突比较少的情况下，链表的查询效率实际上是会比较高一点</span><br><span class="line">  </span><br><span class="line">  取消树化 的阈值是  <span class="number">6</span>     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="为什么-HashMap-使用红黑树而不是二叉树-平衡二叉树？"><a href="#为什么-HashMap-使用红黑树而不是二叉树-平衡二叉树？" class="headerlink" title="为什么 HashMap 使用红黑树而不是二叉树&#x2F;平衡二叉树？"></a>为什么 HashMap 使用红黑树而不是二叉树&#x2F;平衡二叉树？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--- 红黑树本质上是 一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：</span><br><span class="line"></span><br><span class="line">每个节点要么是红色，要么是黑色；</span><br><span class="line">根节点永远是黑色的；</span><br><span class="line">所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节 点）；</span><br><span class="line">每个红色节点的两个子节点一定都是黑色；</span><br><span class="line">从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>---  之所以不用 二叉查找树：</span><br><span class="line"></span><br><span class="line">红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>-- 之所以不用平衡二叉树：</span><br><span class="line">    </span><br><span class="line">平衡二叉树是红黑树是一种自平衡二叉排序树，，，比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。</span><br></pre></td></tr></table></figure>

<h2 id="为什么经常使用String作为HashMap的Key？"><a href="#为什么经常使用String作为HashMap的Key？" class="headerlink" title="为什么经常使用String作为HashMap的Key？"></a><strong>为什么经常使用String作为HashMap的Key？</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、不可变类 String 可以避免修改后无法定位键值对： 假设 String 是可变类，当我们在 HashMap 中构建起一个以 String为Key的键值对时，此时对String进行修改，那么通过修改后的String是无法匹配到刚才构建过的键值对的，因为修改后的hashCode可能会变化，而不可变类可以规避这个问题；</span><br><span class="line">2、String能够满足Java对于hashCode()和 equals()的通用约定： 既两个对象equals()相同，则hashCode()一定相同，</span><br><span class="line"> 如果hashCode()相同，但是equals()不一定相同。</span><br><span class="line"> 这个约定是为了避免两个equals()相同的Key在HashMap中存储两个独立的键值对，引起矛盾。</span><br></pre></td></tr></table></figure>

<h2 id="为什么HashMap采用链地址法而不是开放寻址法"><a href="#为什么HashMap采用链地址法而不是开放寻址法" class="headerlink" title="为什么HashMap采用链地址法而不是开放寻址法"></a>为什么HashMap采用链地址法而不是开放寻址法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">而链地址法对于装载因子的容忍度更高，能够适合大数据量且更高的装载因子上限，内存利用率更高。虽然链表节点会多消耗一个指针内存，但在一般的业务场景中可以忽略不计。</span><br><span class="line"></span><br><span class="line">我们可以举个反例，在Java原生的数据结构中，也存在使用开放寻址法的散列表——就是ThreadlLocal。因为项目中不会大量使用ThreadLocal线程局部存储，所以它是一个小规模数据场景，这里使用开放寻址法是没问题的</span><br></pre></td></tr></table></figure>

<h2 id="hashmap的hash方法为什么需要让高16位参与异或运算的原因"><a href="#hashmap的hash方法为什么需要让高16位参与异或运算的原因" class="headerlink" title="hashmap的hash方法为什么需要让高16位参与异或运算的原因"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyvalley/p/14227702.html">hashmap的hash方法为什么需要让高16位参与异或运算的原因</a></h2><p><img src="/$%7Bimages%7D/image-20251002122024538.png" alt="image-20251002122024538"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">h = key.hashCode() - 获取对象的原始哈希码（<span class="number">32</span>位）</span><br><span class="line"></span><br><span class="line">h &gt;&gt;&gt; <span class="number">16</span> - 无符号右移<span class="number">16</span>位，将高<span class="number">16</span>位移动到低<span class="number">16</span>位</span><br><span class="line"></span><br><span class="line">h ^ (h &gt;&gt;&gt; <span class="number">16</span>) - 高<span class="number">16</span>位与低<span class="number">16</span>位进行异或运算</span><br><span class="line"></span><br><span class="line">原因：当数组的长度很短时，只有低位数的hashcode值能参与运算。而让高<span class="number">16</span>位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率。并且使得高<span class="number">16</span>位和低<span class="number">16</span>位的信息都被保留了</span><br></pre></td></tr></table></figure>

<h2 id="源码标记"><a href="#源码标记" class="headerlink" title="源码标记"></a>源码标记</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//    //   putIfAbsent方法：   V putIfAbsent(K key, V value);</span></span><br><span class="line"><span class="comment">//  而putIfAbsent方法在添加键值对时会进行检查，如果Map集合中不存在指定的键，则会添加键值对并返回null。如果Map中已经存在该键，则不会进行任何操作，也就是说旧的值不会被替换，而是保持不变，方法返回的也是原来的值。</span></span><br><span class="line">  <span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> get(key);</span><br><span class="line">      <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">          v = put(key, value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="putVal-返的旧的值为啥"><a href="#putVal-返的旧的值为啥" class="headerlink" title="putVal()返的旧的值为啥"></a>putVal()返的旧的值为啥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回旧值：让调用者知道这次操作替换掉了什么</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>





<h1 id="ConcurrentHashMap的使用-以及具体位置哪个节点起作用（具体罗辑思维）"><a href="#ConcurrentHashMap的使用-以及具体位置哪个节点起作用（具体罗辑思维）" class="headerlink" title="ConcurrentHashMap的使用,以及具体位置哪个节点起作用（具体罗辑思维）"></a>ConcurrentHashMap的使用,以及具体位置哪个节点起作用（具体罗辑思维）</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zerotomax/p/8687425.html#go0">ConcurrentHashMap源码分析(1.8) - Ouka傅 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ConcurrentHashMap.html#size-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95">吊打Java面试官之ConcurrentHashMap（线程安全的哈希表） | 二哥的Java进阶之路</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/zerotomax/p/8687425.html#go0</span><br><span class="line">https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html</span><br><span class="line">https://cloud.tencent.com/developer/article/2283647</span><br><span class="line">https://blog.csdn.net/fh667788123/article/details/105320428</span><br><span class="line">https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-%E6%89%A9%E5%AE%B9-rehash</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/639717596</span><br><span class="line"></span><br><span class="line">https://javabetter.cn/thread/ConcurrentHashMap.html#size-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95</span><br><span class="line"></span><br><span class="line">D:\Location\2024常用的工具类收集\littleCollection\src\main\java\concurrentHashMap原理</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20250411222043883.png" alt="jdk1.7数据结构如下图"></p>
<h2 id="知识点补充-原码-反码-补码"><a href="#知识点补充-原码-反码-补码" class="headerlink" title="知识点补充 原码 反码 补码"></a>知识点补充 原码 反码 补码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/u011429167/article/details/129264625</span><br><span class="line">原码：是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。</span><br><span class="line"></span><br><span class="line">反码：正数的反码和原码一致；负数的反码就是它的原码除符号位外，按位取反。</span><br><span class="line">补码：正数的原码、反码、补码都一致；负数的补码等于反码+1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    &amp;按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)1&amp;1=1 , 1&amp;0=0 , 0&amp;1=0 , 0&amp;0=0</span><br><span class="line">//3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ， 那么就是011 &amp; 101，由按位与运算规则得知，001 &amp; 101等于0000 0001，最终值为1</span><br><span class="line">//7的二进制位是0000 0111，那就是111 &amp; 101  等于101，也就是0000 0101，故值为5</span><br><span class="line">//-2是 2的补码   的二进制位是   补码= 反码（1111 1101）+1=1111 1110(就是-2)， 然后  1111 1110&amp;0000 0111=0110 =6(十进制)</span><br><span class="line"></span><br><span class="line">        System.out.println(3&amp;5);// result=1</span><br><span class="line">        System.out.println(5&amp;7);// result=5</span><br><span class="line">        System.out.println(-1&amp;7);// result=7</span><br><span class="line">        System.out.println(-2&amp;7);// result=6</span><br><span class="line">        System.out.println(2&amp;7);// result=2</span><br><span class="line">        或运算  1100 | 1010 =1110</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----01 原码  最高位是符号--------------</span><br><span class="line"> 原码 (Sign-Magnitude)</span><br><span class="line">是什么？ 表示有符号整数最直观的方法。</span><br><span class="line">规则：</span><br><span class="line">最高位 (最左边的位) 是符号位：</span><br><span class="line">0 表示 正数</span><br><span class="line">1 表示 负数</span><br><span class="line">剩下的位 (数值位) 表示这个数的绝对值的二进制形式。</span><br><span class="line">例子 (8位系统)：</span><br><span class="line">+1=00000000 00000000 00000000 00000001</span><br><span class="line">-1=10000000 00000000 00000000 00000001</span><br><span class="line">+5 = 0 ...0000101 = 00000101 (符号位0 + 5的二进制)</span><br><span class="line">-5 = 1 ...0000101 = 10000101 (符号位1 + 5的二进制)</span><br><span class="line">问题：</span><br><span class="line">存在 +0 和 -0： 00000000 和 10000000 都表示“零”。这会造成计算和比较上的混乱。</span><br><span class="line">加减法运算复杂： 计算机做加法电路最简单高效。但用原码做加减法时，需要先判断符号位，再决定是做加法还是减法，效率低且电路设计复杂。</span><br><span class="line"> --------02 反码  ------------------------------------------------------------</span><br><span class="line">反码 (Ones&#x27; Complement)</span><br><span class="line">是什么？ 为了解决原码运算问题而提出的改进方案（但仍有缺陷）。</span><br><span class="line">规则：</span><br><span class="line">正数： 其反码和原码相同。</span><br><span class="line">负数： 将其对应的正数的原码的所有位按位取反（0 变 1，1 变 0）。</span><br><span class="line">例子 (8位系统)：</span><br><span class="line">+5 的原码是 00000101 -&gt; 反码也是 00000101</span><br><span class="line">-5：</span><br><span class="line">先找 +5 的原码：00000101</span><br><span class="line">所有位取反：11111010 -&gt; -5 的反码是 11111010        </span><br><span class="line">----------------------  03 补码  补码= 反码+1  ----------------------     ----------------------</span><br><span class="line">补码 (Two&#x27;s Complement) - 现代计算机标准</span><br><span class="line">是什么？ 在反码基础上进一步改进，完美解决了 ±0 问题和运算问题，成为现代计算机表示有符号整数的唯一标准。</span><br><span class="line">规则：</span><br><span class="line">正数： 其补码和原码、反码都相同。</span><br><span class="line">负数： 将其对应的正数的原码，所有位按位取反（得到反码），然后加 1。</span><br><span class="line">例子 (8位系统)：</span><br><span class="line">+5 的补码 = 原码 = 00000101</span><br><span class="line"></span><br><span class="line">-5：：：</span><br><span class="line">+5 原码：00000101</span><br><span class="line">按位取反 (得到反码)：11111010</span><br><span class="line">加 1： 11111010 + 1 = 11111011 -&gt; -5 的补码是 11111011  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/bit-operation.html">位运算（&amp;、|、^、~、&gt;&gt;、 | 菜鸟教程</a></p>
<h2 id="jdk1-7-concurrentHashMap的简单介绍"><a href="#jdk1-7-concurrentHashMap的简单介绍" class="headerlink" title="jdk1.7  concurrentHashMap的简单介绍"></a>jdk1.7  concurrentHashMap的简单介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用两个类型数组  segment，HashEntry,使用ReentranLock 可重入锁，</span><br><span class="line">HashEntry 每个槽位 放的是单向链表，链表是 头节点插入法，(<span class="number">1.8</span> 之后改为 尾插入)</span><br><span class="line"></span><br><span class="line">问题是：： 由于业务的需求 并发度太高情况，任然出现大量锁竞争的情况，导致性能下降</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>锁分离技术：在JDK <span class="number">1.7</span>中，通过Segment的锁分离技术减少锁竞争。</span><br><span class="line">&#123;</span><br><span class="line">JDK <span class="number">1.7</span> 实现：</span><br><span class="line">分段锁（Segment）：ConcurrentHashMap 将整个 HashMap 分成多个 Segment，每个 Segment 类似一个小的 HashMap，并且用锁来保护。因此，多个线程可以同时访问不同的 Segment，从而提高并发性能。</span><br><span class="line">分段操作：通过对键的哈希值取不同的高位来确定数据存放的 Segment。每个 Segment 独立的加锁操作，减少了锁的粒度，提高了并发性能，但是对内存CPU不友好· 。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">###碎片记录</span><br><span class="line"><span class="number">1.</span>线程安全的保证</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>concurrentHashMap  但是这个数组只有在第一次添加元素的时候才会初始化，否则只是初始化一个ConcurrentHashMap对象的话，只是设定了一个sizeCtl变量，这个变量用来判断对象的一些状态和是否需要扩容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> CAS操作：在JDK <span class="number">1.8</span>中，通过CAS操作(主要使用 compareAndSwapObject（）方法来操作 数组)来保证更新操作的原子性。</span><br><span class="line">    <span class="keyword">volatile</span>关键字：使用<span class="keyword">volatile</span>关键字保证变量的内存可见性，确保每次读取变量时都能得到最新的值。</span><br><span class="line">    初始化Node数组 使用cas+<span class="keyword">volatile</span>,  &#123; <span class="keyword">volatile</span> 修饰的变量 有 下面</span><br><span class="line"><span class="keyword">volatile</span> Node&lt;K,V&gt;[] table; <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> baseCount;   <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> transferIndex;   <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span> 在给链表或者红黑树  put放数据时候采用 synchr枷锁</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span> <span class="keyword">synchronized</span>关键字：在JDK <span class="number">1.8</span>中，通过<span class="keyword">synchronized</span>关键字来保证对链表和红黑树节点的同步修改操作。（  sychr锁的是 Node[]  里面 每个槽位的链表 的头部，）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>从（<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>）总结来说，ConcurrentHashMap通过引入锁分离技术、CAS操作、<span class="keyword">synchronized</span>关键字和<span class="keyword">volatile</span>关键字等多种机制来保证线程安全，同时通过链表转红黑树的优化提高了查询性能。这些改进使得ConcurrentHashMap在多线程环境下成为一个高效且线程安全的HashMap实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>复制之后的新链表不是旧链表的绝对倒序。</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>在扩容的时候每个线程都有处理的步长，最少为<span class="number">16</span>，在这个步长范围内的数组节点只有自己一个线程来处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> 原理总结思路细化：：：</span><br><span class="line">  <span class="number">1.</span>concurrentHashMap没有粗暴的给整个数组加锁 原因是很明显这样线程安全，效率极低。</span><br><span class="line">  <span class="number">2.</span>如果给数组的每个头节点 枷锁 这样并发度就是<span class="number">16</span> ，提高<span class="number">16</span>倍速，这样数组有多长 并发度就有多少，提高了并发度。</span><br><span class="line">  <span class="number">3.</span>举例 例如现在做一个 加加操作 ，多线程操作一个变量 a，如果给整个变量a 加上排他锁sychr 同意时间碎片只有一个thread，并发度又降下来，不合理。设计者 使用了轻量级的compare and swap方式,同一时间碎片，只有一个线程在操作变量a,其他线程不断在<span class="keyword">for</span>(;;) 里面循环重试，这样虽然解决所开销的问题，但是效率还是不是很高， 于是设计者又考虑  可以咋失败时候可以新建一个数组counterCells[]  专门负责 失败时候值的 累加，</span><br><span class="line">  <span class="number">4.</span>  put思路：：</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>:flags:  案例测试位置：：  D:\Location\2024常用的工具类收集\littleCollection\src\main\java\concurrentHashMap原理\ConcurrentHashMap006.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;     它代表将<span class="number">1</span>左移<span class="number">30</span>位 <span class="type">int</span> <span class="number">4</span>位  <span class="number">2</span>^<span class="number">4</span>=<span class="number">32</span>  和这个字节数有关  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//       transient 修饰的变量 不进行序列化对象</span></span><br><span class="line">    <span class="comment">//  bin 数组。第一次插入时延迟初始化。 大小始终是 2 的幂。由迭代器直接访问。</span></span><br><span class="line">    <span class="comment">// 数组类型是  链表  Node&lt;K,V&gt;  没有进行初始化定义的数组</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//  onlyIfAbsent 是否存在相同的值，如果有相同值是否替换 true--替换 false相反， evict是否使用构造模式</span></span><br><span class="line"> <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">02</span>---初始化方法中 </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    sizeCtl ：默认为<span class="number">0</span>，用来控制table的初始化和扩容操作</span><br><span class="line">-<span class="number">1</span> 代表table正在初始化</span><br><span class="line">-N 应该取-N对应的二进制的低<span class="number">16</span>位数值为M，此时有M-<span class="number">1</span>个线程进行扩容。（这个地方比较复杂 ，先简单了解？？？）</span><br><span class="line">其余情况：</span><br><span class="line"><span class="number">1</span>、如果table未初始化，表示table需要初始化的大小。</span><br><span class="line"><span class="number">2</span>、如果table初始化完成，表示table的容量，默认是table大小的<span class="number">0.75</span>倍</span><br><span class="line"></span><br><span class="line">    红黑树的演示网站</span><br><span class="line">    https:<span class="comment">//www.cs.usfca.edu/~galles/visualization/RedBlack.html</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/$%7Bimages%7D/image-20250411213108255.png" alt="image-20250411213108255"></p>
<h2 id="currenthashMap大致扩容思路-使用逻辑图最好"><a href="#currenthashMap大致扩容思路-使用逻辑图最好" class="headerlink" title="currenthashMap大致扩容思路(使用逻辑图最好)"></a>currenthashMap大致扩容思路(使用逻辑图最好)</h2><img src="${images}/concurrentHashMap之put原理流程.drawio.png" alt="concurrentHashMap之put原理流程.drawio" style="zoom: 25%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10. 原理总结思路细化：：：</span><br><span class="line">  1.concurrentHashMap没有粗暴的给整个数组加锁 原因是很明显这样线程安全，效率极低。</span><br><span class="line">  2.如果给数组的每个头节点 枷锁 这样并发度就是16 ，提高16倍速，这样数组有多长 并发度就有多少，提高了并发度。</span><br><span class="line">  3.举例 例如现在做一个 加加操作 ，多线程操作一个变量 a，如果给整个变量a 加上排他锁sychr 同意时间碎片只有一个thread，并发度又降下来，不合理。设计者 使用了轻量级的compare and swap方式,同一时间碎片，只有一个线程在操作变量a,其他线程不断在for(;;) 里面循环重试，这样虽然解决所开销的问题，但是效率还是不是很高， 于是设计者又考虑  可以咋失败时候可以新建一个数组counterCells[]  专门负责 失败时候值的 累加，</span><br><span class="line">  4.  put思路：：</span><br></pre></td></tr></table></figure>





<h2 id="concurrenthashmap-和hashMap的有啥区别"><a href="#concurrenthashmap-和hashMap的有啥区别" class="headerlink" title="concurrenthashmap 和hashMap的有啥区别?"></a>concurrenthashmap 和hashMap的有啥区别?</h2><p><img src="/$%7Bimages%7D/image-20250412100743466.png" alt="image-20250412100743466"></p>
<h3 id="细化比较一下-扩容机制的不同"><a href="#细化比较一下-扩容机制的不同" class="headerlink" title="细化比较一下 扩容机制的不同"></a>细化比较一下 扩容机制的不同</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用多线程协同扩容：具体是 从后向前 每个线程负责一段程度，</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码就是 计算扩容 每个线程 负责扩容的片段</span></span><br><span class="line">    <span class="comment">// 当前服务器cpu的  可用的核心线程数</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap选代器是强一致性还是弱一致性？"><a href="#ConcurrentHashMap选代器是强一致性还是弱一致性？" class="headerlink" title="ConcurrentHashMap选代器是强一致性还是弱一致性？"></a>ConcurrentHashMap选代器是强一致性还是弱一致性？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">与HashMap选代器是强一致性不同，ConcurrentHashMap选代器是弱一致性。</span><br><span class="line">ConcurrentHashMap的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</span><br><span class="line">这样送代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</span><br></pre></td></tr></table></figure>

<h2 id="为什么ConcurrentHashMap不充许null值？"><a href="#为什么ConcurrentHashMap不充许null值？" class="headerlink" title="为什么ConcurrentHashMap不充许null值？"></a>为什么ConcurrentHashMap不充许null值？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·主要是为了让ConcurrentHashMap的语义更加准确。</span><br><span class="line">。假如ConcurrentHashMap支持null，那么get方法就会返回null值。那么就会存在一个不确定性，到底这个null是put进去的还是没有找到该key而返回的null呢？</span><br><span class="line">在非并发环境下，这个问题可以通过contains方法来排除。但是，在并发环境下，contains方法执行过程中可能会被其他线程修改而导致结果不准确。</span><br><span class="line">·所以，为了不存在二义性，并发的Map框架一般都是不允许null的。</span><br></pre></td></tr></table></figure>







<h1 id="和-对比"><a href="#和-对比" class="headerlink" title="#和$  对比"></a>#和$  对比</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125;是预编译处理、是占位符， $&#123;&#125;是字符串替换、是拼接符。 </span><br><span class="line">Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为?号，调⽤ PreparedStatement 来赋值； </span><br><span class="line">Mybatis在处理$&#123;&#125;时，会将sql中的$&#123;&#125;替换成变量的值，调⽤ Statement 来赋值； </span><br><span class="line">使⽤#&#123;&#125;可以有效的防⽌ SQL 注⼊， 提⾼系统安全性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据库  https://www.yuque.com/tulingzhouyu/db22bv/dramscudnm47xh5s    ---ztts</span><br></pre></td></tr></table></figure>





<h1 id="常见集合对比-以及数据结构-，-hashMap-LinkedHashMap区别，"><a href="#常见集合对比-以及数据结构-，-hashMap-LinkedHashMap区别，" class="headerlink" title="常见集合对比   以及数据结构  ， hashMap  LinkedHashMap区别，"></a>常见集合对比   以及数据结构  ， hashMap  LinkedHashMap区别，</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">----ArrayList和LinkedList区别</span><br><span class="line"></span><br><span class="line">⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实</span><br><span class="line">现的 </span><br><span class="line">2. </span><br><span class="line">由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合</span><br><span class="line">删除和添加，查询、添加、删除的时间复杂度不同 </span><br><span class="line">3. </span><br><span class="line">另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以</span><br><span class="line">LinkedList还可以当做队列来使⽤ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----HashMap和ArrayList关系对比</span><br><span class="line"></span><br><span class="line">都是线程不安全，不同步</span><br><span class="line"></span><br><span class="line">    2）都可以储存null值</span><br><span class="line"></span><br><span class="line">    3）获取元素个数方法一样，都用size()方法获取</span><br><span class="line">    </span><br><span class="line">    ---其他List  </span><br><span class="line">    CopyOnWriteArrayList 适用于读多写少的并发场景，比如白名单，黑名单等场景</span><br><span class="line">    </span><br></pre></td></tr></table></figure>





<h1 id="stream-和-foreach-对比-性能-，肯定是stream更好"><a href="#stream-和-foreach-对比-性能-，肯定是stream更好" class="headerlink" title="stream 和 foreach  对比 性能 ，肯定是stream更好"></a>stream 和 foreach  对比 性能 ，肯定是stream更好</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从性能角度来看，for循环通常更快一些。这是因为for循环是Java编译器在编译时就可以确定的，而Stream API中的stream()和forEach()方法则需要运行时动态地创建流，这会增加一些额外的开销。</span><br><span class="line">在功能方面，Stream API提供了丰富的操作符，可以方便地对集合进行过滤、映射、排序等操作</span><br><span class="line"></span><br><span class="line">如果数据在1万以内的话，for循环效率高于foreach和stream；</span><br><span class="line">如果数据量在10万的时候，stream效率最高，其次是foreach,最后是for。</span><br><span class="line">另外需要注意的是如果数据达到100万的话，parallelStream异步并行处理效率最高，高于foreach和for</span><br></pre></td></tr></table></figure>





<h1 id="forkJoin的原理以及使用方法-Java-并发编程-——-Fork-Join-框架的原理详解-forkjoin框架原理-CSDN博客"><a href="#forkJoin的原理以及使用方法-Java-并发编程-——-Fork-Join-框架的原理详解-forkjoin框架原理-CSDN博客" class="headerlink" title="forkJoin的原理以及使用方法 Java 并发编程 —— Fork&#x2F;Join 框架的原理详解_forkjoin框架原理-CSDN博客"></a>forkJoin的原理以及使用方法 <a target="_blank" rel="noopener" href="https://blog.csdn.net/mrluo735/article/details/135083092">Java 并发编程 —— Fork&#x2F;Join 框架的原理详解_forkjoin框架原理-CSDN博客</a></h1><p><img src="/$%7Bimages%7D/image-20250505161916657.png" alt="image-20250505161916657"></p>
<img src="${images}/image-20250422203655029.png" alt="image-20250422203655029" style="zoom:67%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">ForkJoinTask  类封装了 数据结构</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">代码位置 测试位置    D:\Location\<span class="number">2024</span>常用的工具类收集\流stream\streamDemo\src\main\java\palaStream</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h1 id="jdk8新增的注解-sun-misc-Contended"><a href="#jdk8新增的注解-sun-misc-Contended" class="headerlink" title="jdk8新增的注解 @sun.misc.Contended"></a>jdk8新增的注解 @sun.misc.Contended</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended 是 Java 8 新增的一个注解，对某字段加上该注解则表示该字段会单独占用一个缓存行（Cache Line）。</span><br><span class="line">单独使用一个缓存行有什么作用——避免伪共享</span><br><span class="line">https://www.cnblogs.com/eycuii/p/11525164.html</span><br></pre></td></tr></table></figure>



<h1 id="了解并发-并行"><a href="#了解并发-并行" class="headerlink" title="了解并发 并行"></a>了解并发 并行</h1><p>  <img src="/$%7Bimages%7D/image-20240710172712752.png" alt="image-20240710172712752"></p>
<p><img src="/$%7Bimages%7D/image-20240805150522195.png" alt="image-20240805150522195"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发三大特性</span><br><span class="line">并发编程Bug的源头：可见性、原子性和有序性问题</span><br><span class="line">volitile  和sync都是 从C语言层面的  通过内存屏障  load store 角度来  ，都可以实现可见性,  volitile不能保证原子性</span><br><span class="line">细节讲述  sync  如何保证 可见性 https:<span class="comment">//blog.csdn.net/chenzengnian123/article/details/122686371</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="什么是指令重排序，load-store"><a href="#什么是指令重排序，load-store" class="headerlink" title="什么是指令重排序，load store"></a>什么是指令重排序，load store</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>-Java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况</span><br><span class="line">的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</span><br><span class="line">指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机</span><br><span class="line">器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</span><br><span class="line">在编译器与CPU处理器中都能执行指令重排优化操</span><br><span class="line">    </span><br><span class="line"><span class="number">01</span>--同样的道理啊，也是通过monitorenter、monitorexit指令嵌入上面的内存屏障；monitorenter、monitorexit这两条指令其实就相当于复合指令，既具有加锁、释放锁的功能，同时也具有内存屏障的功能。</span><br></pre></td></tr></table></figure>



<h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>关键字要点</span><br><span class="line"><span class="number">1.</span>不能对<span class="keyword">final</span>变量再次赋值.</span><br><span class="line"><span class="number">3.</span><span class="keyword">final</span>关键字可以用于局部变量，成员变量、方法以及类.</span><br><span class="line"><span class="number">12.</span>按照Java代码惯例,<span class="keyword">final</span>变量就是常量, 而且通常常量名要大写</span><br><span class="line"><span class="number">13.</span>对于集合对象声明为<span class="keyword">final</span>指的是引用（地址）不能被更改, 但可以向其中增加, 删除或者改变内容.</span><br><span class="line"><span class="number">1.</span>方法前面加上<span class="keyword">final</span>关键字,代表这个方法不可以被子类的方法重写.</span><br><span class="line"><span class="number">2.</span>类名 <span class="keyword">final</span> <span class="keyword">class</span>  <span class="title class_">C</span> ,前面加上<span class="keyword">final</span>关键字,代表这个方法不可以被继承 </span><br><span class="line">    --<span class="number">00</span> 在使用<span class="keyword">final</span>修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为<span class="keyword">final</span>类。--.</span><br><span class="line"><span class="number">10.</span>没有在声明时初始化<span class="keyword">final</span>变量的称为空白<span class="keyword">final</span>变量(blank <span class="keyword">final</span> variable), 必须在构造器中初始化, 或者调用<span class="built_in">this</span>()初始化. 否则编译器会报错.</span><br><span class="line"><span class="number">8.</span>  jdk7  接口中声明的所有变量本身是<span class="keyword">final</span>的（可以不记忆）.</span><br><span class="line"><span class="number">9.</span><span class="keyword">final</span>方法在编译阶段绑定, 称为静态绑定(<span class="keyword">static</span> binding).  </span><br><span class="line"><span class="number">11.</span>将类、方法、变量声明为<span class="keyword">final</span>能够提高性能, 这样JVM就有机会进行估计,然后优化.</span><br></pre></td></tr></table></figure>

<h1 id="接口和抽象类区别"><a href="#接口和抽象类区别" class="headerlink" title="接口和抽象类区别"></a>接口和抽象类区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">实际就是说  01 继承和多态  </span><br><span class="line"></span><br><span class="line">抽象类 是</span><br><span class="line">----</span><br><span class="line">抽象类和抽象方法都必须用abstract修饰符来修饰，抽象方法不能有方法体</span><br><span class="line">2、抽象类有构造器，但不能直接被实例化，要创建对象涉及向上转型，主要是用于被其子类调用</span><br><span class="line">3、抽象类中可以没有抽象方法，但是有抽象方法的类必定是抽象类</span><br><span class="line">4、抽象类中可以包含静态方法</span><br><span class="line">5、抽象类不能用final修饰</span><br><span class="line">6、抽象类不能用private修饰</span><br><span class="line">7、抽象类也是类，一样是用来继承的，接口与类才是实现关系</span><br><span class="line">8、外部抽象类不能用Static修饰，但内部的抽象类可以使用static声明</span><br><span class="line">9、 抽象类可以继承抽象类，抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体非抽象派生类必须覆盖它们</span><br><span class="line">10、 抽象类可以实现接口，可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_44543508/article/details/102609910</span><br></pre></td></tr></table></figure>



<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。</span><br><span class="line"></span><br><span class="line">这里要强调一下：</span><br><span class="line"></span><br><span class="line">static修饰的成员变量和方法，从属于类</span><br><span class="line"></span><br><span class="line">普通变量和方法从属于对象</span><br><span class="line"></span><br><span class="line">静态方法不能调用非静态成员，编译会报错</span><br></pre></td></tr></table></figure>



<h1 id="线程-ThreadLOCAL-常用的线程接口类熟悉-线程队列的使用"><a href="#线程-ThreadLOCAL-常用的线程接口类熟悉-线程队列的使用" class="headerlink" title="线程  ThreadLOCAL   常用的线程接口类熟悉  线程队列的使用"></a>线程  ThreadLOCAL   常用的线程接口类熟悉  线程队列的使用</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102744180">ThreadLocal，一篇文章就够了 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN2497242041/article/details/120192343">https://blog.csdn.net/CSDN2497242041/article/details/120192343</a></p>
<p><img src="/$%7Bimages%7D/image-20250505173757051.png" alt="类 结构"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">使用场景：：</span><br><span class="line"><span class="number">1</span>、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</span><br><span class="line"><span class="number">2</span>、线程间数据隔离</span><br><span class="line"><span class="number">3</span>、进行事务操作，用于存储线程事务信息。</span><br><span class="line"><span class="number">4</span>、数据库连接，Session会话管理。</span><br><span class="line">    -------</span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//通过我们重写initialValue方法获取初始值</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">         <span class="comment">//获取到当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">         <span class="comment">//通过getMap方法，传入当前线程作为参数去获取ThreadLocalMap对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">         <span class="comment">//如果获取到的ThreadLocalMap不为空，就直接存入，否则就创建ThreadLocalMap并存入。</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//key为threadLocal本身，value就是我们业务上需要存储的值</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//获取ThreadLocalMap对象</span></span><br><span class="line">  ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="comment">//重点！！！</span></span><br><span class="line">        <span class="comment">//这里返回的其实就是最上面讲到的每个Thread都会有一个ThreadLocalMap成员变量</span></span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/CSDN2497242041/article/details/120192343</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//首先获取当前线程对象  （    public static native Thread currentThread();）</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取线程中变量 ThreadLocal.ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">//如果不为空，</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);<span class="comment">// ben01</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果为空，初始化该线程对象的map变量，其中key 为当前的threadlocal 变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ben01      ThreadLocal  ,  Connection数据库</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//初始化线程内部变量 threadLocals ，key 为当前 threadlocal</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">         * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">         * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Entry[]  类型数组  key是threadLcoal   Connection数据库</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240417180341915.png" alt="image-20240417180341915"></p>
<p><font  color="red">ThreadLocal会导致内存泄漏问题  ，原因：：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal，线程本地变量，顾名思义，它是每个线程私有的本地变量。通俗点讲，当你创建了一个ThreadLocal变量，每个线程在访问该变量时，都会拷贝一个副本至本地内存，所以多线程下操作ThreadLocal变量时，其实各自都是在操作自己拷贝的副本，互不影响，这样自然而然就避免了线程安全问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">「记住在使用的以后，一定要remove,一定要remove,一定要remove」为什么要remove。因为ThreadLocal会导致内存泄漏问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开启两个线程去操作ThreadLocal变量，从控制台的输出结果，便可以证明我们上面说的定义，每个线程对threadLocal变量的访问与操作互不影响，做到了线程隔离。</span><br><span class="line"></span><br><span class="line">每个线程中都有一个 ThreadLocalMap数据结构，当执行set方法时，其值是保存在当前线程的 threadLocals变量中，当执行get方法中，是从当前线程的 threadLocals变量获取。 (ThreadLocalMap的key值是ThreadLocal类型)</span><br><span class="line"></span><br><span class="line">ThreadLocalMap对象里维护了一个K-V格式的Entry数组，Key存的是ThreadLocal对象本身，value是需要存储的值。当我们要操作ThreadLocal变量时，会先获取当前的线程，根据当前线程拿到对应的ThreadLocalMap对象，进而操作ThreadLocalMap内部数组里存储的数据。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/CSDN2497242041/article/details/120192343,</span><br><span class="line"></span><br><span class="line">judgment  make decide</span><br><span class="line"></span><br><span class="line">因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</span><br></pre></td></tr></table></figure>



<h2 id="内存泄露的原因"><a href="#内存泄露的原因" class="headerlink" title="内存泄露的原因"></a>内存泄露的原因</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java对象的引用包括 ： 强引用，软引用，弱引用，虚引用 。弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，该对象如果被弱引用关联，那么就会被回收。</span><br><span class="line">当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收的。ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 存在内存泄露的风险</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/CSDN2497242041/article/details/120192343</span><br></pre></td></tr></table></figure>







<h1 id="jdbc-执行过程-6个过程-涉及-（-jdbc就是一套接口规范-）"><a href="#jdbc-执行过程-6个过程-涉及-（-jdbc就是一套接口规范-）" class="headerlink" title="jdbc 执行过程  6个过程 涉及 （  jdbc就是一套接口规范 ）"></a>jdbc 执行过程  6个过程 涉及 （  jdbc就是一套接口规范 ）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 三、JDBC的基本执行流程</span><br><span class="line">1加载数据库驱动程序：通过反射的方式加载驱动包，现在基本无需手动添加驱动包了。</span><br><span class="line"></span><br><span class="line">2建立数据库连接：使用DriverManager.getConnection()方法创建与数据库的连接，需要提供数据库的URL、用户名和密码。</span><br><span class="line"></span><br><span class="line">3创建Statement对象：使用connection.createStatement()方法创建一个Statement对象，用于执行SQL语句。</span><br><span class="line"></span><br><span class="line">4执行SQL语句：使用Statement对象的executeQuery()方法执行查询语句，或者使用executeUpdate()方法执行更新语句。</span><br><span class="line"></span><br><span class="line">5处理结果集：如果执行的是查询语句，可以使用ResultSet对象来处理查询结果。</span><br><span class="line"></span><br><span class="line">6 关闭连接：使用connection.close()方法关闭数据库连接，释放资源</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_72172339/article/details/131847398</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_72172339/article/details/131847398</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">01  利用反射创建数据库连接</span><br></pre></td></tr></table></figure>

<h1 id="死锁出现情况-解决办法（破坏死锁成立条件的四个其中一个—来自-抖音检索-mic）"><a href="#死锁出现情况-解决办法（破坏死锁成立条件的四个其中一个—来自-抖音检索-mic）" class="headerlink" title="死锁出现情况  解决办法（破坏死锁成立条件的四个其中一个—来自 抖音检索  mic）"></a>死锁出现情况  解决办法（破坏死锁成立条件的四个其中一个—来自 抖音检索  mic）</h1><img src="${images}/image-20240711140337640.png" alt="image-20240711140337640" style="zoom:8%;" />







<img src="${images}/image-20240711140415942.png" alt="image-20240711140415942" style="zoom:10%;" />



<h1 id="如何优雅的终止线程-–存在一种一种线程中断机制-3个对比（线程并发的知识点）"><a href="#如何优雅的终止线程-–存在一种一种线程中断机制-3个对比（线程并发的知识点）" class="headerlink" title="如何优雅的终止线程  –存在一种一种线程中断机制   3个对比（线程并发的知识点）"></a>如何优雅的终止线程  –存在一种一种线程中断机制   3个对比（线程并发的知识点）</h1><p><img src="/$%7Bimages%7D/image-20230602215952873.png" alt="image-20230602215952873"></p>
<p><img src="/$%7Bimages%7D/image-20240805195931149.png" alt="image-20240805195931149"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如何优雅的停止一个线程</span><br><span class="line">我们知道线程只有从 runnable 状态（可运行/运行状态） 才能进入terminated 状态（终止状态），如果线程处于 blocked、waiting、timed_waiting 状态（休眠状态），就需要通过 Thread 类的 interrupt() 方法，让线程从休眠状态进入 runnable 状态，从而结束线程。</span><br><span class="line"></span><br><span class="line">这里就涉及到了一个概念“线程中断”，这是一种协作机制，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的时机中断请求，也可以完全不处理继续执行下去，这样一来，安全性就得到了保障。</span><br><span class="line"></span><br><span class="line">Thread类中提供线程中断的方法如下：</span><br><span class="line"></span><br><span class="line">Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为 true（默认是 flase）；</span><br><span class="line">Thread.currentThread().isInterrupted()：测试当前线程是否被中断。线程的中断状态会受这个方法的影响，调用一次可以使线程中断状态变为 true，调用两次会使这个线程的中断状态重新转为 false；</span><br><span class="line">Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_43506040/article/details/136661151</span><br></pre></td></tr></table></figure>



<h1 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h1><p>   b: 事务的基本属性包括：{事务属性包含了几个方面：传播行为、隔离规则、回滚规则、事务超时、是否只读；}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、原子性（Atomicity）：事务开始后所有操作，要么全部完成，要么全部不完成，不可能停滞在中间环节。事务执行过程中出错，会回滚（Rollback）到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位</span><br><span class="line">2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到，统一性，一件事情的合理性，</span><br><span class="line">3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账</span><br><span class="line">4、持久性（Durability）：事务完成后，该事务所对数据库所作的更改将被保存到数据库之中，不能回滚</span><br><span class="line"></span><br><span class="line">Mysql怎么保证原子性的？OK，是利用Innodb的undo log。</span><br><span class="line">undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="不可修改的-对象"><a href="#不可修改的-对象" class="headerlink" title="不可修改的 对象"></a>不可修改的 对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 String   </span><br><span class="line">2 bigDecimal</span><br></pre></td></tr></table></figure>

<h1 id="内核态和用户态区别"><a href="#内核态和用户态区别" class="headerlink" title="内核态和用户态区别"></a>内核态和用户态区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/gizing/p/10925286.html</span><br><span class="line">有必要说一下 C P U 指令集，指令集是 C P U 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 C P U 指令，而非常非常多的 C P U 指令 在一起，可以组成一个、甚至多个集合，指令的集合叫 C P U 指令集。</span><br><span class="line"></span><br><span class="line">同时 C P U 指令集 有权限分级，大家试想，C P U 指令集 可以直接操作硬件的，要是因为指令操作的不规范`，造成的错误会影响整个计算机系统的</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">内核态（Kernel Mode）：运行操作系统程序，操作硬件</span><br><span class="line"></span><br><span class="line">用户态（User Mode）：运行用户程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">3.特权级别</span><br><span class="line">特权环：R0、R1、R2和R3</span><br><span class="line"></span><br><span class="line">R0相当于内核态，R3相当于用户态；</span><br><span class="line"></span><br><span class="line">不同级别能够运行不同的指令集合；</span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">用户态与内核态</span><br><span class="line">通关了C P U 指令集权限，现在再说用户态与内核态就十分简单了，用户态与内核态的概念就是C P U 指令集权限的区别，进程中要读写    I/O，必然会用到 ring 0 级别的 C P U 指令集，而此时 C P U 的指令集操作权限只有 ring 3，为了可以操作ring 0 级别的 C P U 指令集， C P U 切换指令集操作权限级别为 ring 0，C P U再执行相应的ring 0 级别的 C P U 指令集（内核代码），执行的内核代码会使用当前进程的内核栈。</span><br><span class="line"></span><br><span class="line">PS：每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">01  处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。</span><br></pre></td></tr></table></figure>



<h1 id="线程模型三种（选择多对多）和线程状态"><a href="#线程模型三种（选择多对多）和线程状态" class="headerlink" title="线程模型三种（选择多对多）和线程状态"></a>线程模型三种（选择多对多）和线程状态</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lihaidong1991/article/details/88861123">三种线程模型_多线程模型有哪几种类型?多对一模型有何优缺点?-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态  runnable 就绪</span><br><span class="line">   running </span><br><span class="line">   minitor 监控(blocked)</span><br><span class="line">   dead</span><br><span class="line">   </span><br><span class="line">   notifyAll()  释放当前线程的锁，当前线程进入wait</span><br></pre></td></tr></table></figure>



<h1 id="放重复提交方案"><a href="#放重复提交方案" class="headerlink" title="放重复提交方案"></a>放重复提交方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/xxxxg_xg/article/details/136656789</span><br><span class="line">LRUMap</span><br></pre></td></tr></table></figure>



<h1 id="数据库连接池爆满解决方案"><a href="#数据库连接池爆满解决方案" class="headerlink" title="数据库连接池爆满解决方案"></a>数据库连接池爆满解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先排查问题</span><br><span class="line">1  看日志  ，数据库监控面板和工具， 普罗米修斯， </span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/weixin_40482816/article/details/116599618</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xuezhangjun0121/article/details/105440901">show full processlist；命令详解 - MySQL_show full processlist;-CSDN博客</a></p>
<h1 id="现场过多日志提示啥错误"><a href="#现场过多日志提示啥错误" class="headerlink" title="现场过多日志提示啥错误"></a>现场过多日志提示啥错误</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OutOfMemoryError</span><br><span class="line"></span><br><span class="line">在Java编程中，多线程是一种重要的编程方式，可以充分利用多核处理器的优势，提高程序的并发性和性能。然而，如果线程数过多，就会出现一系列的问题，甚至导致程序崩溃</span><br><span class="line"></span><br><span class="line">原因分析：：</span><br><span class="line"></span><br><span class="line">01  线程也是对象 ，当创建过多的线程时，会导致JVM的内存资源耗尽。当线程被创建时，JVM会为每个线程分配一块堆栈内存，用于保存线程的执行上下文。如果线程数过多，JVM的堆栈内存将会被耗尽，引发“OutOfMemoryError”异常。</span><br><span class="line"></span><br><span class="line">02 除了内存资源外，线程数过多还会占用其他系统资源，如CPU、I/O等。当线程数过多时，这些系统资源会被过度占用，导致系统性能下降，甚至造成系统崩溃。</span><br><span class="line"></span><br><span class="line">解决方案：通过合理设置线程数，避免过度占用系统资源，并且可以使用线程池来限制线程数。</span><br></pre></td></tr></table></figure>



<h1 id="数据库连接池和redis连接池-对比学习"><a href="#数据库连接池和redis连接池-对比学习" class="headerlink" title="数据库连接池和redis连接池 对比学习"></a>数据库连接池和redis连接池 对比学习</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis  为每次数据交互都需要先建立连接，假设一次数据交互总共用时30ms，超高性能的Redis数据库处理数据所花的时间可能不到1ms，也即是说前期的连接占用了29ms，连接池则可以实现在客户端建立多个链接并且不释放，当需要使用连接的时候通过一定的算法获取已经建立的连接，使用完了以后则还给连接池，这就免去了数据库连接所占用的时间</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="mybaits优点以及动态sql实现"><a href="#mybaits优点以及动态sql实现" class="headerlink" title="mybaits优点以及动态sql实现"></a>mybaits优点以及动态sql实现</h1><img src="${images}/1218593-20240426100039088-2002035695.png" alt="img" style="zoom:50%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Black_Customer/article/details/107403819">【mybatis】mybatis的特性和优势_mybatis的特性及优点-CSDN博客</a></p>
<h1 id="spring-bean是线程安全吗"><a href="#spring-bean是线程安全吗" class="headerlink" title="spring  bean是线程安全吗"></a>spring  bean是线程安全吗</h1><img src="${images}/spring_bean线程安全.jpg" alt="spring_bean线程安全" style="zoom:15%;" />

<h1 id="springboot-三个大注解-之一-EnableAutoConfiguration-工作原理-（涉及自动装配）"><a href="#springboot-三个大注解-之一-EnableAutoConfiguration-工作原理-（涉及自动装配）" class="headerlink" title="springboot 三个大注解    之一  @EnableAutoConfiguration  工作原理  （涉及自动装配）"></a>springboot 三个大注解    之一  @EnableAutoConfiguration  工作原理  <font  color="red">（涉及自动装配）</font></h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Spring Boot自动装配原理(易懂)_springboot自动装配原理-CSDN博客](https://blog.csdn.net/qq_41805567/article/details/129111183)</span><br><span class="line"></span><br><span class="line">[深入理解Spring Boot Starter：概念、特点、场景、原理及自定义starter-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2398558)</span><br><span class="line"></span><br><span class="line">[深入理解 Spring Boot Starters 原理（手写Spring boot Start）_springboot started-CSDN博客](https://blog.csdn.net/zhaohong_bo/article/details/89924053)---自定义  starter启动自动配置</span><br></pre></td></tr></table></figure>



<img src="${images}/image-20240806115005019.png" alt="image-20240806115005019" style="zoom:67%;" />

<p><img src="/$%7Bimages%7D/image-20240806115339948.png" alt="image-20240806115339948"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主动扫描 maven 引入的jar是标记<span class="number">1</span> 出的引入的  注解</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SpringFactoriesLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The location to look for factories.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="Spring-Boot如何实现配置文件的自动加载和刷新？"><a href="#Spring-Boot如何实现配置文件的自动加载和刷新？" class="headerlink" title="Spring Boot如何实现配置文件的自动加载和刷新？"></a>Spring Boot如何实现配置文件的自动加载和刷新？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">试用注解@Value</span><br><span class="line"></span><br><span class="line">直接通过@Value注解，将一个对象得成员变量与Environment中的配置进行绑定</span><br></pre></td></tr></table></figure>







<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p><img src="/$%7Bimages%7D/image-20250311180721292.png" alt="image-20250311180721292"></p>
<h1 id="spring-依赖注入-Resource和autowire区别"><a href="#spring-依赖注入-Resource和autowire区别" class="headerlink" title="spring   依赖注入  Resource和autowire区别"></a>spring   依赖注入  Resource和autowire区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，</span><br><span class="line"></span><br><span class="line">2、不同点</span><br><span class="line"></span><br><span class="line">（1）@Autowired--framework</span><br><span class="line"></span><br><span class="line">@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</span><br><span class="line"></span><br><span class="line">@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。(通过类型匹配找到多个candidate,在没有@Qualifier、@Primary注解的情况下，会使用对象名作为最后的fallback匹配)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（2）@Resource</span><br><span class="line">@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。</span><br><span class="line">所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。</span><br><span class="line">如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h1 id="spring三级缓存-循环依赖"><a href="#spring三级缓存-循环依赖" class="headerlink" title="spring三级缓存 循环依赖"></a>spring三级缓存 循环依赖</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">三级缓存有什么区别?</span><br><span class="line">一级缓存</span><br><span class="line">一级缓存里存的是成品对象，实例化和初始化都完成了，我们的应用中使用的对象就是一级缓存中的</span><br><span class="line"></span><br><span class="line">二级缓存</span><br><span class="line">二级缓存中存的是半成品，没有完成属性注入和初始化，用来解决对象创建过程中的循环依赖问题</span><br><span class="line">早期暴露出去的Bean，其实也就是解决循环依赖的Bean。早期的意思就是没有完完全全创建好，但是由于有循环依赖，就需要把这种Bean提前暴露出去。其实 早期暴露出去的Bean 跟 完完全全创建好的Bean 他们是同一个对象，只不过早期Bean里面的注解可能还没处理，完完全全的Bean已经处理了完了，但是他们指的还是同一个对象，只不过它们是在Bean创建过程中处于的不同状态</span><br><span class="line"></span><br><span class="line">三级缓存</span><br><span class="line">三级缓存中存的是 ObjectFactory&lt;?&gt; 类型的代理工厂对象，用于处理存在 AOP 时的循环依赖问题</span><br><span class="line">存的是每个Bean对应的ObjectFactory对象，通过调用这个对象的getObject方法，就可以获取到早期暴露出去的Bean。</span><br><span class="line">注意：这里有个很重要的细节就是三级缓存只会对==单例的Bean生效==，像多例的是无法利用到三级缓存的，通过三级缓存所在的类名DefaultSingletonBeanRegistry就可以看出，仅仅是对SingletonBean也就是单例Bean有效果。、</span><br><span class="line">&#123; == 在这个过程中，Spring采用了单例模式，确保每个Bean只会被创建一次。 然而，单例模式在处理循环依赖时可能会遇到问题，因为Bean在初始化过程中可能还需要其他未完全初始化的Bean。==&#125;</span><br></pre></td></tr></table></figure>

<h1 id="spring事务-注解（事务的aop和代理对象的实现逻辑）"><a href="#spring事务-注解（事务的aop和代理对象的实现逻辑）" class="headerlink" title="spring事务   注解（事务的aop和代理对象的实现逻辑）"></a>spring事务   注解（事务的aop和代理对象的实现逻辑）</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91779567">手把手带你实战下Spring的七种事务传播行为 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/happydecai/article/details/80338053">Spring事务的传播：PROPAGATION_REQUIRED_propagation.required-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/abc19900828/article/details/39497631">Spring事务管理只对出现运行期异常进行回滚_只有运行时异常才能回滚-CSDN博客</a></p>
<p><img src="/2025/03/02/hello-world/intervwSummary/image-20240712111316519.png" alt="image-20240712111316519"></p>
<p><img src="/$%7Bimages%7D/image-20240712111316519.png" alt="image-20240712111316519"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-----  7种事务的传播机制 记忆使用表格方式更好。</span><br><span class="line">TransactionInterceptor就是代理逻辑，当某个类中存在@Transactional注解时，到时就产生一个代理对象作为Bean，代理对象在执行某个方法时，最终就会进入到TransactionInterceptor的invoke()方法。</span><br><span class="line"></span><br><span class="line">1. 利用所配置的PlatformTransactionManager事务管理器新建一个数据库连接</span><br><span class="line">2. 修改数据库连接的autocommit为false</span><br><span class="line">3. 执行MethodInvocation.proceed()方法，简单理解就是执行业务方法，其中就会执行sql</span><br><span class="line">4. 如果没有抛异常，则提交</span><br><span class="line">5. 如果抛了异常，则回滚</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----关于  抛异常回滚细化</span><br><span class="line"></span><br><span class="line">使用spring难免要用到spring的事务管理，要用事务管理又会很自然的选择声明式的事务管理，在spring的文档中说道，spring声明式事务管理默认对非检查型异常和运行时异常进行事务回滚，而对检查型异常则不进行回滚操作。</span><br><span class="line">那么什么是检查型异常什么又是非检查型异常呢？</span><br><span class="line">最简单的判断点有两个：</span><br><span class="line">1.继承自runtimeexception或error的是非检查型异常，而继承自exception的则是检查型异常（当然，runtimeexception本身也是exception的子类）。</span><br><span class="line">2.对非检查型类异常可以不用捕获，而检查型异常则必须用try语句块进行处理或者把异常交给上级方法处理总之就是必须写代码处理它。所以必须在service捕获异常，然后再次抛出，这样事务方才起效。</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line"></span><br><span class="line">在spring的事务管理环境下，使用unckecked exception可以极大地简化异常的处理，只需要在事务层声明可能抛出的异常（这里的异常可以是自定义的unckecked exception体系），在所有的中间层都只是需要简单throws即可，不需要捕捉和处理，直接到最高层，比如UI层再进行异常的捕捉和处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----事务嵌套概念</span><br><span class="line">事务的嵌套概念</span><br><span class="line">所谓事务的嵌套就是两个事务方法之间相互调用。spring事务开启 ，或者是基于接口的或者是基于类的代理被创建（ 注意一定要是代理，不能手动new 一个对象，并且此类（有无接口都行）一定要被代理——spring中的bean只要纳入了IOC管理都是被代理的 ）。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/happydecai/article/details/80338053</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="spring-如何操作数据库事务的源码"><a href="#spring-如何操作数据库事务的源码" class="headerlink" title="spring 如何操作数据库事务的源码"></a>spring 如何操作数据库事务的源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">PlatformTransactionManager</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行原始方法之前的操作，即获取connection，设置threadlocal，开启事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">        <span class="comment">//模板方法1</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache debug flag to avoid repeated checks.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (definition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">            definition = <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模板方法2，判断是否已存在事务，有事务注解的方法调其他有事务注解方法时会走这</span></span><br><span class="line">        <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">            <span class="comment">//有存在的事务时，根据事务传播行为区别处理</span></span><br><span class="line">            <span class="comment">//1.传播行为是PROPAGATION_NEVER，表示不使用当前事务，抛出异常</span></span><br><span class="line">            <span class="comment">//2.如果是PROPAGATION_NOT_SUPPORTED，表示不支持当前事务，而是始终以非事务方式执行，和最下面else逻辑一样</span></span><br><span class="line">            <span class="comment">//3.如果是PROPAGATION_REQUIRES_NEW，表示新建事务，和下面创建新事务逻辑一样</span></span><br><span class="line">            <span class="comment">//4.如果是PROPAGATION_NESTED，表示如果当前事务存在，则在嵌套事务中执行，否则和PROPAGATION_REQUIRED逻辑一样（和下面创建新事务逻辑一样）</span></span><br><span class="line">            <span class="comment">//5.如果注入validateExistingTransaction为true，比较definition的隔离等级，ReadOnly和TransactionSynchronizationManager中的对应配置比较，抛出异常</span></span><br><span class="line">            <span class="comment">//6.和最下面else逻辑一样</span></span><br><span class="line">            <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对事务注解属性值做一些判断</span></span><br><span class="line">        <span class="comment">//超时设置为&lt;0会报错</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, definition.getTimeout());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有存在的事务时，根据事务传播行为区别处理</span></span><br><span class="line">        <span class="comment">//1.PROPAGATION_MANDATORY会使用当前事务，所以报错</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">                    <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面三种都会创建新事务,事务注解默认是PROPAGATION_REQUIRED</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">                definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">                definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">            <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]: &quot;</span> + definition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//拿注入的transactionSynchronization属性比较，默认不等于SYNCHRONIZATION_NEVER</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">                <span class="comment">//创建新的</span></span><br><span class="line">                <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">                        definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">                <span class="comment">//模板方法，重点！！！        </span></span><br><span class="line">                doBegin(transaction, definition);</span><br><span class="line">                <span class="comment">//设置threadlocal相关</span></span><br><span class="line">                prepareSynchronization(status, definition);</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">                resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实际没有开启事务，但是同步了一些配置到线程</span></span><br><span class="line">            <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + definition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//默认是</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">            <span class="comment">//先newTransactionStatus，再prepareSynchronization，没有doBegin方法</span></span><br><span class="line">            <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>#事务隔离级别</p>
<p>spring默认的隔离级别（可重复读）不能避免 幻读</p>
<p>幻读的INNODB解决办法  RR隔离级别+间隙锁</p>
<p><font color='red'>幻读的INNODB解决办法  RR隔离级别+Next-Key Lock  解决幻读</font></p>
<img src="${images}/image-20240712111316519.png" alt="image-20240712111316519" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">对于脏读、不可重复读和幻读的解释：</span><br><span class="line"></span><br><span class="line">脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据。如果一个事务可以读取未提交的数据，则会发生脏读。</span><br><span class="line"></span><br><span class="line">不可重复读（Non-repeatable Read）：指在同一个事务中，多次读取同一行数据时，得到的结果不一致。这是因为在读取期间，另一个事务修改了该行数据。</span><br><span class="line"></span><br><span class="line">幻读（Phantom Read）：指在同一个事务中，多次查询  同一个范围  的数据时，得到的结果集不一致。这是因为在查询期间，另一个事务插入或删除了符合查询条件的数据。---（ ）</span><br><span class="line"></span><br><span class="line">-----每个隔离级别对这些问题的解决情况如下：</span><br><span class="line"></span><br><span class="line">=====对于任何隔离级别，表级别的表锁、元数据锁、意向锁都是会使用的，但对于行级别的锁则会有些许差别</span><br><span class="line"></span><br><span class="line">读未提交（Read Uncommitted）：允许脏读、不可重复读和幻读。一个事务可以读取另一个事务未提交的数据。----（*****只会使用记录锁，不会用间隙锁***）</span><br><span class="line"></span><br><span class="line">读已提交（Read Committed）：避免脏读。一个事务只能读取已提交的数据。但是，可能发生不可重复读和幻读，因为在同一个事务中，另一个事务可能会修改数据。---（***使用行锁可以解决，在读取之前加上行锁，其他事务不能修改****）</span><br><span class="line">----（*****只会使用记录锁，不会用间隙锁***）</span><br><span class="line"></span><br><span class="line">可重复读（Repeatable Read）：避免脏读和不可重复读。在同一个事务中，多次读取同一行数据时，得到的结果是一致的。但是，可能发生幻读，因为在同一个事务中，另一个事务可能会插入或删除数据。（得到的结果是一致为V=5，可能删除再次插入5）-----(***会使用记录锁、间隙锁和 Next-Key 锁。****)</span><br><span class="line"></span><br><span class="line">串行化（Serializable）：避免脏读、不可重复读和幻读。事务串行执行，保证了数据的一致性和完整性。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/m0_60353039/article/details/131823737</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240711110723793.png" alt="image-20240711110723793"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 数据库隔离级别修改</span><br><span class="line"> </span><br><span class="line"> 01---- 查看当前session的自动提交状态  ,查询是否是自动提交</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">02---设置不要自动提交</span><br><span class="line">SET @@autocommit=0;</span><br><span class="line">03--可以使用如下语句来查询全局事务隔离级别global 和当前连接的事务隔离级别</span><br><span class="line">select @@global.tx_isolation,@@tx_isolation</span><br><span class="line"></span><br><span class="line"> SELECT @@tx_isolation;</span><br><span class="line"> SELECT @@session.tx_isolation;</span><br><span class="line"> SELECT @@global.tx_isolation;</span><br><span class="line">select @@tx_isolation; //查看当前session的隔离级别</span><br><span class="line"></span><br><span class="line">04-- 如果隔离级别不对可以 修改</span><br><span class="line">// 设置当前session的隔离级别为可重复读</span><br><span class="line"></span><br><span class="line">set @@global.tx_isolation = &#x27;READ-UNCOMMITTED&#x27;;      //全局</span><br><span class="line">set @@session.tx_isolation = &#x27;READ-UNCOMMITTED&#x27;;     //当前session</span><br><span class="line">set @@tx_isolation = &#x27;READ-UNCOMMITTED&#x27;;             //仅对下一个事务生效</span><br><span class="line"></span><br><span class="line">set tx_isolation=&#x27;repeatable-read&#x27;; </span><br><span class="line">set tx_isolation=&#x27;repeatable-read&#x27;; // 设置当前session的隔离级别为可重复读</span><br><span class="line"></span><br><span class="line">-- 查询发现都是 REPEATABLE-READ</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ABOOMMMMM/article/details/117754777">可重复读隔离级别如何解决脏读、不可重复读_可重复读怎么解决不可重复读-CSDN博客</a></p>
<p><img src="/$%7Bimages%7D/image-20240807105315479.png" alt="image-20240807105315479"></p>
<p><img src="/$%7Bimages%7D/image-20240807105340582.png" alt="image-20240807105340582"></p>
<h1 id="spring多线程事务为啥不能保证原子性"><a href="#spring多线程事务为啥不能保证原子性" class="headerlink" title=" spring多线程事务为啥不能保证原子性"></a><font style="bold"  color="coral"> spring多线程事务为啥不能保证原子性</font></h1><img src="${images}/多线程不能保证事务原子性.jpg" alt="多线程不能保证事务原子性" style="zoom:15%;" />

<p>2pc–3pc,</p>
<h1 id="springMVC-工作流程–直接看下面连接"><a href="#springMVC-工作流程–直接看下面连接" class="headerlink" title="springMVC 工作流程–直接看下面连接"></a>springMVC 工作流程–直接看下面连接</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_38760069/article/details/96479412">springMVC的主要组件有哪些？springMVC的工作流程？_sqring mvc的主要主件-CSDN博客</a></p>
<p><img src="/$%7Bimages%7D/image-20240806203728392.png" alt="image-20240806203728392"></p>
<p>#：  数据库的 行锁和列锁  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52678870">深入理解数据库行锁与表锁 - 知乎 (zhihu.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">INNoDB 表锁和行锁是该存储引擎中非常重要的锁机制</span><br><span class="line"></span><br><span class="line">表锁是一种互斥锁，用于控制对整个表的并发访问。</span><br><span class="line">而行锁则是一种共享锁，允许事务同时读取和更新表中的不同数据行。这两种锁类型在使用上有很大区别</span><br><span class="line"></span><br><span class="line">表锁在锁入门InnoDB存储引擎中有两种类型：读写锁和排他锁。</span><br><span class="line">读写锁允许一个事务读取表中的数据，同时允许其他事务并发地读取或修改表中的数据。</span><br><span class="line">排他锁则只允许一个事务对整个表进行读写操作，其他事务只能等待该事务释放锁后才能进行操作。</span><br><span class="line"></span><br><span class="line">行锁在钟入门InnoDB存储引擎中也有两种类型：共享锁和排他锁。</span><br><span class="line">共享锁允许一个事务读取表中的某一行数据，同时允许其他事务并发地读取或修改该表中的其他行数据。</span><br><span class="line">排他锁则只允许一个事务对整行数据进行读写操作，其他事务只能等待该事务释放锁后才能进行操作</span><br><span class="line"></span><br><span class="line">在锁入门InnoDB存储引擎中，行锁比表锁具有更高的并发性能。因为行锁只锁定了需要操作的数据行，而不是整个表，所以可以大大降低锁的开销。特别是在高并发的情况下，使用行锁可以显著提高数据库的吞吐量和响应速度。</span><br><span class="line"></span><br><span class="line">然而，在某些场景下，使用表锁可能更适合。比如，在需要对整个表进行批量操作时，使用表锁可以避免对每一行进行重复锁定，从而提高效率。此外，在事务需要更新表中大部分数据时，使用表锁也可以减少锁定开销。</span><br><span class="line"></span><br><span class="line">---在使用这些锁机制时，需要注意以下几个问题：</span><br><span class="line"></span><br><span class="line">死锁问题：如果两个或多个事务互相等待对方释放锁，就会产生死锁。为避免死锁，应尽量减少事务持有锁的时间，并按照一定的顺序获取锁。</span><br><span class="line">争用问题：当多个事务尝试同时访问同一资源时，可能发生争用。为减少争用，可以考虑使用适当的隔离级别和锁类型，以及优化事务的执行顺序。</span><br><span class="line">总之，锁入门InnoDB存储引擎中的表锁和行锁是两种非常重要的锁机制。在实际应用中，根据具体的业务场景和需求选择合适的锁类型，灵活运用并注意避免潜在的问题，是充分发挥InnoDB存储引擎优势的关键。随着数据库技术的不断发展，我们相信未来钟入门InnoDB存储引擎的锁机制还将不断优化和完善，为更多应用场景提供更高效、更稳定的支持。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="sql语句-查询方式联合查询"><a href="#sql语句-查询方式联合查询" class="headerlink" title="sql语句  查询方式联合查询"></a>sql语句  查询方式联合查询</h1><p>SQL联合查询（内联、左联、右联、全联）的语法  1)Inner join 2)left outer join 3)right outer join 4)full outer join</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　如果想把用户信息、积分、等级都列出来，那么一般会这样写：select * from T1 ,T3 where T1.userid = T3.userid(其实这样的结果等同于select * from T1 inner join T3 on T1.userid=T3.userid )。</span><br><span class="line"></span><br><span class="line">　　把两个表中都存在userid的行拼成一行(即内联)，但后者的效率会比前者高很多，建议用后者(内联)的写法</span><br></pre></td></tr></table></figure>

<h1 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h1><ul>
<li><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</p>
</li>
<li><p>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</p>
</li>
<li><p>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</p>
</li>
<li><p>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
</li>
<li><p>HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p>
</li>
</ul>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p> [TCP为什么需要三次握手？用最通俗的话解释给你听-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/daocaokafei/article/details/120189376#:~:text=The">https://blog.csdn.net/daocaokafei/article/details/120189376#:~:text=The</a> principle reason for the three-way handshake is,from causing confusion. 翻译为中文大致意思是主要原因是为了防止旧的重复连接引起连接混乱问题 比如在网络环境比较复杂的情况，客户端可能会连续发送多次请求。 如果只设计成两次握手的情况，服务端只能一直接收请求，然后返回请求信息，也不知道客户端是否请求成功。 这些过期请求的话就会造成网络连接的混乱。 所以设计成三次握手的情况，客户端在接收到服务端SEQ%2B1的返回消息之后，就会知道这个连接是历史连接，所以会发送报文给服务端，告诉服务端。)</p>
<p><img src="/$%7Bimages%7D/image-20240319140506785.png" alt="三次握手的过程"></p>
<h1 id="大型项目springcloud-和-zookeeper-dubbo：：-项目对比原因-选型-原因"><a href="#大型项目springcloud-和-zookeeper-dubbo：：-项目对比原因-选型-原因" class="headerlink" title="大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因"></a>大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因</h1><h1 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a>Spring中的事务是如何实现的</h1><p>Spring中的事务是如何实现的 47 1. Spring事务底层是基于数据库事务和AOP机制的 2. ⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean 3. 当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解 4. 如果加了，那么则利⽤事务管理器创建⼀个数据库连接 5. 并且修改数据库连接的autocommit属性为false，禁⽌此连接的⾃动提交，这是实现Spring事务⾮ 常重要的⼀步 6. 然后执⾏当前⽅法，⽅法中会执⾏sql 7. 执⾏完当前⽅法后，如果没有出现异常就直接提交事务 8. 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务 9. &#x3D;&#x3D;Spring事务的隔离级别对应的就是数据库的隔离级别&#x3D;&#x3D;  10.<font color="skyblue">    Spring事务的传播机制是Spring事务⾃⼰实现的，也是Spring事务中最复杂的 。  12.Spring事务的传播机制是基于数据库连接来做的，⼀个数据库连接⼀个事务，如果传播机制配置为 需要新开⼀个事务，那么实际上就是先建⽴⼀个数据库连接，在此新数据库连接上执⾏sql </font></p>
<img src="${images}/Spring事务的底层实现流程 (1).png" alt="Spring事务的底层实现流程 (1)" style="zoom:67%;" />



<h1 id="事务失效的原因"><a href="#事务失效的原因" class="headerlink" title="::  事务失效的原因"></a>::  事务失效的原因</h1><p><img src="/$%7Bimages%7D/image-20240710165516753.png" alt="image-20240710165516753"></p>
<h1 id="Spring容器启动流程是怎样的"><a href="#Spring容器启动流程是怎样的" class="headerlink" title="Spring容器启动流程是怎样的"></a>Spring容器启动流程是怎样的</h1><ol>
<li><p>在创建Spring容器，也就是启动Spring时： </p>
<ol start="2">
<li>⾸先会进⾏扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中Spring容器启动流程是怎样的</li>
</ol>
</li>
<li><p>然后筛选出⾮懒加载的单例BeanDefinition进⾏创建Bean，对于多例Bean不需要在启动过程中去 进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建     4. 利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推断 构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始化 后这⼀步骤中 5. 单例Bean创建完了之后，Spring会发布⼀个容器启动事件 6. Spring启动结束 7. 在源码中会更复杂，⽐如源码中会提供⼀些模板⽅法，让⼦类来实现，⽐如源码中还涉及到⼀些 BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过 BenaFactoryPostProcessor来实现的，依赖注⼊就是通过BeanPostProcessor来实现的 8. 在Spring启动过程中还会去处理@Import等注解</p>
</li>
</ol>
<p>   流程如下图—</p>
<img src="${images}/Spring888-1720616917264.png" alt="Spring888" style="zoom:9%;" />







<h1 id="Spring中的Bean创建的⽣命周期有哪些步骤"><a href="#Spring中的Bean创建的⽣命周期有哪些步骤" class="headerlink" title="Spring中的Bean创建的⽣命周期有哪些步骤"></a>Spring中的Bean创建的⽣命周期有哪些步骤</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Spring中⼀个Bean的创建⼤概分为以下⼏个步骤：</span><br><span class="line">1. </span><br><span class="line">推断构造⽅法</span><br><span class="line">2. </span><br><span class="line">实例化</span><br><span class="line">3. </span><br><span class="line">填充属性，也就是依赖注⼊</span><br><span class="line">4. </span><br><span class="line">处理Aware回调</span><br><span class="line">5. </span><br><span class="line">初始化前，处理@PostConstruct注解</span><br><span class="line">6. </span><br><span class="line">初始化，处理InitializingBean接⼝</span><br><span class="line">7. </span><br><span class="line">初始化后，进⾏AOP</span><br></pre></td></tr></table></figure>



<img src="${images}/bean周期.png" alt="bean周期" style="zoom:50%;" />



<h1 id="spring事务管理和mysql事务有什么关系？"><a href="#spring事务管理和mysql事务有什么关系？" class="headerlink" title="spring事务管理和mysql事务有什么关系？"></a>spring事务管理和mysql事务有什么关系？</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358657396">【spring源码深度解析】：spring是如何利用@Transactional注解实现数据库事务的？把握住事务的基本用法你就懂了 - 知乎 (zhihu.com)</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">一个简单sql事务</span><br><span class="line"></span><br><span class="line">可见由三步组成：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 开启事务</span><br><span class="line"><span class="number">2.</span> 业务sql执行</span><br><span class="line"><span class="number">3.</span> 提交/回滚事务</span><br><span class="line"></span><br><span class="line">java代码操作数据库的六步（  <span class="number">6</span>个过程 涉及   连接 .....)</span><br><span class="line"></span><br><span class="line">保证事务的很重要的一点是,始终用一个连接connection，唯一的connection才能保证当前事务的ACID四大属性，</span><br><span class="line"></span><br><span class="line">所以被调用方法里有操作数据库时也需要用这个主方法中创建的connection。</span><br><span class="line">不可能每次 执行一个sql使用了 ThreadLocal 这个对象</span><br><span class="line"></span><br><span class="line">因为不太可能把所有调用方法都加一个connection入参，所以比较优雅的方法是把连接放在ThreadLocal里，其他方法要操作数据库时就从ThreadLocal里get即可。s</span><br><span class="line"></span><br><span class="line">后面我只 注解使用<span class="comment">///mybaits</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doTest</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mapper.insert(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法里还是执行业务sql，但是多了个<span class="meta">@Transactional</span>注解，少了创建connection，开启事务，提交\回滚事务的代码，这些都是由<span class="meta">@Transactional</span>对应的切面来实现的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">建议大家先对spring AOP有个了解，spring事务其实就是根据事务注解生成代理类，然后在前置增强方法里获取connection，设置connection放到threadlocal 里面 使用</span><br><span class="line">    <span class="comment">// ben01      ThreadLocal  ,  Connection数据库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;&#125; 方法</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ，开启事务。再执行原始方法，最后在后置增强方法中判断有无异常来进行事务回滚或提交，再释放连接。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="springboot的自动装配流程-关键点"><a href="#springboot的自动装配流程-关键点" class="headerlink" title="springboot的自动装配流程  关键点"></a>springboot的自动装配流程  关键点</h1><p>下面图是springboot启动的核心点提前帮助我们开发人员，写好创建Bean的配置类</p>
<p><img src="/$%7Bimages%7D/image-20240325085447980.png" alt="image-20240325085447980"></p>
<p><img src="/$%7Bimages%7D/image-20240807144201678.png" alt="image-20240807144201678"></p>
<p><img src="/$%7Bimages%7D/image-20240325085502468.png" alt="image-20240325085502468"></p>
<h1 id="CPU飙升原因排查"><a href="#CPU飙升原因排查" class="headerlink" title="CPU飙升原因排查"></a>CPU飙升原因排查</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/dennyzhangdd/p/11585971.html</span><br><span class="line">1. 使用系统监控工具：使用系统监控工具（如top、Task Manager等）来查看CPU的占用情况。观察哪些进程或线程占用了大量的CPU资源。</span><br><span class="line">2. 查看日志和堆栈信息：查看应用程序的日志和堆栈信息，寻找可能导致CPU飙高的代码。特别关注可能会导致CPU占用高的地方，如循环、递归、大量的计算等。</span><br><span class="line">3. 进行性能分析：使用性能分析工具（如VisualVM、jprofiler等）来分析应用程序的性能瓶颈。通过查看方法的执行时间和调用关系，找出耗时较长的方法和热点代码。</span><br><span class="line">4. 检查死循环和无限循环：检查代码中是否存在死循环或无限循环的情况。特别关注循环条件是否正确、循环变量是否更新等。</span><br><span class="line">5. 检查并发问题：如果程序中存在并发操作，检查是否存在竞争条件、死锁等问题。特别关注共享资源的访问和同步机制是否正确。</span><br><span class="line">6. 检查资源的释放：除了CPU资源外，还要确保程序中使用的其他资源（如文件、数据库连接、网络连接等）能够被正确释放。检查是否存在资源泄漏或未及时关闭的情况。</span><br><span class="line">7. 进行代码重构和优化：根据排查结果，进行代码重构和优化，修复性能问题。可以考虑使用缓存、异步处理、并发控制等机制来提高程序的性能。</span><br><span class="line">8. 进行压力测试：通过模拟大量并发请求或高负载情况，观察应用程序的CPU使用情况。如果CPU使用持续飙高或达到上限，可能存在性能问题。</span><br><span class="line">通过以上的排查方案和思路，可以帮助定位和解决CPU飙高的问题。同时，合理的代码编写和性能优化也是预防CPU飙高的重要手段。</span><br></pre></td></tr></table></figure>

<p>1.执行“top”命令<code>：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</code></p>
<p>2.执行“top -Hp 进程号”命令：查看java进程下的所有线程占CPU的情况。</p>
<p>3.执行“printf “%x\n 10”命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf “%x\n 10-》打印：a，那么在jstack中线程号就是0xa.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">可能是服务器问题，需要排查网络、CPU使用率、内存使用率、磁盘使用率等。见：Java--线上问题排查--方法/步骤_IT利刃出鞘的博客-CSDN博客</span><br><span class="line"></span><br><span class="line">系统问题排查步骤</span><br><span class="line"></span><br><span class="line">以下按顺序进行</span><br><span class="line"></span><br><span class="line">是否CPU占用过高</span><br><span class="line">是否内存占用过高</span><br><span class="line">是否磁盘占用过高</span><br><span class="line">是否网络故障</span><br><span class="line">查看后台日志</span><br><span class="line">是否是数据库问题（比如：索引失效、死锁）</span><br><span class="line">是否是垃圾回收导致</span><br><span class="line">是否死锁等</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">步骤简述</span><br><span class="line"></span><br><span class="line">定位进程         （命令：top）</span><br><span class="line">定位线程         （命令：top -Hp 进程号）</span><br><span class="line">定位代码位置  （命令：jstack）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">java死锁</span><br><span class="line">简介</span><br><span class="line"></span><br><span class="line">有三种方法可排查死锁：jps+jstack、jconsole、jvisualvm</span><br><span class="line"></span><br><span class="line">法1：jps+jstack</span><br><span class="line"></span><br><span class="line">法2：jconsole</span><br><span class="line"></span><br><span class="line">法3：jvisualvm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">MySQL慢查询表现</span><br><span class="line">明显感觉到大部分的应用功能都变慢，但也不是完全不能工作，等待比较长的时间还是有响应的。但是整个系统看起来就非常的卡。</span><br></pre></td></tr></table></figure>



<h1 id="保证消息队列幂等性"><a href="#保证消息队列幂等性" class="headerlink" title="保证消息队列幂等性"></a>保证消息队列幂等性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实现幂等性：</span><br><span class="line"></span><br><span class="line">   1. **唯一标识处理：** 对于每个消息，根据唯一标识（如消息ID）在处理前进行检查，确保消息在系统中只被处理一次。</span><br><span class="line"></span><br><span class="line">   2. **幂等性算法：** 设计幂等性处理算法，使得多次执行同一个操作对系统状态没有额外影响。比如，针对数据库操作，使用幂等性的SQL语句或者存储过程。</span><br><span class="line"></span><br><span class="line">   3. **版本控制：** 对于需要修改的数据，使用版本控制机制，确保对同一数据的重复操作不会改变其状态。</span><br><span class="line"></span><br><span class="line">   4. **补偿机制：** 设计补偿性操作，在消息重复消费时，通过补偿操作恢复系统状态到与处理一次消息相同的状态。</span><br><span class="line"></span><br><span class="line">   5. **消息处理日志：** 记录消息的处理状态，避免重复消费。比如，记录处理成功的消息ID或者处理结果。</span><br><span class="line"></span><br><span class="line">   在实际应用中，通常结合以上方法，根据具体业务和系统特点选择合适的方案。重要的是要在消息消费端和系统设计中考虑这些机制，以确保系统在面对消息重复消费时能够保持一致性和稳定性。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="cglib和jdk代理的区别-动态代理和静态代理的区别"><a href="#cglib和jdk代理的区别-动态代理和静态代理的区别" class="headerlink" title="cglib和jdk代理的区别 ,动态代理和静态代理的区别"></a>cglib和jdk代理的区别 ,动态代理和静态代理的区别</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">常见的代理方式 </span><br><span class="line">&#123;<span class="number">01</span>   dubbo没有使用cglib  而是使用JDK和Javassist来进行动态代理</span><br><span class="line"><span class="number">02</span>   spring扩展的事务机制代理对象 是使用cglib 和jdk两种方式 同时处理数据库事务， CGLib动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被<span class="keyword">final</span>关键字所修饰， 事务会失效，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口,,,定义横切逻辑（如：我们在方法执行前后打印的日志，本文只是为了演示，实际的应用一般不会只是简单的打印日志的），并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</span><br><span class="line"></span><br><span class="line">CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</span><br><span class="line"></span><br><span class="line">CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强；需要引入包asm.jar和cglib.jar。 使用AspectJ注入式切面和<span class="meta">@AspectJ</span>注解驱动的切面实际上底层也是通过动态代理实现的。</span><br><span class="line"></span><br><span class="line">在JDK1<span class="number">.8</span>的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了，但是JDK动态代理和CGLIB动态代理的适用场景还是不一样的哈！</span><br><span class="line"></span><br><span class="line">Java动态代理优缺点：</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>Java本身支持，不用担心依赖问题，随着版本稳定升级；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>代码实现简单；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>目标类必须实现某个接口，换言之，没有实现接口的类是不能生成代理对象的；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>代理的方法必须都声明在接口中，否则，无法代理；</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>执行速度性能相对cglib较低；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cglib优缺点：</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>代理的类无需实现接口；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>执行速度相对JDK动态代理较高；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>字节码库需要进行更新以保证在新版java上能运行；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>动态创建代理对象的代价相对JDK动态代理较高；</span><br><span class="line"></span><br><span class="line">Tips：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>代理的对象不能是<span class="keyword">final</span>关键字修饰的</span><br><span class="line">    </span><br><span class="line">    ————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/Death_Eric/article/details/98203329</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----静态代理动态代理对比</span><br><span class="line">    </span><br><span class="line">    Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。</span><br><span class="line"></span><br><span class="line">静态代理</span><br><span class="line">Java中的静态代理要求代理类(ProxySubject)和委托类(RealSubject)都实现同一个接口(Subject)。静态代理中代理类在编译期就已经确定，而动态代理则是JVM运行时动态生成，静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一单需要修改接口，代理类和委托类都需要修改。</span><br><span class="line"></span><br><span class="line">作者：zhong0316</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/f56e123817b5</span></span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    代理对象与目标对象一起实现相同的接口或者继承相同父类，由程序员创建或特定工具自动生成源代码，即在编译时就已经确定了接口，目标类，代理类等。在程序运行之前，代理类 的 .class 文件就已经生成  ，你可以简单认为代理对象写死持有目标对象。</span><br><span class="line">        </span><br><span class="line">--延申  动态代理细分  </span><br><span class="line"> &amp;&amp; 从实现原理上，我们又可以将动态代理划分为两大类：</span><br><span class="line">编译时增强。   （使用 AspectJ 时需要使用专门的编译器 ajc。  AspectJ 提供编译时织入和运行时织入两种方式来实现 AOP。编译时织入可以在编译应用程序时织入切面代码，因此会更加高效，而运行时织入需要在应用程序运行时动态织入切面代码，因此性能开销可能会更大。但是，AspectJ 本身是一个底层的 AOP 框架，因此相对于 Spring AOP 来说，它更精细和高效。）</span><br><span class="line">运行时增强。（jdk  和cglib）</span><br></pre></td></tr></table></figure>



<h1 id="了解下ASM的字节码技术-dubbo里面也是用这个-简单了解-ASM-技术"><a href="#了解下ASM的字节码技术-dubbo里面也是用这个-简单了解-ASM-技术" class="headerlink" title="了解下ASM的字节码技术 dubbo里面也是用这个(  简单了解 ASM　　技术)"></a>了解下ASM的字节码技术 dubbo里面也是用这个(  简单了解 ASM　　技术)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_53840353/article/details/140033143</span><br></pre></td></tr></table></figure>

<h1 id="面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？（面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？-简书-jianshu-com-）"><a href="#面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？（面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？-简书-jianshu-com-）" class="headerlink" title="面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？（面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？ - 简书 (jianshu.com)）"></a>面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9b107da30466">面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？ - 简书 (jianshu.com)</a>）</h1><p><img src="/$%7Bimages%7D/springaop%E5%92%8CsaspectJ__%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240710163709.jpg" alt="springaop和saspectJ__微信图片_20240710163709"></p>
<p><img src="/$%7Bimages%7D/image-20240710162314124.png" alt="image-20240710162314124"></p>
<h1 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">AOP使用场景：</span><br><span class="line"></span><br><span class="line">Authentication 权限检查</span><br><span class="line"></span><br><span class="line">Caching 缓存</span><br><span class="line"></span><br><span class="line">Context passing 内容传递</span><br><span class="line"></span><br><span class="line">Error handling 错误处理</span><br><span class="line"></span><br><span class="line">Lazy loading　延迟加载</span><br><span class="line"></span><br><span class="line">Debugging　　调试</span><br><span class="line"></span><br><span class="line">logging, tracing, profiling and monitoring　日志记录，跟踪，优化，校准</span><br><span class="line"></span><br><span class="line">Performance optimization　性能优化，效率检查</span><br><span class="line"></span><br><span class="line">Persistence　　持久化</span><br><span class="line"></span><br><span class="line">Resource pooling　资源池</span><br><span class="line"></span><br><span class="line">Synchronization　同步</span><br><span class="line"></span><br><span class="line">Transactions 事务管理</span><br><span class="line"></span><br><span class="line">另外Filter的实现和struts2的拦截器的实现都是AOP思想的体现。</span><br><span class="line"></span><br><span class="line">我们是在使用Spring框架的过程中，其实就是为了使用IOC，依赖注入，和AOP，面向切面编程，这两个是Spring的灵魂。</span><br><span class="line"></span><br><span class="line">主要用到的设计模式有工厂模式和代理模式。</span><br><span class="line"></span><br><span class="line">IOC就是典型的工厂模式，通过sessionfactory去注入实例。</span><br><span class="line"></span><br><span class="line">AOP就是典型的代理模式的体现。</span><br><span class="line"></span><br><span class="line">代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</span><br></pre></td></tr></table></figure>

<h1 id="AQS-技术的使用ReentrantLock-底层原理实现"><a href="#AQS-技术的使用ReentrantLock-底层原理实现" class="headerlink" title="AQS 技术的使用ReentrantLock 底层原理实现"></a>AQS 技术的使用ReentrantLock 底层原理实现</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, Serializable </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReentrantLock底层使用了CAS+AQS队列实现  （ 增加了 轮询 超时 中断 公平锁和非公锁）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主要区别就在于锁的获取方式。公平锁会严格按照请求的先后顺序分配锁，等待时间最长的线程会优先获取锁，这样可以避免线程饥饿（线程饥饿指 一个线程长时间持有锁，其他线程不能持有锁 操作热点资源）的问题。而非公平锁则允许新的线程插队，如果新线程恰好在锁释放的瞬间请求锁，它有可能会在等待队列的前面获取到锁，这样可能会导致某一个线程己经在等待的线程等待更长时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">两种所使用的场景</span><br><span class="line">公平锁适合对线程执行顺序有严格要求的场景，比如任务调度。</span><br><span class="line">而非公平锁则适用于对并发性能要求比较高的场景，因为它允许新的线程插队，可能会减少线程切换的开销。但需要注意，使用非公平锁可能会导致某些线程等待时间过长。</span><br><span class="line"></span><br><span class="line">reentranLock可以显示的方式控制锁的获取和释放 就是lock()  unlock（） 方法， </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync(); //默认，非公平</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">// var1=true 公平锁</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync(); //根据参数创建</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. lock() 和 unlock() 的实现</span><br><span class="line"></span><br><span class="line"> final void lock() &#123; //非公平锁</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123; //公平锁</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    4.3 addWaiter()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ReentrantLock中tryLock()和lock()方法的区别</span><br><span class="line">1. trylock0表示会试加锁，可能加口到，也可能加口不到，该方法不会阻寨线程，如果加到锁则返回</span><br><span class="line">true，没有加到则返回false</span><br><span class="line">2. lockO表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值</span><br><span class="line"></span><br><span class="line">当前线程加入AQS双向链表队列。</span><br><span class="line"></span><br><span class="line">写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))。</span><br><span class="line"></span><br><span class="line">首先判断队列是否为空，不为空时则将封装好的 Node 利用 CAS 写入队尾，如果出现并发写入失败就需要调用 enq(node); 来写入了。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">总结</span><br><span class="line">0.每一个ReentrantLock自身维护一个AQS队列记录申请锁的线程信息；</span><br><span class="line"></span><br><span class="line">1.通过大量CAS保证多个线程竞争锁的时候的并发安全；</span><br><span class="line"></span><br><span class="line">2.可重入的功能是通过维护state变量来记录重入次数实现的。</span><br><span class="line"></span><br><span class="line">3.公平锁需要维护队列，通过AQS队列的先后顺序获取锁，缺点是会造成大量线程上下文切换；</span><br><span class="line"></span><br><span class="line">4.非公平锁可以直接抢占，所以效率更高；</span><br><span class="line">5.  非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。</span><br><span class="line">6.==使用场景的话呢，其实还是和他们的属性一一相关，举个栗子：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平(CAS)锁其实效率并不明显，但是用公平锁会给业务增强很多的可控制性。==</span><br><span class="line">----</span><br><span class="line">https://zhuanlan.zhihu.com/p/249147493</span><br><span class="line">--需要看 rent具体方法， 公平锁和非公平锁的实现为啥这样，如何选择</span><br><span class="line">--- CLH锁的而数据结构和实现</span><br><span class="line">CLH锁</span><br><span class="line">https://zhuanlan.zhihu.com/p/197840259#2%20%E4%BB%80%E4%B9%88%E6%98%AFclh%E9%94%81%EF%BC%9F</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240403210226504.png" alt="image-20240403210226504"></p>
<h1 id="ReentrantReadWriteLock和ReentrantLock-对比升级的是哪些方面"><a href="#ReentrantReadWriteLock和ReentrantLock-对比升级的是哪些方面" class="headerlink" title="ReentrantReadWriteLock和ReentrantLock  对比升级的是哪些方面"></a>ReentrantReadWriteLock和ReentrantLock  对比升级的是哪些方面</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock（可重入读写锁）是Java中另一种常用的锁，也是一种可重入锁。与ReentrantLock不同的是，ReentrantReadWriteLock既可以支持独占锁，也可以支持共享锁。共享锁是指同一时刻可以有多个线程读取共享资源，但只能有一个线程写入共享资源；独占锁是指同一时刻只能有一个线程获得锁，其他线程必须等待。因此，ReentrantReadWriteLock适用于读多写少的场景，可以提高并发读操作的效率。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            ##############阁下如果是抄袭，爬取文章作恶或误导他人的开发者,请阅读中国现行法律的相关处罚条例再动手，转载之前最好先验证############# </span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/java_wxid/article/details/132650101</span><br><span class="line">-----</span><br><span class="line">CopyOnWriteArrayList 适用于读多写少的并发场景，比如白名单，黑名单等场景</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="CountDownLatch使用方式原理"><a href="#CountDownLatch使用方式原理" class="headerlink" title="CountDownLatch使用方式原理"></a>CountDownLatch使用方式原理</h1><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/WINGZINGLIU/article/details/107227620">https://blog.csdn.net/WINGZINGLIU/article/details/107227620</a></p>
<p>CountDownLatch</p>
<p>CountDownLatch是一个可以使其他线程等待某些线程执行完毕后再进行执行的工具类。</p>
<p>用我个人的理解来说的话，就是它提供了一个await()方法来阻塞当前线程，</p>
<p>直到countDown()方法使得计数器递减到0之后对阻塞队列中线程进行唤醒，来达到一种等待的效果。</p>
<p><font  color="yellow">**CountDownLatch数据结构&#x2F;   CountDownLatch是利用AQS共享锁机制的同步器Sync来实现的</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享锁的概念  </span><br><span class="line">---共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</span><br><span class="line">如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">--下面是源码的 部分解析</span><br><span class="line">public class CountDownLatch &#123;</span><br><span class="line">    // 继承AQS来实现同步器，</span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">	</span><br><span class="line">		// 通过state控制count</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">		// 重写AQS的tryAcquireShared，通过获取共享锁的方式实现等待</span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">			// 当state不为0时一直阻塞</span><br><span class="line">            return (getState() == 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">		// 释放共享锁</span><br><span class="line">        protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">				</span><br><span class="line">				// 如果state为0，则不能再使用，</span><br><span class="line">                if (c == 0) return false;</span><br><span class="line">				// state减1</span><br><span class="line">                int nextc = c-1;</span><br><span class="line">				// 为0，释放共享锁，唤醒等待线程</span><br><span class="line">                if (compareAndSetState(c, nextc)) return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	// 同步器变量</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    // 创建同步器，设置AQS的state变量为1</span><br><span class="line">    public CountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">        this.sync = new Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="显示锁和隐式锁-对比"><a href="#显示锁和隐式锁-对比" class="headerlink" title="显示锁和隐式锁 对比"></a><font  color="gree">显示锁和隐式锁 对比</font></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Java中隐式锁：synchronized；显式锁：lock</span><br><span class="line"></span><br><span class="line">---java锁体系：：</span><br><span class="line"></span><br><span class="line">1--synchronized是Java中的关键字，由JVM维护，是JVM层面的锁；</span><br><span class="line">而lock是JDK5之后才出现的具体的类，使用Lock是调用对应的API，是API层面的锁。</span><br><span class="line"></span><br><span class="line">2--显氏锁和隐式锁的区别在于：使用显式锁的时候，使用者需要手动去获取和释放锁</span><br><span class="line"></span><br><span class="line">3--synchronized关键字是不可中断的，除非抛出异常或者正常运行结束而Lock是可以中断的，中断方式：</span><br><span class="line">调用设置超时方法tryLock(Long timeout,timeUnit unit)</span><br><span class="line">调用lockInterruptibly()放到代码块中，然后调用interrupt()方法可以中断。</span><br><span class="line"></span><br><span class="line">4---synchronized是非公平锁；而lock两者都可以，默认创建是非公平锁。</span><br><span class="line"></span><br><span class="line">---mysql</span><br><span class="line">显示锁和隐式锁是MySQL中的两种不同的锁机制。 显示锁需要开发人员手动指定锁定的对象，包括共享锁和排他锁。 隐式锁是MySQL自动为事务提供的，根据事务的操作自动加锁，包括隐式共享锁和隐式排他锁。 使用显示锁可以更精细地控制锁的范围，提高并发性能。 而隐式锁相对于开发人员更加方便，但锁的范围相对较大，可能造成锁冲突</span><br></pre></td></tr></table></figure>



<h1 id="几种锁对比"><a href="#几种锁对比" class="headerlink" title="几种锁对比"></a>几种锁对比</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。</span><br><span class="line">排它锁，也称作独占锁，一个锁在某一时刻只cf能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。</span><br><span class="line">2. 独占锁和共享锁实例</span><br><span class="line">ReentrantLock就是一种排它锁。CountDownLatch是一种共享锁。这两类都是单纯的一类，即，要么是排它锁，要么是共享锁。 ReentrantReadWriteLock是同时包含 排他锁和共享锁特性的一种锁， 这里主要以ReentrantReadWriteLock为例来进行分析学习。我们使用ReentrantReadWriteLock的写锁时，使用的便是排它锁的特性；使用ReentrantReadWriteLock的读锁时，使用的便是共享锁的特性</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/u012184539/article/details/88561195</span><br><span class="line"></span><br><span class="line">--01  独占锁和共享</span><br><span class="line"></span><br><span class="line">--02  乐观 悲观</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---03 自旋锁和互斥锁的区别</span><br><span class="line">https://blog.csdn.net/qq_37935909/article/details/108625508</span><br><span class="line">1、互斥锁</span><br><span class="line">互斥锁是一种独占锁，当线程A加锁成功后，此时互斥锁已经被线程A独占了，只要线程A没有释放手中的锁，线程B就会失败，就会释放掉CPU给其他线程，线程B加锁的代码就会被阻塞。</span><br><span class="line"></span><br><span class="line">互斥锁加锁失败而阻塞是由操作系统内核实现的，当加锁失败后，内核将线程置为睡眠状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程加锁成功后就可以继续执行。&#123;  内核态和用户态 区别&#125;</span><br><span class="line">&#123;  结论  ：：  </span><br><span class="line">如果锁住的代码 业务中线程占用(处理)时间  比较短，可能上下文切换的时间比锁住的代码执行时间还要长。若是能确定被锁住的代码执行时间很短，应该选择自旋锁；  那么 如果执行的代码块  需要时间比较久  不要使用CAS自旋锁  至于是否使用互斥锁 目前不知，个人感觉感觉使用互斥锁也不是最好选择&#125;</span><br><span class="line"></span><br><span class="line">自旋锁通过CPU提供的CAS，在用户态完成加锁和解锁操作，不会主动产生线程上下文切换(没有用户态和内核态切换)，所以相比互斥锁来说，会快一些开销小一些。</span><br><span class="line">加锁过程：</span><br><span class="line"></span><br><span class="line">查看锁的状态，若是空闲的则执行2</span><br><span class="line">将锁设置为当前线程持有；</span><br><span class="line">使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会忙等待，直到拿到锁。忙等待可以通过while循环实现，不过最好是使用CPU提供的PAUSE指令来实现。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_37935909/article/details/108625508</span><br><span class="line"></span><br><span class="line">---04  同步锁和异步锁（redis分布式锁就是异步锁）</span><br><span class="line">同步锁：当在一个java虚拟机多个线程操作一个变量的时候就会出现线程安全问题，这个时候就会用到同步锁。  解决办法是使用 sync</span><br><span class="line">异步锁：就是多个java 虚拟机或者说是服务器，操作同一个变量是，会出现线程安全问题，使用需要使用异步锁来处理。</span><br><span class="line">       使用dubbo  zookeeper (共享锁，排它锁)，这里就根据自己的情况，共享锁还是会出现阻塞的情况，排它锁就是会生成很多临时的        节点，谁先获取最小的序号标识谁就先获取到锁</span><br></pre></td></tr></table></figure>





<h1 id="jvm本地缓存的原理和常用工具第三方组件"><a href="#jvm本地缓存的原理和常用工具第三方组件" class="headerlink" title="jvm本地缓存的原理和常用工具第三方组件"></a>jvm本地缓存的原理和常用工具第三方组件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/585557682</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JVM本地缓存的优点包括：</span><br><span class="line"></span><br><span class="line">提高性能：通过减少对外部资源或网络的访问，本地缓存可以显著提高应用程序的性能。</span><br><span class="line">降低延迟：由于减少了外部访问的需要，本地缓存可以降低应用程序的延迟。</span><br><span class="line">提高可用性：通过缓存数据，即使在外部资源不可用的情况下，应用程序也可以继续执行。</span><br><span class="line">然而，本地缓存也存在一些潜在问题：</span><br><span class="line"></span><br><span class="line">内存占用：如果缓存数据过多或不必要地占用内存，可能会导致内存不足的问题。这可能会影响应用程序的性能，甚至导致应用程序崩溃。</span><br><span class="line">数据过期：如果缓存的数据已经过期或不再有效，但仍然被用于后续操作，可能会导致错误的计算结果或行为。</span><br><span class="line">同步问题：在多线程环境下，如果多个线程同时访问和修改同一份缓存数据，可能会导致数据不一致或竞态条件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为了优化JVM本地缓存的性能，你可以考虑以下几点：</span><br><span class="line"></span><br><span class="line">合理配置堆大小：根据应用程序的需求和可用内存，合理配置堆的大小。过小的堆可能导致频繁的垃圾回收，而过大的堆可能导致内存溢出。</span><br><span class="line">利用垃圾回收机制：垃圾回收是JVM自动管理堆内存的一种机制。通过合理配置垃圾回收参数，可以降低内存泄漏和碎片化的风险，提高应用程序的性能。</span><br><span class="line">优化方法区使用：方法区的大小和配置对于JVM的性能具有重要影响。通过合理配置方法区的参数，可以避免方法区溢出或性能下降的问题。</span><br><span class="line">利用缓存淘汰策略：对于本地缓存数据，应该定期进行清理和淘汰。通过合理配置缓存淘汰策略，可以避免内存占用过高或数据过期的问题。</span><br><span class="line">同步和并发控制：在多线程环境下，应该注意对缓存数据的同步和并发控制。通过合理使用同步锁或并发控制工具，可以避免数据不一致或竞态条件的问题。</span><br></pre></td></tr></table></figure>

<h1 id="jvm缓存常用的工具（Java本地缓存技术选型（Guava-Cache、Caffeine、Encache）"><a href="#jvm缓存常用的工具（Java本地缓存技术选型（Guava-Cache、Caffeine、Encache）" class="headerlink" title="jvm缓存常用的工具（Java本地缓存技术选型（Guava Cache、Caffeine、Encache）"></a>jvm缓存常用的工具（Java本地缓存技术选型（Guava Cache、Caffeine、Encache）</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e5dc3a18dcb8">Java本地缓存技术选型（Guava Cache、Caffeine、Encache） - 简书 (jianshu.com)</a>）</p>
<p>{redis  megoDB  这两种都属于remote cache（分布式缓存}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">对一个java后台开发者而言，提到缓存，第一反应就是redis和memcache。利用这类缓存足以解决大多数的性能问题了，并且java针对这两者也都有非常成熟的api可供使用。但是我们也要知道，这两种都属于remote cache（分布式缓存），应用的进程和缓存的进程通常分布在不同的服务器上，不同进程之间通过RPC或HTTP的方式通信。这种缓存的优点是缓存和应用服务解耦，支持大数据量的存储，缺点是数据要经过网络传输，性能上会有一定损耗。</span><br><span class="line"></span><br><span class="line">与分布式缓存对应的是本地缓存，缓存的进程和应用进程是同一个，数据的读写都在一个进程内完成，这种方式的优点是没有网络开销，访问速度很快。缺点是受JVM内存的限制，不适合存放大数据。</span><br><span class="line">---01  自定义使用LinkedHashMap  和 ReentrantReadWriteLock</span><br><span class="line"></span><br><span class="line">---02</span><br><span class="line">2. 基于Guava Cache实现本地缓存</span><br><span class="line">Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：</span><br><span class="line"></span><br><span class="line">支持最大容量限制</span><br><span class="line">支持两种过期删除策略（插入时间和访问时间）</span><br><span class="line">支持简单的统计功能</span><br><span class="line">基于LRU算法实现</span><br><span class="line">Guava Cache的使用非常简单，首先需要引入maven包</span><br><span class="line"></span><br><span class="line">--03 </span><br><span class="line">3. Caffeine</span><br><span class="line">Caffeine是基于java8实现的新一代缓存工具，缓存性能接近理论最优。可以看作是Guava Cache的增强版，功能上两者类似，不同的是Caffeine采用了一种结合LRU、LFU优点的算法：W-TinyLFU，在性能上有明显的优越性。Caffeine的使用，首先需要引入maven包：</span><br><span class="line"></span><br><span class="line">---04</span><br><span class="line"></span><br><span class="line">4. Encache</span><br><span class="line">Encache是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。同Caffeine和Guava Cache相比，Encache的功能更加丰富，扩展性更强：</span><br><span class="line"></span><br><span class="line">支持多种缓存淘汰算法，包括LRU、LFU和FIFO</span><br><span class="line">缓存支持堆内存储、堆外存储、磁盘存储（支持持久化）三种</span><br><span class="line">支持多种集群方案，解决数据共享问题</span><br><span class="line">Encache的使用，首先需要导入maven包：</span><br><span class="line"></span><br><span class="line">作者：程序员日志</span><br><span class="line">链接：https://www.jianshu.com/p/e5dc3a18dcb8</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>











<h1 id="强引用以及4个引用以及引用场景"><a href="#强引用以及4个引用以及引用场景" class="headerlink" title="强引用以及4个引用以及引用场景"></a>强引用以及4个引用以及引用场景</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.强引用（Strong Reference）：2. 软引用（Soft Reference）：3. 弱引用（Weak Reference）：4. 虚引用（Phantom Reference）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从JDK 1.2版本开始，对象的引用被划分为4种级别，这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。</span><br><span class="line"></span><br><span class="line">---01</span><br><span class="line">强引用（Strong Reference）   定义： 强引用（Strong Reference）是Java中最为普遍的引用类型。当一个对象被强引用关联时，垃圾回收器不会回收这个对象，即使系统内存不足也不会回收。只有当该对象的强引用被显式地释放，或者不再被任何引用关联时，该对象才会成为垃圾回收的候选对象。  // 创建一个对象并建立强引用常见的   Object obj = new Object(); // 强引用</span><br><span class="line"></span><br><span class="line">特点：：如果一个对象具有强引用，那就类似于必不可少的物品，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</span><br><span class="line">----02  软引用</span><br><span class="line">软引用用于描述一些还有用但并非必须的对象，在内存不足时可能被垃圾回收。  SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(largeObject);s</span><br><span class="line">使用场景 ：： 1.对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存  2. 当堆的使用率超过阈值时，才回去回收软引用中的对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---03   weak引用</span><br><span class="line">弱引用（Weak Reference）是Java中一种比强引用更弱的引用类型。当一个对象只被弱引用关联时，在下一次垃圾回收时，该对象就有可能被回收。垃圾回收器会在适当的时候回收仅被弱引用持有的对象，即使内存并不紧张，无论内存是否充足，都会回收被弱引用关联的对象</span><br><span class="line">使用场景：：： 这个类通常用于在某处保存对象引用，而又不干扰该对象被GC回收，通常用于Debug、内存监视工具等程序中。因为这类程序一般要求即要观察到对象，又不能影响该对象正常的GC过程    WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(obj)</span><br><span class="line"></span><br><span class="line">使用场景：：1.  WeakHashMap   当key只有弱引用时，GC发现后会自动清理键和值，作为简单的缓存表解决方案。</span><br><span class="line"></span><br><span class="line">2.   ThreadLocal</span><br><span class="line">     ThreadLocal.ThreadLocalMap.Entry 继承了弱引用，key为当前线程实例，和WeakHashMap基本相同。</span><br><span class="line"></span><br><span class="line">----04</span><br><span class="line">虚引用（Phantom Reference）是Java中最弱的引用类型之一，无法通过引用直接获取到对象实例。虚引用主要用于跟踪对象被垃圾回收的状态。当一个对象只被虚引用关联时，其实际上并不影响对象的生命周期，也就是说，垃圾回收器随时可能回收被虚引用关联的对象。</span><br><span class="line"> </span><br><span class="line"> 使用场景</span><br><span class="line"> ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = new PhantomReference&lt;&gt;(obj, referenceQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="sync和-volatitle-关键字对比"><a href="#sync和-volatitle-关键字对比" class="headerlink" title="sync和 volatitle  关键字对比"></a>sync和 volatitle  关键字对比</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377423211">面试官：请详细说下synchronized的实现原理 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/567879393/answer/2978976437">(8 封私信 &#x2F; 80 条消息) synchronized 和 volatile 有什么区别？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356010805">Java面试常见问题：Monitor对象是什么？ - 知乎 (zhihu.com)</a></p>
<p>[(8 封私信 &#x2F; 80 条消息) synchronized 关键字可以保证可见性吗？ - 知乎 (zhihu.com)](https:&#x2F; &#x2F;<a target="_blank" rel="noopener" href="http://www.zhihu.com/question/48313299">www.zhihu.com/question/48313299</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">synchronized  在jdk1.6之前，synchronized被称为重量级锁，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁  </span><br><span class="line">是Java中的monitor是通过内置锁（也称为监视器锁）来实现的 ,  其他的rentanLock这种事使用的 显示锁。</span><br><span class="line"></span><br><span class="line">因为volatile不能保证变量操作的原子性，所以试图通过volatile来保证线程安全性是不靠谱的， volatile 修饰的变量 在两个线程一加一减的 相同次数 最后 ，结果可能出现 counter=1 ,也就是会出现 加减次数不一致问题。  不是原子操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----02</span><br><span class="line"></span><br><span class="line">synchronized 和 volatile 都是 Java 中用来实现多线程同步的机制，但是它们有一些不同，具体可以从以下几个方面进行比较：</span><br><span class="line"></span><br><span class="line">1. 变量特性：synchronized 是利用锁来保证同步的，而 volatile 是利用内存屏障来保证可见性和禁止指令重排的。</span><br><span class="line"></span><br><span class="line">2. 内存开销：synchronized 在使用时有一定的内存开销，需要进行锁的申请、释放、等待等操作，而 volatile 则没有锁的开销，通过 CPU 的缓存一致性实现了数据的可见性。</span><br><span class="line"></span><br><span class="line">3. 线程安全：synchronized 是线程安全的，可以保证多线程下数据的准确性，但是 volatile 是满足一定的条件才能保证原子性和可见性的。例如，对于 ++ 操作，需要使用AtomicInteger；对于多个 volatile 变量的分组操作，需要使用锁或者AtomicReference。</span><br><span class="line"></span><br><span class="line">4. 使用场景：synchronized 适用于需要在代码块或者方法上进行同步控制的场景，而 volatile 适用于只需要保证变量的可见性，而不需要保证多线程之间的原子性操作的场景。</span><br><span class="line"></span><br><span class="line">总之，synchronized 和 volatile 都是用来实现多线程同步的，synchronized 具有更加强大的功能，但同时也有一定的性能开销，适用于在多个线程之间需要同步共享变量的情况。而 volatile 能够更加轻量级地实现变量的可见性，适用于只需要保证某个变量的可见性，而不需要同步控制的场景。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/m0_68464502/article/details/131107637</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">synchronized的缺点：</span><br><span class="line">1.无法判断获取锁的状态。</span><br><span class="line">2.虽然会自动释放锁，但如果如果锁的那个方法执行时间较长就会一直占用着不去释放，不能让使用同一把锁的方法继续执行，影响程序的运行如（例1）。（会锁住某一段程序，别的程序如果需要调用的话就必须等待，减少了速度、效率)。</span><br><span class="line">3.使用synchronized，当多个线程尝试获取锁时，未获取到锁的线程会不断的尝试获取锁，而不会发生中断，这样会造成性能消耗。</span><br><span class="line">4.有可能产生死锁，导致程序中断</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_44978607/article/details/115270957</span><br></pre></td></tr></table></figure>





<h1 id="sync底层原理"><a href="#sync底层原理" class="headerlink" title="sync底层原理"></a>sync底层原理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">01--- 常提到 特性</span><br><span class="line">面试时经常拿synchronized关键字和volatile关键字的特性进行对比，synchronized关键字可以保证并发编程的三大特性：原子性、可见性、有序性，而volatile关键字只能保证可见性和有序性，不能保证原子性，也称为是轻量级的synchronized。</span><br><span class="line">原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</span><br><span class="line">可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时，会对应执行 lock、unlock原子操作(synchronized在修改了本地内存中的变量后，解锁前会将本地内存修改的内容刷新到主内存中，确保了共享变量的值是最新的，也就保证了可见性。)，保证可见性。</span><br><span class="line">有序性：程序的执行顺序会按照代码的先后顺序执行。</span><br><span class="line">02---synchronized关键字可以实现什么类型的锁？</span><br><span class="line"></span><br><span class="line">悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。</span><br><span class="line">非公平锁：synchronized关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。</span><br><span class="line">可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。</span><br><span class="line">独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。</span><br><span class="line"></span><br><span class="line">03--JDK1.6之前  底层加锁原理</span><br><span class="line">在jdk1.6之前，synchronized被称为重量级锁，</span><br><span class="line">其实是这样的，在JDK 1.6之前是重量级锁，线程进入同步代码块/方法 时候选者：monitor对象就会把当前进入线程的Id进行存储，</span><br><span class="line">设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中候选者：</span><br><span class="line">它加锁是依赖底层操作系统的 &#123;mutex 相关指令&#125;实现，所以会有用户态和内核态之间的切换，性能损耗十分明显候选者：</span><br><span class="line">而JDK1.6 以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，就没有切换的消耗候选者：</span><br><span class="line">所以，Mark Word对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</span><br><span class="line"></span><br><span class="line">。下面先介绍jdk1.6之前的synchronized原理。</span><br><span class="line"></span><br><span class="line">在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：</span><br><span class="line">对象头、</span><br><span class="line">实例数据</span><br><span class="line">和填充对齐。</span><br><span class="line">----</span><br><span class="line">1，Mark Word</span><br><span class="line">2，指向类的指针</span><br><span class="line">3，数组长度（只有数组对象才有</span><br><span class="line">---</span><br><span class="line">因为synchronized用的锁是存在对象头里的，这里我们需要重点了解对象头</span><br><span class="line"></span><br><span class="line">在Hotspot虚拟机中，Monitor是由ObjectMonitor实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，a::代码块同步使用的是monitorenter和 monitorexit 指令实现的，b::而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法(  下面两个图 就是处理的 标记)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">04 --JDK1.6之后    底层加锁原理</span><br><span class="line">  a---优化的原因（用户态和内核态的切换）</span><br><span class="line">因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大。</span><br><span class="line"></span><br><span class="line">在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，如下图所示。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级。这种只能升级不能降级的策略是为了提高获得锁和释放锁的效率</span><br><span class="line"></span><br><span class="line">。。。。。。继续  https://zhuanlan.zhihu.com/p/377423211</span><br><span class="line"></span><br><span class="line">jclasslib Bytecode viewer---反编译工具  C语言级别工具</span><br><span class="line">javap -c  SynchronizedDemo.class  命令进行反编译</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240413191956124.png" alt="image-20240413191956124"><img src="/$%7Bimages%7D/image-20240413193340778.png" alt="image-20240413193340778"></p>
<h1 id="设计模式-（常用的和spring等框架的使用的总结）"><a href="#设计模式-（常用的和spring等框架的使用的总结）" class="headerlink" title="设计模式  （常用的和spring等框架的使用的总结）"></a>设计模式  （常用的和spring等框架的使用的总结）</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/634398640">并发专栏-队列同步器 AQS 以及 Reentrantlock 应用 - 知乎 (zhihu.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">01模板方法模式 （ 特点：： 模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码）</span><br><span class="line">ReentrantLock 、ReentrantReadWriteLock、 Semaphore、 CountDownLatch ，都是【聚合】了一个【队列同步器】的子类完成线程访问控制，  使用的就是模板方法模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">（1）创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</span><br><span class="line"></span><br><span class="line">（2）结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</span><br><span class="line"></span><br><span class="line">（3）行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="spring事务，线程和锁-关系总结，备注：：-spring-bean周期-，-spring事务-延申数据库事务-线程-和-表锁机制"><a href="#spring事务，线程和锁-关系总结，备注：：-spring-bean周期-，-spring事务-延申数据库事务-线程-和-表锁机制" class="headerlink" title="spring事务，线程和锁 关系总结，备注：：  spring bean周期 ， spring事务  延申数据库事务  线程 和 表锁机制"></a><font  color="skyblue">spring事务，线程和锁 关系总结，备注：：  spring bean周期 ， spring事务  延申数据库事务  线程 和 表锁机制</font></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ioc容器：实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、</span><br><span class="line">@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的</span><br><span class="line">bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创</span><br><span class="line">建对象放到map里。</span><br><span class="line">这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI(依赖)注入</span><br><span class="line">（autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性</span><br><span class="line">根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</span><br><span class="line"></span><br><span class="line">控制反转：</span><br><span class="line">没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须</span><br><span class="line">主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</span><br><span class="line">引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会</span><br><span class="line">主动创建一个对象B注入到对象A逻辑代码需要使用B的地方。</span><br><span class="line">通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒</span><br><span class="line">过来了，这就是“控制反转”这个名称的由来。</span><br><span class="line"></span><br><span class="line">  ##全部对象的控制权全部上缴给“第三方”IOC容器，##</span><br><span class="line"></span><br><span class="line">所以，IOC容器成了整个系统的关键核心，它起到了一</span><br><span class="line">种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对</span><br><span class="line">象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</span><br><span class="line"></span><br><span class="line">依赖注入：</span><br><span class="line">通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。 </span><br><span class="line">“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器</span><br><span class="line">主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对</span><br><span class="line">象之中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">IOC Map  创建、存储和管理对象</span><br><span class="line"></span><br><span class="line">那么，如何使用IoC容器呢？在传统的Java应用中，我们通常会手动创建和配置对象。但在Spring框架中，我们可以通过 配置文件或注解的方式将普通的Java类标记为Spring的配置类，从而将对象的管理权交给IoC容器</span><br><span class="line"></span><br><span class="line">此外，IoC容器还支持AOP（面向切面编程）和声明式事务等功能。这些功能都依赖于IoC容器的核心功能，即代码解耦和设计模式等问题。通过使用这些功能，我们可以更加方便地实现日志记录、事务管理和安全控制等功能。</span><br></pre></td></tr></table></figure>



<p>原因</p>
<p><img src="/$%7Bimages%7D/image-20240314203551117.png" alt="image-20240314203551117"></p>
<p><img src="/$%7Bimages%7D/image-20240315125856907.png" alt="image-20240315125856907"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,</span><br><span class="line">      @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) &#123;</span><br><span class="line"></span><br><span class="line">   BeanWrapperImpl bw = new BeanWrapperImpl();</span><br><span class="line">   this.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="springcloud负载均衡的顶级接口"><a href="#springcloud负载均衡的顶级接口" class="headerlink" title="springcloud负载均衡的顶级接口"></a>springcloud负载均衡的顶级接口</h1><p><img src="/$%7Bimages%7D/image-20240323100646189.png" alt="image-20240323100646189"></p>
<p><img src="/$%7Bimages%7D/image-20240323100653855.png" alt="image-20240323100653855"></p>
<p>MQ组成布冯</p>
<p><img src="/$%7Bimages%7D/image-20240323154251915.png" alt="image-20240323154251915"></p>
<p><img src="/$%7Bimages%7D/image-20240408133246137.png" alt="image-20240408133246137"></p>
<h1 id="java内存分配-从类的角度解释"><a href="#java内存分配-从类的角度解释" class="headerlink" title="java内存分配 从类的角度解释"></a>java内存分配 从类的角度解释</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">01    java 内存分配 </span><br><span class="line">1、基础数据类型看位置：：</span><br><span class="line">      </span><br><span class="line">   （1） 是全局变量   当声明的是基本类型的变量其变量名及其值放在堆内存中的，然而  引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</span><br><span class="line">  （2）在局部变量  不解释</span><br><span class="line">2、方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收; </span><br><span class="line">3、引用数据类型，需要用 new 来创建，既在栈空间分配一个地址空间，又在 </span><br><span class="line">堆空间分配对象的类变量;</span><br><span class="line"> </span><br><span class="line">4、方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当 </span><br><span class="line">方法调用完后从栈空间回收; </span><br><span class="line">5、局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周 </span><br><span class="line">期结束后，栈空间立刻被回收，堆空间区域等待 GC 回收; </span><br><span class="line">6、方法调用时传入的实际参数，先在栈空间分配，在方法调用完成后从栈空间释放; </span><br><span class="line">7、字符串常量在 DATA 区域分配 ， this 在堆空间分配; </span><br><span class="line">8、数组既在栈空间分配数组名称， 又在堆空间分配数组实际的大小。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">、JIT（just in time,即时编译技术）编译后的代码等数据</span><br><span class="line"></span><br><span class="line">通过反射获取到的类型、方法名、字段名称、访问修饰符等信息就是从方法区获取到的。在使用到CGLib对类进行增强时，增强的类越多，就需要越大的方法区类存储动态生成的Class信息，当存放方法区数据的内存溢出时，会报OutOfMemoryError异常。在jdk1.8中也就是Metaspace内存溢出，可以通过参数JVM参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置Metaspace的空间大小。jdk1.8后方法区（Method Area）被元空间(Metaspace)代替。3</span><br><span class="line"></span><br><span class="line">||</span><br><span class="line">StackOverflowError是由于调用栈溢出引起的错误，而OutOfMemoryError是由于无法分配更多的堆内存引起的错误</span><br><span class="line"></span><br><span class="line">JVM规范中规定, 除了程序计数器之外, 其他的运行时数据区域, 例如堆栈, 方法区, 都会出现OutOfMemoryError异常.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265664787">彻底理解JVM内存模型 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javaqaaa/article/details/126438978">jvm基础知识_方法区中类静态属性引用的对象-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">01 --关于 本地方法栈和虚拟机栈对比</span><br><span class="line">本地方法栈</span><br><span class="line">本地方法栈和java虚拟机栈所发挥的作用是非常相似的，其区别就是</span><br><span class="line"></span><br><span class="line">java虚拟机栈为虚拟机执行Java方法（也就是字节码）服务</span><br><span class="line">本地方法栈则是为虚拟机使用到的本地方法服务</span><br><span class="line">StackOverflowError和OutOfMemoryError异常</span><br><span class="line">Java虚拟机栈</span><br><span class="line"></span><br><span class="line">如果线程请求的栈深度大于虚拟机所允许的深度，则会抛出StackOverflowError异常</span><br><span class="line">如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</span><br><span class="line">本地方法栈</span><br><span class="line">与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常</span><br><span class="line"></span><br><span class="line">本地方法栈：：：一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java方法：该方法的实现由非java语言实现</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/sx1999aaa/article/details/108553131</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240828220332689.png" alt="image-20240828220332689"></p>
<p><img src="/$%7Bimages%7D/image-20240412133722259.png" alt="image-20240412133722259"></p>
<p><img src="/$%7Bimages%7D/image-20240327202022883.png" alt="jdk1.7"></p>
<p><img src="/$%7Bimages%7D/image-20240828211441771.png" alt="jdk1.8  结构图"></p>
<p><img src="/$%7Bimages%7D/image-20240405094351170.png" alt="image-20240405094351170"></p>
<h1 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h1><img src="${images}/image-20250223174826081.png" alt="image-20250223174826081" style="zoom:33%;" />



<img src="${images}/image-20250223175057853.png" alt="image-20250223175057853" style="zoom:67%;" />





<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/376564740">面试必备：4种经典限流算法讲解 - 知乎</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>  固定窗口限流算法</span><br><span class="line">  | 首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。</span><br><span class="line"></span><br><span class="line">   当次数少于限流阀值，就允许访问，并且计数器+<span class="number">1</span></span><br><span class="line">   当次数大于限流阀值，就拒绝访问。</span><br><span class="line">   当前的时间窗口过去之后，计数器清零。</span><br><span class="line"><span class="number">02</span> 漏桶算法</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line"><span class="number">03</span> 令牌桶算法  （目前建议使用的）</span><br><span class="line">   Guava的RateLimiter限流组件，就是基于令牌桶算法实现的。</span><br></pre></td></tr></table></figure>





<h1 id="网关的作用，经常使用的组件"><a href="#网关的作用，经常使用的组件" class="headerlink" title="网关的作用，经常使用的组件"></a>网关的作用，经常使用的组件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  身份认证，权限鉴定</span><br><span class="line">2    服务路由转发  和负载均衡</span><br><span class="line">3   过滤器</span><br><span class="line">4   拦截器</span><br><span class="line">5   请求限流 sentinel</span><br><span class="line">6   网关可以是zuul也可以是gateway, 现在更喜欢使用gateWay</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="负载均衡的算法"><a href="#负载均衡的算法" class="headerlink" title="负载均衡的算法"></a>负载均衡的算法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务端负载均衡：：NGINX</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">负载均衡通器常有两种实现手段，一种是服务端负载均衡器，另一种是客户端负载均衡器，而我们今天的主角 Ribbon 就属于后者——客户端负载均衡器。</span><br><span class="line"></span><br><span class="line">7种负载均衡策略</span><br><span class="line">1.轮询策略</span><br><span class="line">2.权重策略</span><br><span class="line">3.随机策略</span><br><span class="line">4.最小连接数策略</span><br><span class="line">5.重试策略</span><br><span class="line">6.可用性敏感策略</span><br><span class="line">7.区域敏感策略</span><br><span class="line"></span><br><span class="line">Ribbon 为客户端负载均衡器，相比于服务端负载均衡器的统一负载均衡策略来说，它提供了更多的灵活性。Ribbon 内置了 7 种负载均衡策略：轮询策略、权重策略、随机策略、最小连接数策略、重试策略、可用性敏感策略、区域性敏感策略，并且用户可以通过继承 RoundRibbonRule 来实现自定义负载均衡策略。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">但是我们应该区别一下, 到底是因为内存泄漏还是内存溢出: </span><br><span class="line"></span><br><span class="line">内存泄漏,  创建了很多类的对象, 这类对象不是必要的, 并且这些类对象应该在被使用完之后被垃圾回收器回收, 但是因为某些疏忽导致没有被回收, 此种情况被成为内存泄漏, 一般会引起非常大的故障</span><br><span class="line">内存溢出则跟泄漏相近, 但是内存溢出创建的对象是有必要的, 创建的对象在运行期间一直需要, 但是再进行额外的创建的时候, 因为内存空间不够而抛出OOM异常, 就是内存溢出</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/niceffking/article/details/142313709</span><br></pre></td></tr></table></figure>



<h1 id="ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因"><a href="#ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因" class="headerlink" title="ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因"></a>ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s?__biz=MzU3OTc1MDM1Mg==&amp;mid=2247500218&amp;idx=1&amp;sn=176abfecb79d02358eea5b15d1e2d9b3&amp;chksm=fd63d105ca1458131453ba890bb4e28e3fbf71ef4d53cddc80c68bc8e17d21241d192586fcc1&amp;scene=21#wechat_redirect</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/zxlp520/article/details/107074275</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">ConcurrentHashMap 主要使用的是 CAS+自旋+synchronized+多重check 来保证在初始化，新增，和扩容的时候线程安全，读取数据的时候则使用了 volatitle 让元素节点 在多线程之间 可见，从而达到获取最新的值</span><br></pre></td></tr></table></figure>



<h1 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//调试日志</span><br><span class="line">private final static Logger logger = LoggerFactory.getLogger(RocketMQSendTest.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="放重复提交的处理方案"><a href="#放重复提交的处理方案" class="headerlink" title="放重复提交的处理方案"></a>放重复提交的处理方案</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33454058/article/details/125516310">java开发中 防止重复提交的几种方案_java防止重复提交-CSDN博客</a></p>
<p><img src="/$%7Bimages%7D/image-20250223171341206.png" alt="image-20250223171341206"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">什么是接口幂等性？？</span><br><span class="line"></span><br><span class="line">接口幂等性是指在分布式系统中，对于相同的请求，无论请求多少次，都应该返回相同的结果。这意味着，如果请求已经处理完毕，那么重复请求应该返回相同的响应，而不应该产生额外的副作用。这种特性对于确保系统的稳定性和一致性非常重要，尤其是在处理并发请求和网络异常的情况下。在编程中，可以通过一些特定的设计来实现接口幂等性，例如使用全局唯一的ID来标记请求，或者使用乐观锁机制来防止重复处理等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> https:<span class="comment">//www.cnblogs.com/vipstone/p/13328386.html</span></span><br><span class="line"><span class="number">02</span>   本地缓存设置一个集合HashMap  ,如果containKey(),存在值，说明已经请求过了，就拒绝。这个当然不适合，但是是一个基本雏形</span><br><span class="line"><span class="number">03</span>   在表单 session .token放入唯一标识符（UUID）,首次请求保存到本地缓存中，设置一定过期时间，保证设置的短暂时间</span><br><span class="line"><span class="number">04</span>   使用LRUMap  实现放重复提交</span><br><span class="line"><span class="comment">// 根据 LRU(Least Recently Used，最近最少使用)算法淘汰数据的 Map 集合，最大容量 100 个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUMap&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> <span class="title class_">LRUMap</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 幂等性判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(String id, Object lockClass)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockClass) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请勿重复提交！！！&quot;</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非重复请求，存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">05</span>  redis  分布式锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="LRUMap-实现原理分析"><a href="#LRUMap-实现原理分析" class="headerlink" title="LRUMap 实现原理分析"></a>LRUMap 实现原理分析</h1><h1 id="关于CAS理解和应用"><a href="#关于CAS理解和应用" class="headerlink" title="关于CAS理解和应用"></a>关于CAS理解和应用</h1><p><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare/index.html?id=60dbd623e3b9c51e673d2ba45722a1c2&type=note&_time=1743671182368">06-并发编程之深入理解CAS.note</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">CAS缺陷  3个</span><br><span class="line">CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：</span><br><span class="line">01  如果涉及库存超卖的场景 涉及redis操作， 自旋 CAS 长时间地不成功，空转 ，，，则会给 CPU 带来非常大的开销  </span><br><span class="line">----解决办法  ：：使用reenTranLock </span><br><span class="line">02  只能保证一个共享变量原子操作   ---- 解决办法 ：； 使用 AtomicReference </span><br><span class="line">03  ABA 问题     --- 解决ABA问题可以使用 AtomicStampedReference类，使用内封装一个版本号version</span><br></pre></td></tr></table></figure>





<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>[发现更多精彩视频 - 抖音搜索](<a target="_blank" rel="noopener" href="https://www.douyin.com/discover/search/concurrentHashMap">https://www.douyin.com/discover/search/concurrentHashMap</a> 流程?aid&#x3D;c36a335a-7438-4183-b5c5-95ee1d2b6395&amp;modal_id&#x3D;7112094067030330665&amp;type&#x3D;general)</p>
<h1 id="分段累加技术如何实现，逻辑"><a href="#分段累加技术如何实现，逻辑" class="headerlink" title="分段累加技术如何实现，逻辑"></a>分段累加技术如何实现，逻辑</h1><h1 id="最新JDK17和22-的新特点"><a href="#最新JDK17和22-的新特点" class="headerlink" title="最新JDK17和22 的新特点"></a>最新JDK17和22 的新特点</h1><h1 id="支付系统的幂等性（常见处理方法）"><a href="#支付系统的幂等性（常见处理方法）" class="headerlink" title="支付系统的幂等性（常见处理方法）"></a>支付系统的幂等性（常见处理方法）</h1><p><img src="/$%7Bimages%7D/image-20250506103831201.png" alt="image-20250506103831201"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">5.4</span> </span><br><span class="line">   <span class="number">5.4</span>一锁判三更新</span><br><span class="line">在高并发场景中，支付宝团队提出了一种综合性的幕等解决方案：”一锁二判三更新”：</span><br><span class="line"><span class="number">1</span>：先加锁：使用Redis分布式锁，确保在处理请求时不会有其他请求干扰。</span><br><span class="line"><span class="number">2</span>：进行幕等性判断：检查请求是否已被处理，可以基于状态机、唯一性索引等进行判断</span><br><span class="line"><span class="number">3</span>，数据更新：如果判断通过，执行数据更新操作，并在完成后释放锁</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/%E9%98%BF%E9%87%8C%E6%94%AF%E4%BB%98%E5%B9%82%E7%AD%89%E6%80%A7%E9%80%BB%E8%BE%91%E5%9B%BE.drawio.png" alt="阿里支付幂等性逻辑图.drawio"></p>
<h1 id="springboot配置文件加载优先级"><a href="#springboot配置文件加载优先级" class="headerlink" title="springboot配置文件加载优先级"></a>springboot配置文件加载优先级</h1><h1 id="springweb和springwebmvc区别"><a href="#springweb和springwebmvc区别" class="headerlink" title="springweb和springwebmvc区别"></a>springweb和springwebmvc区别</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zyunfei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  <!--  km 多级目录 -->
      <script type="text/javascript" src="/js/category.js"></script>

</body>
</html>
