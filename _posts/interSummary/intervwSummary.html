<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zyunfei63.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12,"display":"post"},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"enable":true,"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="hashMap详细理解HashMap数据结构，太齐全了！-CSDN博客 一文读懂HashMap高频考点：从哈希碰撞到红黑树优化，为何它总在面试中高频出现？ - 知乎 1D:\Location\技术积累区\tuling线程并发\高并发代码\第三四节monkkey\juc\src\main\java\bat\ke\qq\com         12345678910111213141516171819">
<meta property="og:type" content="website">
<meta property="og:title" content="intervmSummary">
<meta property="og:url" content="https://zyunfei63.github.io/_posts/interSummary/intervwSummary.html">
<meta property="og:site_name" content="Alex Hexo">
<meta property="og:description" content="hashMap详细理解HashMap数据结构，太齐全了！-CSDN博客 一文读懂HashMap高频考点：从哈希碰撞到红黑树优化，为何它总在面试中高频出现？ - 知乎 1D:\Location\技术积累区\tuling线程并发\高并发代码\第三四节monkkey\juc\src\main\java\bat\ke\qq\com         12345678910111213141516171819">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/2025-04-10_141635.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250411151525781.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20250410205250313.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20250506154849973.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250506190704049.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250506190627649.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250506235457063.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250507142514521.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20251002122024538.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250411222043883.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250411213108255.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/concurrentHashMap%E4%B9%8Bput%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B.drawio.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250412100743466.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250505161916657.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20250422203655029.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240710172712752.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240805150522195.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250505173757051.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240417180341915.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20240711140337640.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20240711140415942.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20230602215952873.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240805195931149.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/1218593-20240426100039088-2002035695.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/spring_bean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.jpg">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20240806115005019.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240806115339948.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250311180721292.png">
<meta property="og:image" content="https://zyunfei63.github.io/2025/03/02/hello-world/intervwSummary/image-20240712111316519.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240712111316519.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20240712111316519.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240711110723793.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240807105315479.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240807105340582.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E5%8E%9F%E5%AD%90%E6%80%A7.jpg">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240806203728392.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240319140506785.png">
<meta property="article:published_time" content="2025-10-02T05:34:53.000Z">
<meta property="article:modified_time" content="2025-10-02T05:38:52.305Z">
<meta property="article:author" content="zyunfei">
<meta property="article:tag" content="Java, go,js,Resume">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/hashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="https://zyunfei63.github.io/_posts/interSummary/intervwSummary">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"en","comments":true,"permalink":"https://zyunfei63.github.io/_posts/interSummary/intervwSummary.html","path":"_posts/interSummary/intervwSummary.html","title":"intervmSummary"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>intervmSummary | Alex Hexo
</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GF5PJZTEZ"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-5GF5PJZTEZ","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Alex Hexo</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">可以开发出自己的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/home" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fas fa-folder fa-fw"></i>分类</a></li><li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fas fa-briefcase fa-fw"></i>简历</a></li><li class="menu-item menu-item-github"><a href="https://github.com/zyunfei63" rel="section" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#hashMap"><span class="nav-number">1.</span> <span class="nav-text">hashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E7%94%B3%E6%B6%89%E5%8F%8A-hashCode-equle-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="nav-number">1.1.</span> <span class="nav-text">延申涉及 hashCode ()  equle()方法重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="nav-number">1.2.</span> <span class="nav-text">什么是哈希冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E8%BF%87%E9%95%BF-%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E8%BF%87%E4%BD%8E-%E6%89%80%E4%BB%A5-%E6%94%B9%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">1.3.</span> <span class="nav-text">链表过长 查询效率过低 所以 改为红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">为什么 HashMap 使用红黑树而不是二叉树&#x2F;平衡二叉树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8String%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84Key%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">为什么经常使用String作为HashMap的Key？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E9%87%87%E7%94%A8%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">为什么HashMap采用链地址法而不是开放寻址法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashmap%E7%9A%84hash%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%AE%A9%E9%AB%9816%E4%BD%8D%E5%8F%82%E4%B8%8E%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.7.</span> <span class="nav-text">hashmap的hash方法为什么需要让高16位参与异或运算的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E6%A0%87%E8%AE%B0"><span class="nav-number">1.8.</span> <span class="nav-text">源码标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#putVal-%E8%BF%94%E7%9A%84%E6%97%A7%E7%9A%84%E5%80%BC%E4%B8%BA%E5%95%A5"><span class="nav-number">1.9.</span> <span class="nav-text">putVal()返的旧的值为啥</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ConcurrentHashMap%E7%9A%84%E4%BD%BF%E7%94%A8-%E4%BB%A5%E5%8F%8A%E5%85%B7%E4%BD%93%E4%BD%8D%E7%BD%AE%E5%93%AA%E4%B8%AA%E8%8A%82%E7%82%B9%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%88%E5%85%B7%E4%BD%93%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">ConcurrentHashMap的使用,以及具体位置哪个节点起作用（具体罗辑思维）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85-%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">知识点补充 原码 反码 补码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">2.2.</span> <span class="nav-text">移位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk1-7-concurrentHashMap%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.3.</span> <span class="nav-text">jdk1.7  concurrentHashMap的简单介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#currenthashMap%E5%A4%A7%E8%87%B4%E6%89%A9%E5%AE%B9%E6%80%9D%E8%B7%AF-%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E5%9B%BE%E6%9C%80%E5%A5%BD"><span class="nav-number">2.4.</span> <span class="nav-text">currenthashMap大致扩容思路(使用逻辑图最好)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrenthashmap-%E5%92%8ChashMap%E7%9A%84%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB"><span class="nav-number">2.5.</span> <span class="nav-text">concurrenthashmap 和hashMap的有啥区别?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%86%E5%8C%96%E6%AF%94%E8%BE%83%E4%B8%80%E4%B8%8B-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">2.5.1.</span> <span class="nav-text">细化比较一下 扩容机制的不同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap%E9%80%89%E4%BB%A3%E5%99%A8%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E8%BF%98%E6%98%AF%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">ConcurrentHashMap选代器是强一致性还是弱一致性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E4%B8%8D%E5%85%85%E8%AE%B8null%E5%80%BC%EF%BC%9F"><span class="nav-number">2.7.</span> <span class="nav-text">为什么ConcurrentHashMap不充许null值？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C-%E5%AF%B9%E6%AF%94"><span class="nav-number">3.</span> <span class="nav-text">#和$  对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E5%AF%B9%E6%AF%94-%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%EF%BC%8C-hashMap-LinkedHashMap%E5%8C%BA%E5%88%AB%EF%BC%8C"><span class="nav-number">4.</span> <span class="nav-text">常见集合对比   以及数据结构  ， hashMap  LinkedHashMap区别，</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stream-%E5%92%8C-foreach-%E5%AF%B9%E6%AF%94-%E6%80%A7%E8%83%BD-%EF%BC%8C%E8%82%AF%E5%AE%9A%E6%98%AFstream%E6%9B%B4%E5%A5%BD"><span class="nav-number">5.</span> <span class="nav-text">stream 和 foreach  对比 性能 ，肯定是stream更好</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#forkJoin%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E2%80%94%E2%80%94-Fork-Join-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3-forkjoin%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86-CSDN%E5%8D%9A%E5%AE%A2"><span class="nav-number">6.</span> <span class="nav-text">forkJoin的原理以及使用方法 Java 并发编程 —— Fork&#x2F;Join 框架的原理详解_forkjoin框架原理-CSDN博客</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jdk8%E6%96%B0%E5%A2%9E%E7%9A%84%E6%B3%A8%E8%A7%A3-sun-misc-Contended"><span class="nav-number">7.</span> <span class="nav-text">jdk8新增的注解 @sun.misc.Contended</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C"><span class="nav-number">8.</span> <span class="nav-text">了解并发 并行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%8Cload-store"><span class="nav-number">9.</span> <span class="nav-text">什么是指令重排序，load store</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">10.</span> <span class="nav-text">final 关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8C%BA%E5%88%AB"><span class="nav-number">11.</span> <span class="nav-text">接口和抽象类区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">12.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B-ThreadLOCAL-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3%E7%B1%BB%E7%86%9F%E6%82%89-%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">13.</span> <span class="nav-text">线程  ThreadLOCAL   常用的线程接口类熟悉  线程队列的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">13.1.</span> <span class="nav-text">内存泄露的原因</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jdbc-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-6%E4%B8%AA%E8%BF%87%E7%A8%8B-%E6%B6%89%E5%8F%8A-%EF%BC%88-jdbc%E5%B0%B1%E6%98%AF%E4%B8%80%E5%A5%97%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83-%EF%BC%89"><span class="nav-number">14.</span> <span class="nav-text">jdbc 执行过程  6个过程 涉及 （  jdbc就是一套接口规范 ）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%87%BA%E7%8E%B0%E6%83%85%E5%86%B5-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%88%E7%A0%B4%E5%9D%8F%E6%AD%BB%E9%94%81%E6%88%90%E7%AB%8B%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E2%80%94%E6%9D%A5%E8%87%AA-%E6%8A%96%E9%9F%B3%E6%A3%80%E7%B4%A2-mic%EF%BC%89"><span class="nav-number">15.</span> <span class="nav-text">死锁出现情况  解决办法（破坏死锁成立条件的四个其中一个—来自 抖音检索  mic）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B-%E2%80%93%E5%AD%98%E5%9C%A8%E4%B8%80%E7%A7%8D%E4%B8%80%E7%A7%8D%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6-3%E4%B8%AA%E5%AF%B9%E6%AF%94%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89"><span class="nav-number">16.</span> <span class="nav-text">如何优雅的终止线程  –存在一种一种线程中断机制   3个对比（线程并发的知识点）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="nav-number">17.</span> <span class="nav-text">事务的基本要素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84-%E5%AF%B9%E8%B1%A1"><span class="nav-number">18.</span> <span class="nav-text">不可修改的 对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">内核态和用户态区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%89%E7%A7%8D%EF%BC%88%E9%80%89%E6%8B%A9%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%89%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">20.</span> <span class="nav-text">线程模型三种（选择多对多）和线程状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%94%BE%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E6%96%B9%E6%A1%88"><span class="nav-number">21.</span> <span class="nav-text">放重复提交方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%88%86%E6%BB%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">22.</span> <span class="nav-text">数据库连接池爆满解决方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8E%B0%E5%9C%BA%E8%BF%87%E5%A4%9A%E6%97%A5%E5%BF%97%E6%8F%90%E7%A4%BA%E5%95%A5%E9%94%99%E8%AF%AF"><span class="nav-number">23.</span> <span class="nav-text">现场过多日志提示啥错误</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8Credis%E8%BF%9E%E6%8E%A5%E6%B1%A0-%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0"><span class="nav-number">24.</span> <span class="nav-text">数据库连接池和redis连接池 对比学习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mybaits%E4%BC%98%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81sql%E5%AE%9E%E7%8E%B0"><span class="nav-number">25.</span> <span class="nav-text">mybaits优点以及动态sql实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97"><span class="nav-number">26.</span> <span class="nav-text">spring  bean是线程安全吗</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springboot-%E4%B8%89%E4%B8%AA%E5%A4%A7%E6%B3%A8%E8%A7%A3-%E4%B9%8B%E4%B8%80-EnableAutoConfiguration-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%EF%BC%88%E6%B6%89%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%89"><span class="nav-number">27.</span> <span class="nav-text">springboot 三个大注解    之一  @EnableAutoConfiguration  工作原理  （涉及自动装配）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">Spring Boot如何实现配置文件的自动加载和刷新？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="nav-number">28.1.</span> <span class="nav-text">加载顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-Resource%E5%92%8Cautowire%E5%8C%BA%E5%88%AB"><span class="nav-number">29.</span> <span class="nav-text">spring   依赖注入  Resource和autowire区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">30.</span> <span class="nav-text">spring三级缓存 循环依赖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1-%E6%B3%A8%E8%A7%A3%EF%BC%88%E4%BA%8B%E5%8A%A1%E7%9A%84aop%E5%92%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%EF%BC%89"><span class="nav-number">31.</span> <span class="nav-text">spring事务   注解（事务的aop和代理对象的实现逻辑）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring-%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%BA%90%E7%A0%81"><span class="nav-number">32.</span> <span class="nav-text">spring 如何操作数据库事务的源码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%8B%E5%8A%A1%E4%B8%BA%E5%95%A5%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">33.</span> <span class="nav-text"> spring多线程事务为啥不能保证原子性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springMVC-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E2%80%93%E7%9B%B4%E6%8E%A5%E7%9C%8B%E4%B8%8B%E9%9D%A2%E8%BF%9E%E6%8E%A5"><span class="nav-number">34.</span> <span class="nav-text">springMVC 工作流程–直接看下面连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sql%E8%AF%AD%E5%8F%A5-%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">35.</span> <span class="nav-text">sql语句  查询方式联合查询</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-%E4%B8%8E-HTTPS-%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">HTTP 与 HTTPS 区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">37.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AEspringcloud-%E5%92%8C-zookeeper-dubbo%EF%BC%9A%EF%BC%9A-%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94%E5%8E%9F%E5%9B%A0-%E9%80%89%E5%9E%8B-%E5%8E%9F%E5%9B%A0"><span class="nav-number">38.</span> <span class="nav-text">大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#intrvmSummary2%E2%80%94"><span class="nav-number">39.</span> <span class="nav-text">intrvmSummary2—-&gt;</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zyunfei"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">zyunfei</p>
  <div class="site-description" itemprop="description">版本1.0</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="en"><header class="post-header">

<h1 class="post-title" itemprop="name headline">intervmSummary
</h1>

<div class="post-meta-container">
  <ul class="breadcrumb">
            <li><a href="/_posts/">_POSTS</a></li>
            <li><a href="/_posts/interSummary/">INTERSUMMARY</a></li>
            <li>INTERVWSUMMARY</li>
  </ul>
</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37084904/article/details/109243886">详细理解HashMap数据结构，太齐全了！-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30946244897">一文读懂HashMap高频考点：从哈希碰撞到红黑树优化，为何它总在面试中高频出现？ - 知乎</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Location\技术积累区\tuling线程并发\高并发代码\第三四节monkkey\juc\src\main\java\bat\ke\qq\com</span><br></pre></td></tr></table></figure>



<img src="${images}/hashMap数据结构.png" alt="hashMap数据结构" style="zoom: 50%;" />

<p><img src="./2025-04-10_141635.png" alt="2025-04-10_141635" style="zoom: 67%;" /><img src="/$%7Bimages%7D/image-20250411151525781.png" alt="image-20250411151525781"></p>
<img src="${images}/image-20250410205250313.png" alt="image-20250410205250313" style="zoom:67%;" />

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">1.7  头插入法 会死循环问题 ，1.8之后修正为尾插法</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">1.8之前采用数组加链表的数据结构（1.7没有红黑树结构），1.8采用数组加链表加红黑树的数据结构。</span><br><span class="line">     桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。</span><br><span class="line">     </span><br><span class="line"> a1::</span><br><span class="line"> HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的</span><br><span class="line"> HashMap最多允许有一个键为null，允许多个值为null；</span><br><span class="line"> </span><br><span class="line"> 相反 concurrentHashMap的key value不能是null</span><br><span class="line"> HashTable不允许键或值为null</span><br><span class="line"> </span><br><span class="line"> a2:: 存储过程，链表会存在 哈希碰撞，  jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> a3:: 成员变量 负债因子 初始化容量</span><br><span class="line"> a4:: 当HashMap中的元素个数超过数组长度loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75=12(这个值就是阈值)的时候，就把数组的大小扩展为2×16=32，即扩大一倍，然后重新计算每个元素在数组中的位置</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">a5:: 链表切换红黑树 </span><br><span class="line">JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值 （++size &gt; threshold）（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。 当这个链表长度大于阈值8并且数组长度大于64则进行将链表变为红黑树。</span><br><span class="line"> 将链表转换成红黑树前会判断，如果阈值大于8，但是数组长度小64，此时并不会将链表变为红黑树。而是选择进行数组扩容。变为红黑树的目的是为了高效的查询。</span><br><span class="line">    </span><br><span class="line">    a6::如果红黑树节点个数 &lt; 6 ，转为链表（取消树化）</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">flage HashMap特点::</span><br><span class="line">     存取无序的</span><br><span class="line"></span><br><span class="line">键和值位置都可以是null，但是键位置只能是一个null</span><br><span class="line"></span><br><span class="line">键位置是唯一的，底层的数据结构控制键的</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">jdk1.8前数据结构是：链表 + 数组 数据结构 来解决冲突  jdk1.8之后是 ：链表 + 数组  + 红黑树  来解决冲突  </span><br><span class="line">-----------9999</span><br><span class="line">         </span><br><span class="line">         ----</span><br><span class="line">     </span><br><span class="line">         </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     a2::存储过程</span><br><span class="line">   当两个对象的hashCode相等时会怎么样？</span><br><span class="line"></span><br><span class="line">会产生哈希碰撞，若key值内容相同则替换旧的value.否则连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</span><br><span class="line"></span><br><span class="line">何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</span><br><span class="line"></span><br><span class="line">只要两个元素的key计算的哈希值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</span><br><span class="line"></span><br><span class="line">如果两个键的hashcode相同，如何存储键值对？</span><br><span class="line"></span><br><span class="line">hashcode相同，通过equals比较内容是否相同。</span><br><span class="line">         ----相同（String类型情况下：：引用地址相同或者内容相同）：则新的value覆盖之前的value，</span><br><span class="line">         --不相同：则将新的键值对添加到链表或者红黑树下一个节点</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为8）并且当前数组的长度大于64时，此时此arr[index]  如:sarr[9]索引位置上的所有数据改为使用红黑树存储。</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         两个对象一样对象 hashCode值一样， 重写equle. 方法   </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">          抖音源码分析分析：：  </span><br><span class="line">https://www.douyin.com/search/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90?aid=4705b39d-8246-4b5a-950f-95973e912c59&amp;modal_id=7298270278071667994&amp;type=general</span><br><span class="line"></span><br><span class="line">  红黑树演示网站：：  https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</span><br></pre></td></tr></table></figure>

<h2 id="延申涉及-hashCode-equle-方法重写"><a href="#延申涉及-hashCode-equle-方法重写" class="headerlink" title="延申涉及 hashCode ()  equle()方法重写"></a>延申涉及 hashCode ()  equle()方法重写</h2><img src="${images}/image-20250506154849973.png" alt="image-20250506154849973" style="zoom:67%;" />

<p><img src="/$%7Bimages%7D/image-20250506190704049.png" alt="image-20250506190704049"></p>
<p><img src="/$%7Bimages%7D/image-20250506190627649.png" alt="image-20250506190627649"></p>
<p><img src="/$%7Bimages%7D/image-20250506235457063.png" alt="image-20250506235457063"></p>
<p><img src="/$%7Bimages%7D/image-20250507142514521.png" alt="自定义的类MarkBoy"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结论：： 通过上面的分析，彻底理解了HashMap的原理以及冲突现象，也理解了为什么，要使用HashMap（以及HashSet）来存储的对象类一定要同时重写hashCode和equals方法。</span><br><span class="line"></span><br><span class="line">此外hashcode和equals的关系，</span><br><span class="line">1.hashcode值相等，equals()返回true.  对象一定一样</span><br><span class="line">2.其他三种情况 ，不确定了</span><br><span class="line"></span><br><span class="line">Object 的hashcode()是根據地址來返回值的即使兩個對象内容一樣，地址肯定不一樣，所以返回值也不一樣，</span><br><span class="line"></span><br><span class="line">总结：：  hashcode()和equals()方法在 Object和String，或者自己创建的类Student  里面都继承extends这些方法，</span><br><span class="line">       1. 首先 Object 的hashcode()是根据地址來计算返回值的即使兩個對象内容一樣，地址肯定不一樣，所以返回值hash值也不一樣。</span><br><span class="line">       2.第二Object .equals() 比较的是引用地址</span><br><span class="line">       3. 由于String这个类特别常用，相对于其他类 特殊重写了hashcode和equals()方法,具体可以看jdk8源码，上图也有</span><br><span class="line">       4. key值类型的不一样， 使用的hashcode()和equals()方法也不一样，如果自定义的引用数据类型（例如 Person,id ,name)这种，再重写两个方法时候具体的 方法体内容 自定义</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="headerlink" title="什么是哈希冲突"></a>什么是哈希冲突</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用的散列冲突解决方法有2类：   开放寻址法：例如:ThreadLocalMap；  链地址法：例如:HashMap。</span><br><span class="line"></span><br><span class="line">不同的对象，使用key (可能是字符串) 通过hashcode()方法 获得返回值，  两个对象index 相等</span><br><span class="line"></span><br><span class="line">解决办法 1. 使用 双向循环链表的 next属性 来 解决冲突  2. 使用 红黑树 解决</span><br></pre></td></tr></table></figure>

<h2 id="链表过长-查询效率过低-所以-改为红黑树"><a href="#链表过长-查询效率过低-所以-改为红黑树" class="headerlink" title="链表过长 查询效率过低 所以 改为红黑树"></a>链表过长 查询效率过低 所以 改为红黑树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>-- 这种情况最坏的查找无非也就查找高度次（那如果结点数量为N，它的高度通常保持在logN的水平），所以这样它的时间复杂度就是O（logN)。</span><br><span class="line"><span class="number">2</span>---  但是，避免不了出现这样的情况（单链条）  ，二叉搜索树退化为单支树(或者接近单支)，那这时查找的时间复杂度就应该是O(N)。</span><br><span class="line"> </span><br><span class="line"> 不默认使用红黑树 的原因 红黑苏 需要左旋 右旋  ，变色的操作 数据结构复杂，在冲突比较少的情况下，链表的查询效率实际上是会比较高一点</span><br><span class="line">  </span><br><span class="line">  取消树化 的阈值是  <span class="number">6</span>     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="为什么-HashMap-使用红黑树而不是二叉树-平衡二叉树？"><a href="#为什么-HashMap-使用红黑树而不是二叉树-平衡二叉树？" class="headerlink" title="为什么 HashMap 使用红黑树而不是二叉树&#x2F;平衡二叉树？"></a>为什么 HashMap 使用红黑树而不是二叉树&#x2F;平衡二叉树？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--- 红黑树本质上是 一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：</span><br><span class="line"></span><br><span class="line">每个节点要么是红色，要么是黑色；</span><br><span class="line">根节点永远是黑色的；</span><br><span class="line">所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节 点）；</span><br><span class="line">每个红色节点的两个子节点一定都是黑色；</span><br><span class="line">从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>---  之所以不用 二叉查找树：</span><br><span class="line"></span><br><span class="line">红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>-- 之所以不用平衡二叉树：</span><br><span class="line">    </span><br><span class="line">平衡二叉树是红黑树是一种自平衡二叉排序树，，，比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。</span><br></pre></td></tr></table></figure>

<h2 id="为什么经常使用String作为HashMap的Key？"><a href="#为什么经常使用String作为HashMap的Key？" class="headerlink" title="为什么经常使用String作为HashMap的Key？"></a><strong>为什么经常使用String作为HashMap的Key？</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、不可变类 String 可以避免修改后无法定位键值对： 假设 String 是可变类，当我们在 HashMap 中构建起一个以 String为Key的键值对时，此时对String进行修改，那么通过修改后的String是无法匹配到刚才构建过的键值对的，因为修改后的hashCode可能会变化，而不可变类可以规避这个问题；</span><br><span class="line">2、String能够满足Java对于hashCode()和 equals()的通用约定： 既两个对象equals()相同，则hashCode()一定相同，</span><br><span class="line"> 如果hashCode()相同，但是equals()不一定相同。</span><br><span class="line"> 这个约定是为了避免两个equals()相同的Key在HashMap中存储两个独立的键值对，引起矛盾。</span><br></pre></td></tr></table></figure>

<h2 id="为什么HashMap采用链地址法而不是开放寻址法"><a href="#为什么HashMap采用链地址法而不是开放寻址法" class="headerlink" title="为什么HashMap采用链地址法而不是开放寻址法"></a>为什么HashMap采用链地址法而不是开放寻址法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">而链地址法对于装载因子的容忍度更高，能够适合大数据量且更高的装载因子上限，内存利用率更高。虽然链表节点会多消耗一个指针内存，但在一般的业务场景中可以忽略不计。</span><br><span class="line"></span><br><span class="line">我们可以举个反例，在Java原生的数据结构中，也存在使用开放寻址法的散列表——就是ThreadlLocal。因为项目中不会大量使用ThreadLocal线程局部存储，所以它是一个小规模数据场景，这里使用开放寻址法是没问题的</span><br></pre></td></tr></table></figure>

<h2 id="hashmap的hash方法为什么需要让高16位参与异或运算的原因"><a href="#hashmap的hash方法为什么需要让高16位参与异或运算的原因" class="headerlink" title="hashmap的hash方法为什么需要让高16位参与异或运算的原因"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyvalley/p/14227702.html">hashmap的hash方法为什么需要让高16位参与异或运算的原因</a></h2><p><img src="/$%7Bimages%7D/image-20251002122024538.png" alt="image-20251002122024538"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">h = key.hashCode() - 获取对象的原始哈希码（<span class="number">32</span>位）</span><br><span class="line"></span><br><span class="line">h &gt;&gt;&gt; <span class="number">16</span> - 无符号右移<span class="number">16</span>位，将高<span class="number">16</span>位移动到低<span class="number">16</span>位</span><br><span class="line"></span><br><span class="line">h ^ (h &gt;&gt;&gt; <span class="number">16</span>) - 高<span class="number">16</span>位与低<span class="number">16</span>位进行异或运算</span><br><span class="line"></span><br><span class="line">原因：当数组的长度很短时，只有低位数的hashcode值能参与运算。而让高<span class="number">16</span>位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率。并且使得高<span class="number">16</span>位和低<span class="number">16</span>位的信息都被保留了</span><br></pre></td></tr></table></figure>

<h2 id="源码标记"><a href="#源码标记" class="headerlink" title="源码标记"></a>源码标记</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//    //   putIfAbsent方法：   V putIfAbsent(K key, V value);</span></span><br><span class="line"><span class="comment">//  而putIfAbsent方法在添加键值对时会进行检查，如果Map集合中不存在指定的键，则会添加键值对并返回null。如果Map中已经存在该键，则不会进行任何操作，也就是说旧的值不会被替换，而是保持不变，方法返回的也是原来的值。</span></span><br><span class="line">  <span class="keyword">default</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">      <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> get(key);</span><br><span class="line">      <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">          v = put(key, value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="putVal-返的旧的值为啥"><a href="#putVal-返的旧的值为啥" class="headerlink" title="putVal()返的旧的值为啥"></a>putVal()返的旧的值为啥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回旧值：让调用者知道这次操作替换掉了什么</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>





<h1 id="ConcurrentHashMap的使用-以及具体位置哪个节点起作用（具体罗辑思维）"><a href="#ConcurrentHashMap的使用-以及具体位置哪个节点起作用（具体罗辑思维）" class="headerlink" title="ConcurrentHashMap的使用,以及具体位置哪个节点起作用（具体罗辑思维）"></a>ConcurrentHashMap的使用,以及具体位置哪个节点起作用（具体罗辑思维）</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zerotomax/p/8687425.html#go0">ConcurrentHashMap源码分析(1.8) - Ouka傅 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://javabetter.cn/thread/ConcurrentHashMap.html#size-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95">吊打Java面试官之ConcurrentHashMap（线程安全的哈希表） | 二哥的Java进阶之路</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/zerotomax/p/8687425.html#go0</span><br><span class="line">https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html</span><br><span class="line">https://cloud.tencent.com/developer/article/2283647</span><br><span class="line">https://blog.csdn.net/fh667788123/article/details/105320428</span><br><span class="line">https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-%E6%89%A9%E5%AE%B9-rehash</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/639717596</span><br><span class="line"></span><br><span class="line">https://javabetter.cn/thread/ConcurrentHashMap.html#size-%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95</span><br><span class="line"></span><br><span class="line">D:\Location\2024常用的工具类收集\littleCollection\src\main\java\concurrentHashMap原理</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20250411222043883.png" alt="jdk1.7数据结构如下图"></p>
<h2 id="知识点补充-原码-反码-补码"><a href="#知识点补充-原码-反码-补码" class="headerlink" title="知识点补充 原码 反码 补码"></a>知识点补充 原码 反码 补码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/u011429167/article/details/129264625</span><br><span class="line">原码：是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值。</span><br><span class="line"></span><br><span class="line">反码：正数的反码和原码一致；负数的反码就是它的原码除符号位外，按位取反。</span><br><span class="line">补码：正数的原码、反码、补码都一致；负数的补码等于反码+1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    &amp;按位与的运算规则是将两边的数转换为二进制位，然后运算最终值，运算规则即(两个为真才为真)1&amp;1=1 , 1&amp;0=0 , 0&amp;1=0 , 0&amp;0=0</span><br><span class="line">//3的二进制位是0000 0011 ， 5的二进制位是0000 0101 ， 那么就是011 &amp; 101，由按位与运算规则得知，001 &amp; 101等于0000 0001，最终值为1</span><br><span class="line">//7的二进制位是0000 0111，那就是111 &amp; 101  等于101，也就是0000 0101，故值为5</span><br><span class="line">//-2是 2的补码   的二进制位是   补码= 反码（1111 1101）+1=1111 1110(就是-2)， 然后  1111 1110&amp;0000 0111=0110 =6(十进制)</span><br><span class="line"></span><br><span class="line">        System.out.println(3&amp;5);// result=1</span><br><span class="line">        System.out.println(5&amp;7);// result=5</span><br><span class="line">        System.out.println(-1&amp;7);// result=7</span><br><span class="line">        System.out.println(-2&amp;7);// result=6</span><br><span class="line">        System.out.println(2&amp;7);// result=2</span><br><span class="line">        或运算  1100 | 1010 =1110</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----01 原码  最高位是符号--------------</span><br><span class="line"> 原码 (Sign-Magnitude)</span><br><span class="line">是什么？ 表示有符号整数最直观的方法。</span><br><span class="line">规则：</span><br><span class="line">最高位 (最左边的位) 是符号位：</span><br><span class="line">0 表示 正数</span><br><span class="line">1 表示 负数</span><br><span class="line">剩下的位 (数值位) 表示这个数的绝对值的二进制形式。</span><br><span class="line">例子 (8位系统)：</span><br><span class="line">+1=00000000 00000000 00000000 00000001</span><br><span class="line">-1=10000000 00000000 00000000 00000001</span><br><span class="line">+5 = 0 ...0000101 = 00000101 (符号位0 + 5的二进制)</span><br><span class="line">-5 = 1 ...0000101 = 10000101 (符号位1 + 5的二进制)</span><br><span class="line">问题：</span><br><span class="line">存在 +0 和 -0： 00000000 和 10000000 都表示“零”。这会造成计算和比较上的混乱。</span><br><span class="line">加减法运算复杂： 计算机做加法电路最简单高效。但用原码做加减法时，需要先判断符号位，再决定是做加法还是减法，效率低且电路设计复杂。</span><br><span class="line"> --------02 反码  ------------------------------------------------------------</span><br><span class="line">反码 (Ones&#x27; Complement)</span><br><span class="line">是什么？ 为了解决原码运算问题而提出的改进方案（但仍有缺陷）。</span><br><span class="line">规则：</span><br><span class="line">正数： 其反码和原码相同。</span><br><span class="line">负数： 将其对应的正数的原码的所有位按位取反（0 变 1，1 变 0）。</span><br><span class="line">例子 (8位系统)：</span><br><span class="line">+5 的原码是 00000101 -&gt; 反码也是 00000101</span><br><span class="line">-5：</span><br><span class="line">先找 +5 的原码：00000101</span><br><span class="line">所有位取反：11111010 -&gt; -5 的反码是 11111010        </span><br><span class="line">----------------------  03 补码  补码= 反码+1  ----------------------     ----------------------</span><br><span class="line">补码 (Two&#x27;s Complement) - 现代计算机标准</span><br><span class="line">是什么？ 在反码基础上进一步改进，完美解决了 ±0 问题和运算问题，成为现代计算机表示有符号整数的唯一标准。</span><br><span class="line">规则：</span><br><span class="line">正数： 其补码和原码、反码都相同。</span><br><span class="line">负数： 将其对应的正数的原码，所有位按位取反（得到反码），然后加 1。</span><br><span class="line">例子 (8位系统)：</span><br><span class="line">+5 的补码 = 原码 = 00000101</span><br><span class="line"></span><br><span class="line">-5：：：</span><br><span class="line">+5 原码：00000101</span><br><span class="line">按位取反 (得到反码)：11111010</span><br><span class="line">加 1： 11111010 + 1 = 11111011 -&gt; -5 的补码是 11111011  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/bit-operation.html">位运算（&amp;、|、^、~、&gt;&gt;、 | 菜鸟教程</a></p>
<h2 id="jdk1-7-concurrentHashMap的简单介绍"><a href="#jdk1-7-concurrentHashMap的简单介绍" class="headerlink" title="jdk1.7  concurrentHashMap的简单介绍"></a>jdk1.7  concurrentHashMap的简单介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用两个类型数组  segment，HashEntry,使用ReentranLock 可重入锁，</span><br><span class="line">HashEntry 每个槽位 放的是单向链表，链表是 头节点插入法，(<span class="number">1.8</span> 之后改为 尾插入)</span><br><span class="line"></span><br><span class="line">问题是：： 由于业务的需求 并发度太高情况，任然出现大量锁竞争的情况，导致性能下降</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>锁分离技术：在JDK <span class="number">1.7</span>中，通过Segment的锁分离技术减少锁竞争。</span><br><span class="line">&#123;</span><br><span class="line">JDK <span class="number">1.7</span> 实现：</span><br><span class="line">分段锁（Segment）：ConcurrentHashMap 将整个 HashMap 分成多个 Segment，每个 Segment 类似一个小的 HashMap，并且用锁来保护。因此，多个线程可以同时访问不同的 Segment，从而提高并发性能。</span><br><span class="line">分段操作：通过对键的哈希值取不同的高位来确定数据存放的 Segment。每个 Segment 独立的加锁操作，减少了锁的粒度，提高了并发性能，但是对内存CPU不友好· 。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">###碎片记录</span><br><span class="line"><span class="number">1.</span>线程安全的保证</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>concurrentHashMap  但是这个数组只有在第一次添加元素的时候才会初始化，否则只是初始化一个ConcurrentHashMap对象的话，只是设定了一个sizeCtl变量，这个变量用来判断对象的一些状态和是否需要扩容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> CAS操作：在JDK <span class="number">1.8</span>中，通过CAS操作(主要使用 compareAndSwapObject（）方法来操作 数组)来保证更新操作的原子性。</span><br><span class="line">    <span class="keyword">volatile</span>关键字：使用<span class="keyword">volatile</span>关键字保证变量的内存可见性，确保每次读取变量时都能得到最新的值。</span><br><span class="line">    初始化Node数组 使用cas+<span class="keyword">volatile</span>,  &#123; <span class="keyword">volatile</span> 修饰的变量 有 下面</span><br><span class="line"><span class="keyword">volatile</span> Node&lt;K,V&gt;[] table; <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> baseCount;   <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> transferIndex;   <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span> 在给链表或者红黑树  put放数据时候采用 synchr枷锁</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">6.</span> <span class="keyword">synchronized</span>关键字：在JDK <span class="number">1.8</span>中，通过<span class="keyword">synchronized</span>关键字来保证对链表和红黑树节点的同步修改操作。（  sychr锁的是 Node[]  里面 每个槽位的链表 的头部，）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>从（<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>）总结来说，ConcurrentHashMap通过引入锁分离技术、CAS操作、<span class="keyword">synchronized</span>关键字和<span class="keyword">volatile</span>关键字等多种机制来保证线程安全，同时通过链表转红黑树的优化提高了查询性能。这些改进使得ConcurrentHashMap在多线程环境下成为一个高效且线程安全的HashMap实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>复制之后的新链表不是旧链表的绝对倒序。</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>在扩容的时候每个线程都有处理的步长，最少为<span class="number">16</span>，在这个步长范围内的数组节点只有自己一个线程来处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> 原理总结思路细化：：：</span><br><span class="line">  <span class="number">1.</span>concurrentHashMap没有粗暴的给整个数组加锁 原因是很明显这样线程安全，效率极低。</span><br><span class="line">  <span class="number">2.</span>如果给数组的每个头节点 枷锁 这样并发度就是<span class="number">16</span> ，提高<span class="number">16</span>倍速，这样数组有多长 并发度就有多少，提高了并发度。</span><br><span class="line">  <span class="number">3.</span>举例 例如现在做一个 加加操作 ，多线程操作一个变量 a，如果给整个变量a 加上排他锁sychr 同意时间碎片只有一个thread，并发度又降下来，不合理。设计者 使用了轻量级的compare and swap方式,同一时间碎片，只有一个线程在操作变量a,其他线程不断在<span class="keyword">for</span>(;;) 里面循环重试，这样虽然解决所开销的问题，但是效率还是不是很高， 于是设计者又考虑  可以咋失败时候可以新建一个数组counterCells[]  专门负责 失败时候值的 累加，</span><br><span class="line">  <span class="number">4.</span>  put思路：：</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>:flags:  案例测试位置：：  D:\Location\2024常用的工具类收集\littleCollection\src\main\java\concurrentHashMap原理\ConcurrentHashMap006.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;     它代表将<span class="number">1</span>左移<span class="number">30</span>位 <span class="type">int</span> <span class="number">4</span>位  <span class="number">2</span>^<span class="number">4</span>=<span class="number">32</span>  和这个字节数有关  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//       transient 修饰的变量 不进行序列化对象</span></span><br><span class="line">    <span class="comment">//  bin 数组。第一次插入时延迟初始化。 大小始终是 2 的幂。由迭代器直接访问。</span></span><br><span class="line">    <span class="comment">// 数组类型是  链表  Node&lt;K,V&gt;  没有进行初始化定义的数组</span></span><br><span class="line">       <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//  onlyIfAbsent 是否存在相同的值，如果有相同值是否替换 true--替换 false相反， evict是否使用构造模式</span></span><br><span class="line"> <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">02</span>---初始化方法中 </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    sizeCtl ：默认为<span class="number">0</span>，用来控制table的初始化和扩容操作</span><br><span class="line">-<span class="number">1</span> 代表table正在初始化</span><br><span class="line">-N 应该取-N对应的二进制的低<span class="number">16</span>位数值为M，此时有M-<span class="number">1</span>个线程进行扩容。（这个地方比较复杂 ，先简单了解？？？）</span><br><span class="line">其余情况：</span><br><span class="line"><span class="number">1</span>、如果table未初始化，表示table需要初始化的大小。</span><br><span class="line"><span class="number">2</span>、如果table初始化完成，表示table的容量，默认是table大小的<span class="number">0.75</span>倍</span><br><span class="line"></span><br><span class="line">    红黑树的演示网站</span><br><span class="line">    https:<span class="comment">//www.cs.usfca.edu/~galles/visualization/RedBlack.html</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/$%7Bimages%7D/image-20250411213108255.png" alt="image-20250411213108255"></p>
<h2 id="currenthashMap大致扩容思路-使用逻辑图最好"><a href="#currenthashMap大致扩容思路-使用逻辑图最好" class="headerlink" title="currenthashMap大致扩容思路(使用逻辑图最好)"></a>currenthashMap大致扩容思路(使用逻辑图最好)</h2><img src="${images}/concurrentHashMap之put原理流程.drawio.png" alt="concurrentHashMap之put原理流程.drawio" style="zoom: 25%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10. 原理总结思路细化：：：</span><br><span class="line">  1.concurrentHashMap没有粗暴的给整个数组加锁 原因是很明显这样线程安全，效率极低。</span><br><span class="line">  2.如果给数组的每个头节点 枷锁 这样并发度就是16 ，提高16倍速，这样数组有多长 并发度就有多少，提高了并发度。</span><br><span class="line">  3.举例 例如现在做一个 加加操作 ，多线程操作一个变量 a，如果给整个变量a 加上排他锁sychr 同意时间碎片只有一个thread，并发度又降下来，不合理。设计者 使用了轻量级的compare and swap方式,同一时间碎片，只有一个线程在操作变量a,其他线程不断在for(;;) 里面循环重试，这样虽然解决所开销的问题，但是效率还是不是很高， 于是设计者又考虑  可以咋失败时候可以新建一个数组counterCells[]  专门负责 失败时候值的 累加，</span><br><span class="line">  4.  put思路：：</span><br></pre></td></tr></table></figure>





<h2 id="concurrenthashmap-和hashMap的有啥区别"><a href="#concurrenthashmap-和hashMap的有啥区别" class="headerlink" title="concurrenthashmap 和hashMap的有啥区别?"></a>concurrenthashmap 和hashMap的有啥区别?</h2><p><img src="/$%7Bimages%7D/image-20250412100743466.png" alt="image-20250412100743466"></p>
<h3 id="细化比较一下-扩容机制的不同"><a href="#细化比较一下-扩容机制的不同" class="headerlink" title="细化比较一下 扩容机制的不同"></a>细化比较一下 扩容机制的不同</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用多线程协同扩容：具体是 从后向前 每个线程负责一段程度，</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码就是 计算扩容 每个线程 负责扩容的片段</span></span><br><span class="line">    <span class="comment">// 当前服务器cpu的  可用的核心线程数</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<h2 id="ConcurrentHashMap选代器是强一致性还是弱一致性？"><a href="#ConcurrentHashMap选代器是强一致性还是弱一致性？" class="headerlink" title="ConcurrentHashMap选代器是强一致性还是弱一致性？"></a>ConcurrentHashMap选代器是强一致性还是弱一致性？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">与HashMap选代器是强一致性不同，ConcurrentHashMap选代器是弱一致性。</span><br><span class="line">ConcurrentHashMap的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</span><br><span class="line">这样送代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。</span><br></pre></td></tr></table></figure>

<h2 id="为什么ConcurrentHashMap不充许null值？"><a href="#为什么ConcurrentHashMap不充许null值？" class="headerlink" title="为什么ConcurrentHashMap不充许null值？"></a>为什么ConcurrentHashMap不充许null值？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·主要是为了让ConcurrentHashMap的语义更加准确。</span><br><span class="line">。假如ConcurrentHashMap支持null，那么get方法就会返回null值。那么就会存在一个不确定性，到底这个null是put进去的还是没有找到该key而返回的null呢？</span><br><span class="line">在非并发环境下，这个问题可以通过contains方法来排除。但是，在并发环境下，contains方法执行过程中可能会被其他线程修改而导致结果不准确。</span><br><span class="line">·所以，为了不存在二义性，并发的Map框架一般都是不允许null的。</span><br></pre></td></tr></table></figure>







<h1 id="和-对比"><a href="#和-对比" class="headerlink" title="#和$  对比"></a>#和$  对比</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&#125;是预编译处理、是占位符， $&#123;&#125;是字符串替换、是拼接符。 </span><br><span class="line">Mybatis在处理#&#123;&#125;时，会将sql中的#&#123;&#125;替换为?号，调⽤ PreparedStatement 来赋值； </span><br><span class="line">Mybatis在处理$&#123;&#125;时，会将sql中的$&#123;&#125;替换成变量的值，调⽤ Statement 来赋值； </span><br><span class="line">使⽤#&#123;&#125;可以有效的防⽌ SQL 注⼊， 提⾼系统安全性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据库  https://www.yuque.com/tulingzhouyu/db22bv/dramscudnm47xh5s    ---ztts</span><br></pre></td></tr></table></figure>





<h1 id="常见集合对比-以及数据结构-，-hashMap-LinkedHashMap区别，"><a href="#常见集合对比-以及数据结构-，-hashMap-LinkedHashMap区别，" class="headerlink" title="常见集合对比   以及数据结构  ， hashMap  LinkedHashMap区别，"></a>常见集合对比   以及数据结构  ， hashMap  LinkedHashMap区别，</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">----ArrayList和LinkedList区别</span><br><span class="line"></span><br><span class="line">⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实</span><br><span class="line">现的 </span><br><span class="line">2. </span><br><span class="line">由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合</span><br><span class="line">删除和添加，查询、添加、删除的时间复杂度不同 </span><br><span class="line">3. </span><br><span class="line">另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以</span><br><span class="line">LinkedList还可以当做队列来使⽤ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----HashMap和ArrayList关系对比</span><br><span class="line"></span><br><span class="line">都是线程不安全，不同步</span><br><span class="line"></span><br><span class="line">    2）都可以储存null值</span><br><span class="line"></span><br><span class="line">    3）获取元素个数方法一样，都用size()方法获取</span><br><span class="line">    </span><br><span class="line">    ---其他List  </span><br><span class="line">    CopyOnWriteArrayList 适用于读多写少的并发场景，比如白名单，黑名单等场景</span><br><span class="line">    </span><br></pre></td></tr></table></figure>





<h1 id="stream-和-foreach-对比-性能-，肯定是stream更好"><a href="#stream-和-foreach-对比-性能-，肯定是stream更好" class="headerlink" title="stream 和 foreach  对比 性能 ，肯定是stream更好"></a>stream 和 foreach  对比 性能 ，肯定是stream更好</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从性能角度来看，for循环通常更快一些。这是因为for循环是Java编译器在编译时就可以确定的，而Stream API中的stream()和forEach()方法则需要运行时动态地创建流，这会增加一些额外的开销。</span><br><span class="line">在功能方面，Stream API提供了丰富的操作符，可以方便地对集合进行过滤、映射、排序等操作</span><br><span class="line"></span><br><span class="line">如果数据在1万以内的话，for循环效率高于foreach和stream；</span><br><span class="line">如果数据量在10万的时候，stream效率最高，其次是foreach,最后是for。</span><br><span class="line">另外需要注意的是如果数据达到100万的话，parallelStream异步并行处理效率最高，高于foreach和for</span><br></pre></td></tr></table></figure>





<h1 id="forkJoin的原理以及使用方法-Java-并发编程-——-Fork-Join-框架的原理详解-forkjoin框架原理-CSDN博客"><a href="#forkJoin的原理以及使用方法-Java-并发编程-——-Fork-Join-框架的原理详解-forkjoin框架原理-CSDN博客" class="headerlink" title="forkJoin的原理以及使用方法 Java 并发编程 —— Fork&#x2F;Join 框架的原理详解_forkjoin框架原理-CSDN博客"></a>forkJoin的原理以及使用方法 <a target="_blank" rel="noopener" href="https://blog.csdn.net/mrluo735/article/details/135083092">Java 并发编程 —— Fork&#x2F;Join 框架的原理详解_forkjoin框架原理-CSDN博客</a></h1><p><img src="/$%7Bimages%7D/image-20250505161916657.png" alt="image-20250505161916657"></p>
<img src="${images}/image-20250422203655029.png" alt="image-20250422203655029" style="zoom:67%;" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">ForkJoinTask  类封装了 数据结构</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">代码位置 测试位置    D:\Location\<span class="number">2024</span>常用的工具类收集\流stream\streamDemo\src\main\java\palaStream</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h1 id="jdk8新增的注解-sun-misc-Contended"><a href="#jdk8新增的注解-sun-misc-Contended" class="headerlink" title="jdk8新增的注解 @sun.misc.Contended"></a>jdk8新增的注解 @sun.misc.Contended</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@sun.misc.Contended 是 Java 8 新增的一个注解，对某字段加上该注解则表示该字段会单独占用一个缓存行（Cache Line）。</span><br><span class="line">单独使用一个缓存行有什么作用——避免伪共享</span><br><span class="line">https://www.cnblogs.com/eycuii/p/11525164.html</span><br></pre></td></tr></table></figure>



<h1 id="了解并发-并行"><a href="#了解并发-并行" class="headerlink" title="了解并发 并行"></a>了解并发 并行</h1><p>  <img src="/$%7Bimages%7D/image-20240710172712752.png" alt="image-20240710172712752"></p>
<p><img src="/$%7Bimages%7D/image-20240805150522195.png" alt="image-20240805150522195"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发三大特性</span><br><span class="line">并发编程Bug的源头：可见性、原子性和有序性问题</span><br><span class="line">volitile  和sync都是 从C语言层面的  通过内存屏障  load store 角度来  ，都可以实现可见性,  volitile不能保证原子性</span><br><span class="line">细节讲述  sync  如何保证 可见性 https:<span class="comment">//blog.csdn.net/chenzengnian123/article/details/122686371</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="什么是指令重排序，load-store"><a href="#什么是指令重排序，load-store" class="headerlink" title="什么是指令重排序，load store"></a>什么是指令重排序，load store</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>-Java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与它顺序化情况</span><br><span class="line">的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</span><br><span class="line">指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机</span><br><span class="line">器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</span><br><span class="line">在编译器与CPU处理器中都能执行指令重排优化操</span><br><span class="line">    </span><br><span class="line"><span class="number">01</span>--同样的道理啊，也是通过monitorenter、monitorexit指令嵌入上面的内存屏障；monitorenter、monitorexit这两条指令其实就相当于复合指令，既具有加锁、释放锁的功能，同时也具有内存屏障的功能。</span><br></pre></td></tr></table></figure>



<h1 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>关键字要点</span><br><span class="line"><span class="number">1.</span>不能对<span class="keyword">final</span>变量再次赋值.</span><br><span class="line"><span class="number">3.</span><span class="keyword">final</span>关键字可以用于局部变量，成员变量、方法以及类.</span><br><span class="line"><span class="number">12.</span>按照Java代码惯例,<span class="keyword">final</span>变量就是常量, 而且通常常量名要大写</span><br><span class="line"><span class="number">13.</span>对于集合对象声明为<span class="keyword">final</span>指的是引用（地址）不能被更改, 但可以向其中增加, 删除或者改变内容.</span><br><span class="line"><span class="number">1.</span>方法前面加上<span class="keyword">final</span>关键字,代表这个方法不可以被子类的方法重写.</span><br><span class="line"><span class="number">2.</span>类名 <span class="keyword">final</span> <span class="keyword">class</span>  <span class="title class_">C</span> ,前面加上<span class="keyword">final</span>关键字,代表这个方法不可以被继承 </span><br><span class="line">    --<span class="number">00</span> 在使用<span class="keyword">final</span>修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为<span class="keyword">final</span>类。--.</span><br><span class="line"><span class="number">10.</span>没有在声明时初始化<span class="keyword">final</span>变量的称为空白<span class="keyword">final</span>变量(blank <span class="keyword">final</span> variable), 必须在构造器中初始化, 或者调用<span class="built_in">this</span>()初始化. 否则编译器会报错.</span><br><span class="line"><span class="number">8.</span>  jdk7  接口中声明的所有变量本身是<span class="keyword">final</span>的（可以不记忆）.</span><br><span class="line"><span class="number">9.</span><span class="keyword">final</span>方法在编译阶段绑定, 称为静态绑定(<span class="keyword">static</span> binding).  </span><br><span class="line"><span class="number">11.</span>将类、方法、变量声明为<span class="keyword">final</span>能够提高性能, 这样JVM就有机会进行估计,然后优化.</span><br></pre></td></tr></table></figure>

<h1 id="接口和抽象类区别"><a href="#接口和抽象类区别" class="headerlink" title="接口和抽象类区别"></a>接口和抽象类区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">实际就是说  01 继承和多态  </span><br><span class="line"></span><br><span class="line">抽象类 是</span><br><span class="line">----</span><br><span class="line">抽象类和抽象方法都必须用abstract修饰符来修饰，抽象方法不能有方法体</span><br><span class="line">2、抽象类有构造器，但不能直接被实例化，要创建对象涉及向上转型，主要是用于被其子类调用</span><br><span class="line">3、抽象类中可以没有抽象方法，但是有抽象方法的类必定是抽象类</span><br><span class="line">4、抽象类中可以包含静态方法</span><br><span class="line">5、抽象类不能用final修饰</span><br><span class="line">6、抽象类不能用private修饰</span><br><span class="line">7、抽象类也是类，一样是用来继承的，接口与类才是实现关系</span><br><span class="line">8、外部抽象类不能用Static修饰，但内部的抽象类可以使用static声明</span><br><span class="line">9、 抽象类可以继承抽象类，抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体非抽象派生类必须覆盖它们</span><br><span class="line">10、 抽象类可以实现接口，可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_44543508/article/details/102609910</span><br></pre></td></tr></table></figure>



<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。</span><br><span class="line"></span><br><span class="line">这里要强调一下：</span><br><span class="line"></span><br><span class="line">static修饰的成员变量和方法，从属于类</span><br><span class="line"></span><br><span class="line">普通变量和方法从属于对象</span><br><span class="line"></span><br><span class="line">静态方法不能调用非静态成员，编译会报错</span><br></pre></td></tr></table></figure>



<h1 id="线程-ThreadLOCAL-常用的线程接口类熟悉-线程队列的使用"><a href="#线程-ThreadLOCAL-常用的线程接口类熟悉-线程队列的使用" class="headerlink" title="线程  ThreadLOCAL   常用的线程接口类熟悉  线程队列的使用"></a>线程  ThreadLOCAL   常用的线程接口类熟悉  线程队列的使用</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102744180">ThreadLocal，一篇文章就够了 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN2497242041/article/details/120192343">https://blog.csdn.net/CSDN2497242041/article/details/120192343</a></p>
<p><img src="/$%7Bimages%7D/image-20250505173757051.png" alt="类 结构"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">使用场景：：</span><br><span class="line"><span class="number">1</span>、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</span><br><span class="line"><span class="number">2</span>、线程间数据隔离</span><br><span class="line"><span class="number">3</span>、进行事务操作，用于存储线程事务信息。</span><br><span class="line"><span class="number">4</span>、数据库连接，Session会话管理。</span><br><span class="line">    -------</span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//通过我们重写initialValue方法获取初始值</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">         <span class="comment">//获取到当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">         <span class="comment">//通过getMap方法，传入当前线程作为参数去获取ThreadLocalMap对象</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">         <span class="comment">//如果获取到的ThreadLocalMap不为空，就直接存入，否则就创建ThreadLocalMap并存入。</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//key为threadLocal本身，value就是我们业务上需要存储的值</span></span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//获取ThreadLocalMap对象</span></span><br><span class="line">  ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="comment">//重点！！！</span></span><br><span class="line">        <span class="comment">//这里返回的其实就是最上面讲到的每个Thread都会有一个ThreadLocalMap成员变量</span></span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">                        </span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/CSDN2497242041/article/details/120192343</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="comment">//首先获取当前线程对象  （    public static native Thread currentThread();）</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取线程中变量 ThreadLocal.ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">//如果不为空，</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);<span class="comment">// ben01</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果为空，初始化该线程对象的map变量，其中key 为当前的threadlocal 变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ben01      ThreadLocal  ,  Connection数据库</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//初始化线程内部变量 threadLocals ，key 为当前 threadlocal</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment">         * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment">         * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Entry[]  类型数组  key是threadLcoal   Connection数据库</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240417180341915.png" alt="image-20240417180341915"></p>
<p><font  color="red">ThreadLocal会导致内存泄漏问题  ，原因：：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal，线程本地变量，顾名思义，它是每个线程私有的本地变量。通俗点讲，当你创建了一个ThreadLocal变量，每个线程在访问该变量时，都会拷贝一个副本至本地内存，所以多线程下操作ThreadLocal变量时，其实各自都是在操作自己拷贝的副本，互不影响，这样自然而然就避免了线程安全问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">「记住在使用的以后，一定要remove,一定要remove,一定要remove」为什么要remove。因为ThreadLocal会导致内存泄漏问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开启两个线程去操作ThreadLocal变量，从控制台的输出结果，便可以证明我们上面说的定义，每个线程对threadLocal变量的访问与操作互不影响，做到了线程隔离。</span><br><span class="line"></span><br><span class="line">每个线程中都有一个 ThreadLocalMap数据结构，当执行set方法时，其值是保存在当前线程的 threadLocals变量中，当执行get方法中，是从当前线程的 threadLocals变量获取。 (ThreadLocalMap的key值是ThreadLocal类型)</span><br><span class="line"></span><br><span class="line">ThreadLocalMap对象里维护了一个K-V格式的Entry数组，Key存的是ThreadLocal对象本身，value是需要存储的值。当我们要操作ThreadLocal变量时，会先获取当前的线程，根据当前线程拿到对应的ThreadLocalMap对象，进而操作ThreadLocalMap内部数组里存储的数据。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/CSDN2497242041/article/details/120192343,</span><br><span class="line"></span><br><span class="line">judgment  make decide</span><br><span class="line"></span><br><span class="line">因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</span><br></pre></td></tr></table></figure>



<h2 id="内存泄露的原因"><a href="#内存泄露的原因" class="headerlink" title="内存泄露的原因"></a>内存泄露的原因</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java对象的引用包括 ： 强引用，软引用，弱引用，虚引用 。弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，该对象如果被弱引用关联，那么就会被回收。</span><br><span class="line">当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收的。ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 存在内存泄露的风险</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/CSDN2497242041/article/details/120192343</span><br></pre></td></tr></table></figure>







<h1 id="jdbc-执行过程-6个过程-涉及-（-jdbc就是一套接口规范-）"><a href="#jdbc-执行过程-6个过程-涉及-（-jdbc就是一套接口规范-）" class="headerlink" title="jdbc 执行过程  6个过程 涉及 （  jdbc就是一套接口规范 ）"></a>jdbc 执行过程  6个过程 涉及 （  jdbc就是一套接口规范 ）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 三、JDBC的基本执行流程</span><br><span class="line">1加载数据库驱动程序：通过反射的方式加载驱动包，现在基本无需手动添加驱动包了。</span><br><span class="line"></span><br><span class="line">2建立数据库连接：使用DriverManager.getConnection()方法创建与数据库的连接，需要提供数据库的URL、用户名和密码。</span><br><span class="line"></span><br><span class="line">3创建Statement对象：使用connection.createStatement()方法创建一个Statement对象，用于执行SQL语句。</span><br><span class="line"></span><br><span class="line">4执行SQL语句：使用Statement对象的executeQuery()方法执行查询语句，或者使用executeUpdate()方法执行更新语句。</span><br><span class="line"></span><br><span class="line">5处理结果集：如果执行的是查询语句，可以使用ResultSet对象来处理查询结果。</span><br><span class="line"></span><br><span class="line">6 关闭连接：使用connection.close()方法关闭数据库连接，释放资源</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_72172339/article/details/131847398</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_72172339/article/details/131847398</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">01  利用反射创建数据库连接</span><br></pre></td></tr></table></figure>

<h1 id="死锁出现情况-解决办法（破坏死锁成立条件的四个其中一个—来自-抖音检索-mic）"><a href="#死锁出现情况-解决办法（破坏死锁成立条件的四个其中一个—来自-抖音检索-mic）" class="headerlink" title="死锁出现情况  解决办法（破坏死锁成立条件的四个其中一个—来自 抖音检索  mic）"></a>死锁出现情况  解决办法（破坏死锁成立条件的四个其中一个—来自 抖音检索  mic）</h1><img src="${images}/image-20240711140337640.png" alt="image-20240711140337640" style="zoom:8%;" />







<img src="${images}/image-20240711140415942.png" alt="image-20240711140415942" style="zoom:10%;" />



<h1 id="如何优雅的终止线程-–存在一种一种线程中断机制-3个对比（线程并发的知识点）"><a href="#如何优雅的终止线程-–存在一种一种线程中断机制-3个对比（线程并发的知识点）" class="headerlink" title="如何优雅的终止线程  –存在一种一种线程中断机制   3个对比（线程并发的知识点）"></a>如何优雅的终止线程  –存在一种一种线程中断机制   3个对比（线程并发的知识点）</h1><p><img src="/$%7Bimages%7D/image-20230602215952873.png" alt="image-20230602215952873"></p>
<p><img src="/$%7Bimages%7D/image-20240805195931149.png" alt="image-20240805195931149"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">如何优雅的停止一个线程</span><br><span class="line">我们知道线程只有从 runnable 状态（可运行/运行状态） 才能进入terminated 状态（终止状态），如果线程处于 blocked、waiting、timed_waiting 状态（休眠状态），就需要通过 Thread 类的 interrupt() 方法，让线程从休眠状态进入 runnable 状态，从而结束线程。</span><br><span class="line"></span><br><span class="line">这里就涉及到了一个概念“线程中断”，这是一种协作机制，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的时机中断请求，也可以完全不处理继续执行下去，这样一来，安全性就得到了保障。</span><br><span class="line"></span><br><span class="line">Thread类中提供线程中断的方法如下：</span><br><span class="line"></span><br><span class="line">Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为 true（默认是 flase）；</span><br><span class="line">Thread.currentThread().isInterrupted()：测试当前线程是否被中断。线程的中断状态会受这个方法的影响，调用一次可以使线程中断状态变为 true，调用两次会使这个线程的中断状态重新转为 false；</span><br><span class="line">Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_43506040/article/details/136661151</span><br></pre></td></tr></table></figure>



<h1 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h1><p>   b: 事务的基本属性包括：{事务属性包含了几个方面：传播行为、隔离规则、回滚规则、事务超时、是否只读；}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、原子性（Atomicity）：事务开始后所有操作，要么全部完成，要么全部不完成，不可能停滞在中间环节。事务执行过程中出错，会回滚（Rollback）到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位</span><br><span class="line">2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到，统一性，一件事情的合理性，</span><br><span class="line">3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账</span><br><span class="line">4、持久性（Durability）：事务完成后，该事务所对数据库所作的更改将被保存到数据库之中，不能回滚</span><br><span class="line"></span><br><span class="line">Mysql怎么保证原子性的？OK，是利用Innodb的undo log。</span><br><span class="line">undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="不可修改的-对象"><a href="#不可修改的-对象" class="headerlink" title="不可修改的 对象"></a>不可修改的 对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 String   </span><br><span class="line">2 bigDecimal</span><br></pre></td></tr></table></figure>

<h1 id="内核态和用户态区别"><a href="#内核态和用户态区别" class="headerlink" title="内核态和用户态区别"></a>内核态和用户态区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/gizing/p/10925286.html</span><br><span class="line">有必要说一下 C P U 指令集，指令集是 C P U 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 C P U 指令，而非常非常多的 C P U 指令 在一起，可以组成一个、甚至多个集合，指令的集合叫 C P U 指令集。</span><br><span class="line"></span><br><span class="line">同时 C P U 指令集 有权限分级，大家试想，C P U 指令集 可以直接操作硬件的，要是因为指令操作的不规范`，造成的错误会影响整个计算机系统的</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">内核态（Kernel Mode）：运行操作系统程序，操作硬件</span><br><span class="line"></span><br><span class="line">用户态（User Mode）：运行用户程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">3.特权级别</span><br><span class="line">特权环：R0、R1、R2和R3</span><br><span class="line"></span><br><span class="line">R0相当于内核态，R3相当于用户态；</span><br><span class="line"></span><br><span class="line">不同级别能够运行不同的指令集合；</span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">用户态与内核态</span><br><span class="line">通关了C P U 指令集权限，现在再说用户态与内核态就十分简单了，用户态与内核态的概念就是C P U 指令集权限的区别，进程中要读写    I/O，必然会用到 ring 0 级别的 C P U 指令集，而此时 C P U 的指令集操作权限只有 ring 3，为了可以操作ring 0 级别的 C P U 指令集， C P U 切换指令集操作权限级别为 ring 0，C P U再执行相应的ring 0 级别的 C P U 指令集（内核代码），执行的内核代码会使用当前进程的内核栈。</span><br><span class="line"></span><br><span class="line">PS：每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">最后做个小结，我们通过指令集权限区分用户态和内核态，还限制了内存资源的使用，操作系统为用户态与内核态划分了两块内存空间，给它们对应的指令集使用</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">01  处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。</span><br></pre></td></tr></table></figure>



<h1 id="线程模型三种（选择多对多）和线程状态"><a href="#线程模型三种（选择多对多）和线程状态" class="headerlink" title="线程模型三种（选择多对多）和线程状态"></a>线程模型三种（选择多对多）和线程状态</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lihaidong1991/article/details/88861123">三种线程模型_多线程模型有哪几种类型?多对一模型有何优缺点?-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态  runnable 就绪</span><br><span class="line">   running </span><br><span class="line">   minitor 监控(blocked)</span><br><span class="line">   dead</span><br><span class="line">   </span><br><span class="line">   notifyAll()  释放当前线程的锁，当前线程进入wait</span><br></pre></td></tr></table></figure>



<h1 id="放重复提交方案"><a href="#放重复提交方案" class="headerlink" title="放重复提交方案"></a>放重复提交方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/xxxxg_xg/article/details/136656789</span><br><span class="line">LRUMap</span><br></pre></td></tr></table></figure>



<h1 id="数据库连接池爆满解决方案"><a href="#数据库连接池爆满解决方案" class="headerlink" title="数据库连接池爆满解决方案"></a>数据库连接池爆满解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先排查问题</span><br><span class="line">1  看日志  ，数据库监控面板和工具， 普罗米修斯， </span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/weixin_40482816/article/details/116599618</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xuezhangjun0121/article/details/105440901">show full processlist；命令详解 - MySQL_show full processlist;-CSDN博客</a></p>
<h1 id="现场过多日志提示啥错误"><a href="#现场过多日志提示啥错误" class="headerlink" title="现场过多日志提示啥错误"></a>现场过多日志提示啥错误</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OutOfMemoryError</span><br><span class="line"></span><br><span class="line">在Java编程中，多线程是一种重要的编程方式，可以充分利用多核处理器的优势，提高程序的并发性和性能。然而，如果线程数过多，就会出现一系列的问题，甚至导致程序崩溃</span><br><span class="line"></span><br><span class="line">原因分析：：</span><br><span class="line"></span><br><span class="line">01  线程也是对象 ，当创建过多的线程时，会导致JVM的内存资源耗尽。当线程被创建时，JVM会为每个线程分配一块堆栈内存，用于保存线程的执行上下文。如果线程数过多，JVM的堆栈内存将会被耗尽，引发“OutOfMemoryError”异常。</span><br><span class="line"></span><br><span class="line">02 除了内存资源外，线程数过多还会占用其他系统资源，如CPU、I/O等。当线程数过多时，这些系统资源会被过度占用，导致系统性能下降，甚至造成系统崩溃。</span><br><span class="line"></span><br><span class="line">解决方案：通过合理设置线程数，避免过度占用系统资源，并且可以使用线程池来限制线程数。</span><br></pre></td></tr></table></figure>



<h1 id="数据库连接池和redis连接池-对比学习"><a href="#数据库连接池和redis连接池-对比学习" class="headerlink" title="数据库连接池和redis连接池 对比学习"></a>数据库连接池和redis连接池 对比学习</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis  为每次数据交互都需要先建立连接，假设一次数据交互总共用时30ms，超高性能的Redis数据库处理数据所花的时间可能不到1ms，也即是说前期的连接占用了29ms，连接池则可以实现在客户端建立多个链接并且不释放，当需要使用连接的时候通过一定的算法获取已经建立的连接，使用完了以后则还给连接池，这就免去了数据库连接所占用的时间</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="mybaits优点以及动态sql实现"><a href="#mybaits优点以及动态sql实现" class="headerlink" title="mybaits优点以及动态sql实现"></a>mybaits优点以及动态sql实现</h1><img src="${images}/1218593-20240426100039088-2002035695.png" alt="img" style="zoom:50%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Black_Customer/article/details/107403819">【mybatis】mybatis的特性和优势_mybatis的特性及优点-CSDN博客</a></p>
<h1 id="spring-bean是线程安全吗"><a href="#spring-bean是线程安全吗" class="headerlink" title="spring  bean是线程安全吗"></a>spring  bean是线程安全吗</h1><img src="${images}/spring_bean线程安全.jpg" alt="spring_bean线程安全" style="zoom:15%;" />

<h1 id="springboot-三个大注解-之一-EnableAutoConfiguration-工作原理-（涉及自动装配）"><a href="#springboot-三个大注解-之一-EnableAutoConfiguration-工作原理-（涉及自动装配）" class="headerlink" title="springboot 三个大注解    之一  @EnableAutoConfiguration  工作原理  （涉及自动装配）"></a>springboot 三个大注解    之一  @EnableAutoConfiguration  工作原理  <font  color="red">（涉及自动装配）</font></h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Spring Boot自动装配原理(易懂)_springboot自动装配原理-CSDN博客](https://blog.csdn.net/qq_41805567/article/details/129111183)</span><br><span class="line"></span><br><span class="line">[深入理解Spring Boot Starter：概念、特点、场景、原理及自定义starter-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2398558)</span><br><span class="line"></span><br><span class="line">[深入理解 Spring Boot Starters 原理（手写Spring boot Start）_springboot started-CSDN博客](https://blog.csdn.net/zhaohong_bo/article/details/89924053)---自定义  starter启动自动配置</span><br></pre></td></tr></table></figure>



<img src="${images}/image-20240806115005019.png" alt="image-20240806115005019" style="zoom:67%;" />

<p><img src="/$%7Bimages%7D/image-20240806115339948.png" alt="image-20240806115339948"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主动扫描 maven 引入的jar是标记<span class="number">1</span> 出的引入的  注解</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SpringFactoriesLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The location to look for factories.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Can be present in multiple JAR files.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="Spring-Boot如何实现配置文件的自动加载和刷新？"><a href="#Spring-Boot如何实现配置文件的自动加载和刷新？" class="headerlink" title="Spring Boot如何实现配置文件的自动加载和刷新？"></a>Spring Boot如何实现配置文件的自动加载和刷新？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">试用注解@Value</span><br><span class="line"></span><br><span class="line">直接通过@Value注解，将一个对象得成员变量与Environment中的配置进行绑定</span><br></pre></td></tr></table></figure>







<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p><img src="/$%7Bimages%7D/image-20250311180721292.png" alt="image-20250311180721292"></p>
<h1 id="spring-依赖注入-Resource和autowire区别"><a href="#spring-依赖注入-Resource和autowire区别" class="headerlink" title="spring   依赖注入  Resource和autowire区别"></a>spring   依赖注入  Resource和autowire区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，</span><br><span class="line"></span><br><span class="line">2、不同点</span><br><span class="line"></span><br><span class="line">（1）@Autowired--framework</span><br><span class="line"></span><br><span class="line">@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</span><br><span class="line"></span><br><span class="line">@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。(通过类型匹配找到多个candidate,在没有@Qualifier、@Primary注解的情况下，会使用对象名作为最后的fallback匹配)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（2）@Resource</span><br><span class="line">@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。</span><br><span class="line">所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。</span><br><span class="line">如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h1 id="spring三级缓存-循环依赖"><a href="#spring三级缓存-循环依赖" class="headerlink" title="spring三级缓存 循环依赖"></a>spring三级缓存 循环依赖</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">三级缓存有什么区别?</span><br><span class="line">一级缓存</span><br><span class="line">一级缓存里存的是成品对象，实例化和初始化都完成了，我们的应用中使用的对象就是一级缓存中的</span><br><span class="line"></span><br><span class="line">二级缓存</span><br><span class="line">二级缓存中存的是半成品，没有完成属性注入和初始化，用来解决对象创建过程中的循环依赖问题</span><br><span class="line">早期暴露出去的Bean，其实也就是解决循环依赖的Bean。早期的意思就是没有完完全全创建好，但是由于有循环依赖，就需要把这种Bean提前暴露出去。其实 早期暴露出去的Bean 跟 完完全全创建好的Bean 他们是同一个对象，只不过早期Bean里面的注解可能还没处理，完完全全的Bean已经处理了完了，但是他们指的还是同一个对象，只不过它们是在Bean创建过程中处于的不同状态</span><br><span class="line"></span><br><span class="line">三级缓存</span><br><span class="line">三级缓存中存的是 ObjectFactory&lt;?&gt; 类型的代理工厂对象，用于处理存在 AOP 时的循环依赖问题</span><br><span class="line">存的是每个Bean对应的ObjectFactory对象，通过调用这个对象的getObject方法，就可以获取到早期暴露出去的Bean。</span><br><span class="line">注意：这里有个很重要的细节就是三级缓存只会对==单例的Bean生效==，像多例的是无法利用到三级缓存的，通过三级缓存所在的类名DefaultSingletonBeanRegistry就可以看出，仅仅是对SingletonBean也就是单例Bean有效果。、</span><br><span class="line">&#123; == 在这个过程中，Spring采用了单例模式，确保每个Bean只会被创建一次。 然而，单例模式在处理循环依赖时可能会遇到问题，因为Bean在初始化过程中可能还需要其他未完全初始化的Bean。==&#125;</span><br></pre></td></tr></table></figure>

<h1 id="spring事务-注解（事务的aop和代理对象的实现逻辑）"><a href="#spring事务-注解（事务的aop和代理对象的实现逻辑）" class="headerlink" title="spring事务   注解（事务的aop和代理对象的实现逻辑）"></a>spring事务   注解（事务的aop和代理对象的实现逻辑）</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91779567">手把手带你实战下Spring的七种事务传播行为 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/happydecai/article/details/80338053">Spring事务的传播：PROPAGATION_REQUIRED_propagation.required-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/abc19900828/article/details/39497631">Spring事务管理只对出现运行期异常进行回滚_只有运行时异常才能回滚-CSDN博客</a></p>
<p><img src="/2025/03/02/hello-world/intervwSummary/image-20240712111316519.png" alt="image-20240712111316519"></p>
<p><img src="/$%7Bimages%7D/image-20240712111316519.png" alt="image-20240712111316519"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-----  7种事务的传播机制 记忆使用表格方式更好。</span><br><span class="line">TransactionInterceptor就是代理逻辑，当某个类中存在@Transactional注解时，到时就产生一个代理对象作为Bean，代理对象在执行某个方法时，最终就会进入到TransactionInterceptor的invoke()方法。</span><br><span class="line"></span><br><span class="line">1. 利用所配置的PlatformTransactionManager事务管理器新建一个数据库连接</span><br><span class="line">2. 修改数据库连接的autocommit为false</span><br><span class="line">3. 执行MethodInvocation.proceed()方法，简单理解就是执行业务方法，其中就会执行sql</span><br><span class="line">4. 如果没有抛异常，则提交</span><br><span class="line">5. 如果抛了异常，则回滚</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----关于  抛异常回滚细化</span><br><span class="line"></span><br><span class="line">使用spring难免要用到spring的事务管理，要用事务管理又会很自然的选择声明式的事务管理，在spring的文档中说道，spring声明式事务管理默认对非检查型异常和运行时异常进行事务回滚，而对检查型异常则不进行回滚操作。</span><br><span class="line">那么什么是检查型异常什么又是非检查型异常呢？</span><br><span class="line">最简单的判断点有两个：</span><br><span class="line">1.继承自runtimeexception或error的是非检查型异常，而继承自exception的则是检查型异常（当然，runtimeexception本身也是exception的子类）。</span><br><span class="line">2.对非检查型类异常可以不用捕获，而检查型异常则必须用try语句块进行处理或者把异常交给上级方法处理总之就是必须写代码处理它。所以必须在service捕获异常，然后再次抛出，这样事务方才起效。</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line"></span><br><span class="line">在spring的事务管理环境下，使用unckecked exception可以极大地简化异常的处理，只需要在事务层声明可能抛出的异常（这里的异常可以是自定义的unckecked exception体系），在所有的中间层都只是需要简单throws即可，不需要捕捉和处理，直接到最高层，比如UI层再进行异常的捕捉和处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----事务嵌套概念</span><br><span class="line">事务的嵌套概念</span><br><span class="line">所谓事务的嵌套就是两个事务方法之间相互调用。spring事务开启 ，或者是基于接口的或者是基于类的代理被创建（ 注意一定要是代理，不能手动new 一个对象，并且此类（有无接口都行）一定要被代理——spring中的bean只要纳入了IOC管理都是被代理的 ）。所以在同一个类中一个方法调用另一个方法有事务的方法，事务是不会起作用的。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/happydecai/article/details/80338053</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="spring-如何操作数据库事务的源码"><a href="#spring-如何操作数据库事务的源码" class="headerlink" title="spring 如何操作数据库事务的源码"></a>spring 如何操作数据库事务的源码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">PlatformTransactionManager</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行原始方法之前的操作，即获取connection，设置threadlocal，开启事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">        <span class="comment">//模板方法1</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache debug flag to avoid repeated checks.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (definition == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">            definition = <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模板方法2，判断是否已存在事务，有事务注解的方法调其他有事务注解方法时会走这</span></span><br><span class="line">        <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">            <span class="comment">//有存在的事务时，根据事务传播行为区别处理</span></span><br><span class="line">            <span class="comment">//1.传播行为是PROPAGATION_NEVER，表示不使用当前事务，抛出异常</span></span><br><span class="line">            <span class="comment">//2.如果是PROPAGATION_NOT_SUPPORTED，表示不支持当前事务，而是始终以非事务方式执行，和最下面else逻辑一样</span></span><br><span class="line">            <span class="comment">//3.如果是PROPAGATION_REQUIRES_NEW，表示新建事务，和下面创建新事务逻辑一样</span></span><br><span class="line">            <span class="comment">//4.如果是PROPAGATION_NESTED，表示如果当前事务存在，则在嵌套事务中执行，否则和PROPAGATION_REQUIRED逻辑一样（和下面创建新事务逻辑一样）</span></span><br><span class="line">            <span class="comment">//5.如果注入validateExistingTransaction为true，比较definition的隔离等级，ReadOnly和TransactionSynchronizationManager中的对应配置比较，抛出异常</span></span><br><span class="line">            <span class="comment">//6.和最下面else逻辑一样</span></span><br><span class="line">            <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对事务注解属性值做一些判断</span></span><br><span class="line">        <span class="comment">//超时设置为&lt;0会报错</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, definition.getTimeout());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有存在的事务时，根据事务传播行为区别处理</span></span><br><span class="line">        <span class="comment">//1.PROPAGATION_MANDATORY会使用当前事务，所以报错</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">                    <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面三种都会创建新事务,事务注解默认是PROPAGATION_REQUIRED</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">                definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">                definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">            <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]: &quot;</span> + definition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//拿注入的transactionSynchronization属性比较，默认不等于SYNCHRONIZATION_NEVER</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">                <span class="comment">//创建新的</span></span><br><span class="line">                <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">                        definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">                <span class="comment">//模板方法，重点！！！        </span></span><br><span class="line">                doBegin(transaction, definition);</span><br><span class="line">                <span class="comment">//设置threadlocal相关</span></span><br><span class="line">                prepareSynchronization(status, definition);</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">                resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实际没有开启事务，但是同步了一些配置到线程</span></span><br><span class="line">            <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + definition);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//默认是</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">            <span class="comment">//先newTransactionStatus，再prepareSynchronization，没有doBegin方法</span></span><br><span class="line">            <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>#事务隔离级别</p>
<p>spring默认的隔离级别（可重复读）不能避免 幻读</p>
<p>幻读的INNODB解决办法  RR隔离级别+间隙锁</p>
<p><font color='red'>幻读的INNODB解决办法  RR隔离级别+Next-Key Lock  解决幻读</font></p>
<img src="${images}/image-20240712111316519.png" alt="image-20240712111316519" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">对于脏读、不可重复读和幻读的解释：</span><br><span class="line"></span><br><span class="line">脏读（Dirty Read）：指一个事务读取了另一个事务未提交的数据。如果一个事务可以读取未提交的数据，则会发生脏读。</span><br><span class="line"></span><br><span class="line">不可重复读（Non-repeatable Read）：指在同一个事务中，多次读取同一行数据时，得到的结果不一致。这是因为在读取期间，另一个事务修改了该行数据。</span><br><span class="line"></span><br><span class="line">幻读（Phantom Read）：指在同一个事务中，多次查询  同一个范围  的数据时，得到的结果集不一致。这是因为在查询期间，另一个事务插入或删除了符合查询条件的数据。---（ ）</span><br><span class="line"></span><br><span class="line">-----每个隔离级别对这些问题的解决情况如下：</span><br><span class="line"></span><br><span class="line">=====对于任何隔离级别，表级别的表锁、元数据锁、意向锁都是会使用的，但对于行级别的锁则会有些许差别</span><br><span class="line"></span><br><span class="line">读未提交（Read Uncommitted）：允许脏读、不可重复读和幻读。一个事务可以读取另一个事务未提交的数据。----（*****只会使用记录锁，不会用间隙锁***）</span><br><span class="line"></span><br><span class="line">读已提交（Read Committed）：避免脏读。一个事务只能读取已提交的数据。但是，可能发生不可重复读和幻读，因为在同一个事务中，另一个事务可能会修改数据。---（***使用行锁可以解决，在读取之前加上行锁，其他事务不能修改****）</span><br><span class="line">----（*****只会使用记录锁，不会用间隙锁***）</span><br><span class="line"></span><br><span class="line">可重复读（Repeatable Read）：避免脏读和不可重复读。在同一个事务中，多次读取同一行数据时，得到的结果是一致的。但是，可能发生幻读，因为在同一个事务中，另一个事务可能会插入或删除数据。（得到的结果是一致为V=5，可能删除再次插入5）-----(***会使用记录锁、间隙锁和 Next-Key 锁。****)</span><br><span class="line"></span><br><span class="line">串行化（Serializable）：避免脏读、不可重复读和幻读。事务串行执行，保证了数据的一致性和完整性。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/m0_60353039/article/details/131823737</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240711110723793.png" alt="image-20240711110723793"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 数据库隔离级别修改</span><br><span class="line"> </span><br><span class="line"> 01---- 查看当前session的自动提交状态  ,查询是否是自动提交</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">02---设置不要自动提交</span><br><span class="line">SET @@autocommit=0;</span><br><span class="line">03--可以使用如下语句来查询全局事务隔离级别global 和当前连接的事务隔离级别</span><br><span class="line">select @@global.tx_isolation,@@tx_isolation</span><br><span class="line"></span><br><span class="line"> SELECT @@tx_isolation;</span><br><span class="line"> SELECT @@session.tx_isolation;</span><br><span class="line"> SELECT @@global.tx_isolation;</span><br><span class="line">select @@tx_isolation; //查看当前session的隔离级别</span><br><span class="line"></span><br><span class="line">04-- 如果隔离级别不对可以 修改</span><br><span class="line">// 设置当前session的隔离级别为可重复读</span><br><span class="line"></span><br><span class="line">set @@global.tx_isolation = &#x27;READ-UNCOMMITTED&#x27;;      //全局</span><br><span class="line">set @@session.tx_isolation = &#x27;READ-UNCOMMITTED&#x27;;     //当前session</span><br><span class="line">set @@tx_isolation = &#x27;READ-UNCOMMITTED&#x27;;             //仅对下一个事务生效</span><br><span class="line"></span><br><span class="line">set tx_isolation=&#x27;repeatable-read&#x27;; </span><br><span class="line">set tx_isolation=&#x27;repeatable-read&#x27;; // 设置当前session的隔离级别为可重复读</span><br><span class="line"></span><br><span class="line">-- 查询发现都是 REPEATABLE-READ</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ABOOMMMMM/article/details/117754777">可重复读隔离级别如何解决脏读、不可重复读_可重复读怎么解决不可重复读-CSDN博客</a></p>
<p><img src="/$%7Bimages%7D/image-20240807105315479.png" alt="image-20240807105315479"></p>
<p><img src="/$%7Bimages%7D/image-20240807105340582.png" alt="image-20240807105340582"></p>
<h1 id="spring多线程事务为啥不能保证原子性"><a href="#spring多线程事务为啥不能保证原子性" class="headerlink" title=" spring多线程事务为啥不能保证原子性"></a><font style="bold"  color="coral"> spring多线程事务为啥不能保证原子性</font></h1><img src="${images}/多线程不能保证事务原子性.jpg" alt="多线程不能保证事务原子性" style="zoom:15%;" />

<p>2pc–3pc,</p>
<h1 id="springMVC-工作流程–直接看下面连接"><a href="#springMVC-工作流程–直接看下面连接" class="headerlink" title="springMVC 工作流程–直接看下面连接"></a>springMVC 工作流程–直接看下面连接</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_38760069/article/details/96479412">springMVC的主要组件有哪些？springMVC的工作流程？_sqring mvc的主要主件-CSDN博客</a></p>
<p><img src="/$%7Bimages%7D/image-20240806203728392.png" alt="image-20240806203728392"></p>
<p>#：  数据库的 行锁和列锁  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52678870">深入理解数据库行锁与表锁 - 知乎 (zhihu.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">INNoDB 表锁和行锁是该存储引擎中非常重要的锁机制</span><br><span class="line"></span><br><span class="line">表锁是一种互斥锁，用于控制对整个表的并发访问。</span><br><span class="line">而行锁则是一种共享锁，允许事务同时读取和更新表中的不同数据行。这两种锁类型在使用上有很大区别</span><br><span class="line"></span><br><span class="line">表锁在锁入门InnoDB存储引擎中有两种类型：读写锁和排他锁。</span><br><span class="line">读写锁允许一个事务读取表中的数据，同时允许其他事务并发地读取或修改表中的数据。</span><br><span class="line">排他锁则只允许一个事务对整个表进行读写操作，其他事务只能等待该事务释放锁后才能进行操作。</span><br><span class="line"></span><br><span class="line">行锁在钟入门InnoDB存储引擎中也有两种类型：共享锁和排他锁。</span><br><span class="line">共享锁允许一个事务读取表中的某一行数据，同时允许其他事务并发地读取或修改该表中的其他行数据。</span><br><span class="line">排他锁则只允许一个事务对整行数据进行读写操作，其他事务只能等待该事务释放锁后才能进行操作</span><br><span class="line"></span><br><span class="line">在锁入门InnoDB存储引擎中，行锁比表锁具有更高的并发性能。因为行锁只锁定了需要操作的数据行，而不是整个表，所以可以大大降低锁的开销。特别是在高并发的情况下，使用行锁可以显著提高数据库的吞吐量和响应速度。</span><br><span class="line"></span><br><span class="line">然而，在某些场景下，使用表锁可能更适合。比如，在需要对整个表进行批量操作时，使用表锁可以避免对每一行进行重复锁定，从而提高效率。此外，在事务需要更新表中大部分数据时，使用表锁也可以减少锁定开销。</span><br><span class="line"></span><br><span class="line">---在使用这些锁机制时，需要注意以下几个问题：</span><br><span class="line"></span><br><span class="line">死锁问题：如果两个或多个事务互相等待对方释放锁，就会产生死锁。为避免死锁，应尽量减少事务持有锁的时间，并按照一定的顺序获取锁。</span><br><span class="line">争用问题：当多个事务尝试同时访问同一资源时，可能发生争用。为减少争用，可以考虑使用适当的隔离级别和锁类型，以及优化事务的执行顺序。</span><br><span class="line">总之，锁入门InnoDB存储引擎中的表锁和行锁是两种非常重要的锁机制。在实际应用中，根据具体的业务场景和需求选择合适的锁类型，灵活运用并注意避免潜在的问题，是充分发挥InnoDB存储引擎优势的关键。随着数据库技术的不断发展，我们相信未来钟入门InnoDB存储引擎的锁机制还将不断优化和完善，为更多应用场景提供更高效、更稳定的支持。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="sql语句-查询方式联合查询"><a href="#sql语句-查询方式联合查询" class="headerlink" title="sql语句  查询方式联合查询"></a>sql语句  查询方式联合查询</h1><p>SQL联合查询（内联、左联、右联、全联）的语法  1)Inner join 2)left outer join 3)right outer join 4)full outer join</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　如果想把用户信息、积分、等级都列出来，那么一般会这样写：select * from T1 ,T3 where T1.userid = T3.userid(其实这样的结果等同于select * from T1 inner join T3 on T1.userid=T3.userid )。</span><br><span class="line"></span><br><span class="line">　　把两个表中都存在userid的行拼成一行(即内联)，但后者的效率会比前者高很多，建议用后者(内联)的写法</span><br></pre></td></tr></table></figure>

<h1 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h1><ul>
<li><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</p>
</li>
<li><p>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</p>
</li>
<li><p>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</p>
</li>
<li><p>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
</li>
<li><p>HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p>
</li>
</ul>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p> [TCP为什么需要三次握手？用最通俗的话解释给你听-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/daocaokafei/article/details/120189376#:~:text=The">https://blog.csdn.net/daocaokafei/article/details/120189376#:~:text=The</a> principle reason for the three-way handshake is,from causing confusion. 翻译为中文大致意思是主要原因是为了防止旧的重复连接引起连接混乱问题 比如在网络环境比较复杂的情况，客户端可能会连续发送多次请求。 如果只设计成两次握手的情况，服务端只能一直接收请求，然后返回请求信息，也不知道客户端是否请求成功。 这些过期请求的话就会造成网络连接的混乱。 所以设计成三次握手的情况，客户端在接收到服务端SEQ%2B1的返回消息之后，就会知道这个连接是历史连接，所以会发送报文给服务端，告诉服务端。)</p>
<p><img src="/$%7Bimages%7D/image-20240319140506785.png" alt="三次握手的过程"></p>
<h1 id="大型项目springcloud-和-zookeeper-dubbo：：-项目对比原因-选型-原因"><a href="#大型项目springcloud-和-zookeeper-dubbo：：-项目对比原因-选型-原因" class="headerlink" title="大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因"></a>大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因</h1><h1 id="intrvmSummary2—"><a href="#intrvmSummary2—" class="headerlink" title="intrvmSummary2—-&gt;"></a>intrvmSummary2—-&gt;</h1>
      </div>
      
      
      
    </div>
  <ul class="breadcrumb">
            <li><a href="/_posts/">_POSTS</a></li>
            <li><a href="/_posts/interSummary/">INTERSUMMARY</a></li>
            <li>INTERVWSUMMARY</li>
  </ul>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zyunfei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  <!--  km 多级目录 -->
      <script type="text/javascript" src="/js/category.js"></script>

</body>
</html>
