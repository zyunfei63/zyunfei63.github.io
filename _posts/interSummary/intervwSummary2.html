<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zyunfei63.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"padding":18,"offset":12,"display":"post"},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"enable":true,"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="intrvmSummary1—-&gt;大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因Spring中的事务是如何实现的Spring中的事务是如何实现的 47 1. Spring事务底层是基于数据库事务和AOP机制的 2. ⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean 3. 当调⽤代理对象的⽅">
<meta property="og:type" content="website">
<meta property="og:title" content="intervmSummary">
<meta property="og:url" content="https://zyunfei63.github.io/_posts/interSummary/intervwSummary2.html">
<meta property="og:site_name" content="Alex Hexo">
<meta property="og:description" content="intrvmSummary1—-&gt;大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因Spring中的事务是如何实现的Spring中的事务是如何实现的 47 1. Spring事务底层是基于数据库事务和AOP机制的 2. ⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean 3. 当调⽤代理对象的⽅">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%20(1).png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240710165516753.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/Spring888-1720616917264.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/bean%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240325085447980.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240807144201678.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240325085502468.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/springaop%E5%92%8CsaspectJ__%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240710163709.jpg">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240710162314124.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240403210226504.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240413191956124.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240413193340778.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240314203551117.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240315125856907.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240323100646189.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240323100653855.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240323154251915.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240408133246137.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240828220332689.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240412133722259.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240327202022883.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240828211441771.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20240405094351170.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20250223174826081.png">
<meta property="og:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/image-20250223175057853.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250223171341206.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/image-20250506103831201.png">
<meta property="og:image" content="https://zyunfei63.github.io/$%7Bimages%7D/%E9%98%BF%E9%87%8C%E6%94%AF%E4%BB%98%E5%B9%82%E7%AD%89%E6%80%A7%E9%80%BB%E8%BE%91%E5%9B%BE.drawio.png">
<meta property="article:published_time" content="2025-10-02T05:35:53.000Z">
<meta property="article:modified_time" content="2025-10-02T05:39:45.976Z">
<meta property="article:author" content="zyunfei">
<meta property="article:tag" content="Java, go,js,Resume">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zyunfei63.github.io/_posts/interSummary/$%7Bimages%7D/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%20(1).png">


<link rel="canonical" href="https://zyunfei63.github.io/_posts/interSummary/intervwSummary2">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"en","comments":true,"permalink":"https://zyunfei63.github.io/_posts/interSummary/intervwSummary2.html","path":"_posts/interSummary/intervwSummary2.html","title":"intervmSummary"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>intervmSummary | Alex Hexo
</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GF5PJZTEZ"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-5GF5PJZTEZ","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Alex Hexo</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">可以开发出自己的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-首页"><a href="/home" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-分类"><a href="/categories/" rel="section"><i class="fas fa-folder fa-fw"></i>分类</a></li><li class="menu-item menu-item-简历"><a href="/resume/" rel="section"><i class="fas fa-briefcase fa-fw"></i>简历</a></li><li class="menu-item menu-item-github"><a href="https://github.com/zyunfei63" rel="section" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#intrvmSummary1%E2%80%94"><span class="nav-number">1.</span> <span class="nav-text">intrvmSummary1—-&gt;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AEspringcloud-%E5%92%8C-zookeeper-dubbo%EF%BC%9A%EF%BC%9A-%E9%A1%B9%E7%9B%AE%E5%AF%B9%E6%AF%94%E5%8E%9F%E5%9B%A0-%E9%80%89%E5%9E%8B-%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.</span> <span class="nav-text">大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">3.</span> <span class="nav-text">Spring中的事务是如何实现的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">4.</span> <span class="nav-text">::  事务失效的原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">5.</span> <span class="nav-text">Spring容器启动流程是怎样的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E4%B8%AD%E7%9A%84Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.</span> <span class="nav-text">Spring中的Bean创建的⽣命周期有哪些步骤</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%92%8Cmysql%E4%BA%8B%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">spring事务管理和mysql事务有什么关系？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%B5%81%E7%A8%8B-%E5%85%B3%E9%94%AE%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">springboot的自动装配流程  关键点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU%E9%A3%99%E5%8D%87%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5"><span class="nav-number">9.</span> <span class="nav-text">CPU飙升原因排查</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">保证消息队列幂等性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cglib%E5%92%8Cjdk%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.</span> <span class="nav-text">cglib和jdk代理的区别 ,动态代理和静态代理的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E4%B8%8BASM%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF-dubbo%E9%87%8C%E9%9D%A2%E4%B9%9F%E6%98%AF%E7%94%A8%E8%BF%99%E4%B8%AA-%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3-ASM-%E6%8A%80%E6%9C%AF"><span class="nav-number">12.</span> <span class="nav-text">了解下ASM的字节码技术 dubbo里面也是用这个(  简单了解 ASM　　技术)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9FSpring-AOP%E5%92%8CAspectJ%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9FSpring-AOP%E5%92%8CAspectJ%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E7%AE%80%E4%B9%A6-jianshu-com-%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？（面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？ - 简书 (jianshu.com)）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">14.</span> <span class="nav-text">AOP使用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS-%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BD%BF%E7%94%A8ReentrantLock-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="nav-number">15.</span> <span class="nav-text">AQS 技术的使用ReentrantLock 底层原理实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ReentrantReadWriteLock%E5%92%8CReentrantLock-%E5%AF%B9%E6%AF%94%E5%8D%87%E7%BA%A7%E7%9A%84%E6%98%AF%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="nav-number">16.</span> <span class="nav-text">ReentrantReadWriteLock和ReentrantLock  对比升级的是哪些方面</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CountDownLatch%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="nav-number">17.</span> <span class="nav-text">CountDownLatch使用方式原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E9%94%81%E5%92%8C%E9%9A%90%E5%BC%8F%E9%94%81-%E5%AF%B9%E6%AF%94"><span class="nav-number">18.</span> <span class="nav-text">显示锁和隐式锁 对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E9%94%81%E5%AF%B9%E6%AF%94"><span class="nav-number">19.</span> <span class="nav-text">几种锁对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6"><span class="nav-number">20.</span> <span class="nav-text">jvm本地缓存的原理和常用工具第三方组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E7%BC%93%E5%AD%98%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%88Java%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%88Guava-Cache%E3%80%81Caffeine%E3%80%81Encache%EF%BC%89"><span class="nav-number">21.</span> <span class="nav-text">jvm缓存常用的工具（Java本地缓存技术选型（Guava Cache、Caffeine、Encache）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A4%E4%B8%AA%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">22.</span> <span class="nav-text">强引用以及4个引用以及引用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sync%E5%92%8C-volatitle-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AF%B9%E6%AF%94"><span class="nav-number">23.</span> <span class="nav-text">sync和 volatitle  关键字对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sync%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">24.</span> <span class="nav-text">sync底层原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%EF%BC%88%E5%B8%B8%E7%94%A8%E7%9A%84%E5%92%8Cspring%E7%AD%89%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">设计模式  （常用的和spring等框架的使用的总结）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81-%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93%EF%BC%8C%E5%A4%87%E6%B3%A8%EF%BC%9A%EF%BC%9A-spring-bean%E5%91%A8%E6%9C%9F-%EF%BC%8C-spring%E4%BA%8B%E5%8A%A1-%E5%BB%B6%E7%94%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-%E7%BA%BF%E7%A8%8B-%E5%92%8C-%E8%A1%A8%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">26.</span> <span class="nav-text">spring事务，线程和锁 关系总结，备注：：  spring bean周期 ， spring事务  延申数据库事务  线程 和 表锁机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springcloud%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E9%A1%B6%E7%BA%A7%E6%8E%A5%E5%8F%A3"><span class="nav-number">27.</span> <span class="nav-text">springcloud负载均衡的顶级接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E4%BB%8E%E7%B1%BB%E7%9A%84%E8%A7%92%E5%BA%A6%E8%A7%A3%E9%87%8A"><span class="nav-number">28.</span> <span class="nav-text">java内存分配 从类的角度解释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">29.</span> <span class="nav-text">jvm内存模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">30.</span> <span class="nav-text">拦截器和过滤器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="nav-number">31.</span> <span class="nav-text">限流算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E5%85%B3%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">32.</span> <span class="nav-text">网关的作用，经常使用的组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">33.</span> <span class="nav-text">负载均衡的算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">34.</span> <span class="nav-text">内存泄漏和内存溢出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ConcurrentHashMap%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">35.</span> <span class="nav-text">ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">过滤器和拦截器的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%94%BE%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88"><span class="nav-number">37.</span> <span class="nav-text">放重复提交的处理方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LRUMap-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">38.</span> <span class="nav-text">LRUMap 实现原理分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8ECAS%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-number">39.</span> <span class="nav-text">关于CAS理解和应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SPI"><span class="nav-number">40.</span> <span class="nav-text">SPI</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E7%B4%AF%E5%8A%A0%E6%8A%80%E6%9C%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%80%BB%E8%BE%91"><span class="nav-number">41.</span> <span class="nav-text">分段累加技术如何实现，逻辑</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E6%96%B0JDK17%E5%92%8C22-%E7%9A%84%E6%96%B0%E7%89%B9%E7%82%B9"><span class="nav-number">42.</span> <span class="nav-text">最新JDK17和22 的新特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E5%B8%B8%E8%A7%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">43.</span> <span class="nav-text">支付系统的幂等性（常见处理方法）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">44.</span> <span class="nav-text">springboot配置文件加载优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springweb%E5%92%8Cspringwebmvc%E5%8C%BA%E5%88%AB"><span class="nav-number">45.</span> <span class="nav-text">springweb和springwebmvc区别</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zyunfei"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">zyunfei</p>
  <div class="site-description" itemprop="description">版本1.0</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="en"><header class="post-header">

<h1 class="post-title" itemprop="name headline">intervmSummary
</h1>

<div class="post-meta-container">
  <ul class="breadcrumb">
            <li><a href="/_posts/">_POSTS</a></li>
            <li><a href="/_posts/interSummary/">INTERSUMMARY</a></li>
            <li>INTERVWSUMMARY2</li>
  </ul>
</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="intrvmSummary1—"><a href="#intrvmSummary1—" class="headerlink" title="intrvmSummary1—-&gt;"></a>intrvmSummary1—-&gt;</h1><h1 id="大型项目springcloud-和-zookeeper-dubbo：：-项目对比原因-选型-原因"><a href="#大型项目springcloud-和-zookeeper-dubbo：：-项目对比原因-选型-原因" class="headerlink" title="大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因"></a>大型项目springcloud  和 zookeeper+dubbo：： 项目对比原因 选型 原因</h1><h1 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a>Spring中的事务是如何实现的</h1><p>Spring中的事务是如何实现的 47 1. Spring事务底层是基于数据库事务和AOP机制的 2. ⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean 3. 当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解 4. 如果加了，那么则利⽤事务管理器创建⼀个数据库连接 5. 并且修改数据库连接的autocommit属性为false，禁⽌此连接的⾃动提交，这是实现Spring事务⾮ 常重要的⼀步 6. 然后执⾏当前⽅法，⽅法中会执⾏sql 7. 执⾏完当前⽅法后，如果没有出现异常就直接提交事务 8. 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务 9. &#x3D;&#x3D;Spring事务的隔离级别对应的就是数据库的隔离级别&#x3D;&#x3D;  10.<font color="skyblue">    Spring事务的传播机制是Spring事务⾃⼰实现的，也是Spring事务中最复杂的 。  12.Spring事务的传播机制是基于数据库连接来做的，⼀个数据库连接⼀个事务，如果传播机制配置为 需要新开⼀个事务，那么实际上就是先建⽴⼀个数据库连接，在此新数据库连接上执⾏sql </font></p>
<img src="${images}/Spring事务的底层实现流程 (1).png" alt="Spring事务的底层实现流程 (1)" style="zoom:67%;" />



<h1 id="事务失效的原因"><a href="#事务失效的原因" class="headerlink" title="::  事务失效的原因"></a>::  事务失效的原因</h1><p><img src="/$%7Bimages%7D/image-20240710165516753.png" alt="image-20240710165516753"></p>
<h1 id="Spring容器启动流程是怎样的"><a href="#Spring容器启动流程是怎样的" class="headerlink" title="Spring容器启动流程是怎样的"></a>Spring容器启动流程是怎样的</h1><ol>
<li><p>在创建Spring容器，也就是启动Spring时： </p>
<ol start="2">
<li>⾸先会进⾏扫描，扫描得到所有的BeanDefinition对象，并存在⼀个Map中Spring容器启动流程是怎样的</li>
</ol>
</li>
<li><p>然后筛选出⾮懒加载的单例BeanDefinition进⾏创建Bean，对于多例Bean不需要在启动过程中去 进⾏创建，对于多例Bean会在每次获取Bean时利⽤BeanDefinition去创建     4. 利⽤BeanDefinition创建Bean就是Bean的创建⽣命周期，这期间包括了合并BeanDefinition、推断 构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发⽣在初始化 后这⼀步骤中 5. 单例Bean创建完了之后，Spring会发布⼀个容器启动事件 6. Spring启动结束 7. 在源码中会更复杂，⽐如源码中会提供⼀些模板⽅法，让⼦类来实现，⽐如源码中还涉及到⼀些 BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过 BenaFactoryPostProcessor来实现的，依赖注⼊就是通过BeanPostProcessor来实现的 8. 在Spring启动过程中还会去处理@Import等注解</p>
</li>
</ol>
<p>   流程如下图—</p>
<img src="${images}/Spring888-1720616917264.png" alt="Spring888" style="zoom:9%;" />







<h1 id="Spring中的Bean创建的⽣命周期有哪些步骤"><a href="#Spring中的Bean创建的⽣命周期有哪些步骤" class="headerlink" title="Spring中的Bean创建的⽣命周期有哪些步骤"></a>Spring中的Bean创建的⽣命周期有哪些步骤</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Spring中⼀个Bean的创建⼤概分为以下⼏个步骤：</span><br><span class="line">1. </span><br><span class="line">推断构造⽅法</span><br><span class="line">2. </span><br><span class="line">实例化</span><br><span class="line">3. </span><br><span class="line">填充属性，也就是依赖注⼊</span><br><span class="line">4. </span><br><span class="line">处理Aware回调</span><br><span class="line">5. </span><br><span class="line">初始化前，处理@PostConstruct注解</span><br><span class="line">6. </span><br><span class="line">初始化，处理InitializingBean接⼝</span><br><span class="line">7. </span><br><span class="line">初始化后，进⾏AOP</span><br></pre></td></tr></table></figure>



<img src="${images}/bean周期.png" alt="bean周期" style="zoom:50%;" />



<h1 id="spring事务管理和mysql事务有什么关系？"><a href="#spring事务管理和mysql事务有什么关系？" class="headerlink" title="spring事务管理和mysql事务有什么关系？"></a>spring事务管理和mysql事务有什么关系？</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358657396">【spring源码深度解析】：spring是如何利用@Transactional注解实现数据库事务的？把握住事务的基本用法你就懂了 - 知乎 (zhihu.com)</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">一个简单sql事务</span><br><span class="line"></span><br><span class="line">可见由三步组成：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 开启事务</span><br><span class="line"><span class="number">2.</span> 业务sql执行</span><br><span class="line"><span class="number">3.</span> 提交/回滚事务</span><br><span class="line"></span><br><span class="line">java代码操作数据库的六步（  <span class="number">6</span>个过程 涉及   连接 .....)</span><br><span class="line"></span><br><span class="line">保证事务的很重要的一点是,始终用一个连接connection，唯一的connection才能保证当前事务的ACID四大属性，</span><br><span class="line"></span><br><span class="line">所以被调用方法里有操作数据库时也需要用这个主方法中创建的connection。</span><br><span class="line">不可能每次 执行一个sql使用了 ThreadLocal 这个对象</span><br><span class="line"></span><br><span class="line">因为不太可能把所有调用方法都加一个connection入参，所以比较优雅的方法是把连接放在ThreadLocal里，其他方法要操作数据库时就从ThreadLocal里get即可。s</span><br><span class="line"></span><br><span class="line">后面我只 注解使用<span class="comment">///mybaits</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doTest</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    mapper.insert(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法里还是执行业务sql，但是多了个<span class="meta">@Transactional</span>注解，少了创建connection，开启事务，提交\回滚事务的代码，这些都是由<span class="meta">@Transactional</span>对应的切面来实现的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">建议大家先对spring AOP有个了解，spring事务其实就是根据事务注解生成代理类，然后在前置增强方法里获取connection，设置connection放到threadlocal 里面 使用</span><br><span class="line">    <span class="comment">// ben01      ThreadLocal  ,  Connection数据库</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;&#125; 方法</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ，开启事务。再执行原始方法，最后在后置增强方法中判断有无异常来进行事务回滚或提交，再释放连接。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="springboot的自动装配流程-关键点"><a href="#springboot的自动装配流程-关键点" class="headerlink" title="springboot的自动装配流程  关键点"></a>springboot的自动装配流程  关键点</h1><p>下面图是springboot启动的核心点提前帮助我们开发人员，写好创建Bean的配置类</p>
<p><img src="/$%7Bimages%7D/image-20240325085447980.png" alt="image-20240325085447980"></p>
<p><img src="/$%7Bimages%7D/image-20240807144201678.png" alt="image-20240807144201678"></p>
<p><img src="/$%7Bimages%7D/image-20240325085502468.png" alt="image-20240325085502468"></p>
<h1 id="CPU飙升原因排查"><a href="#CPU飙升原因排查" class="headerlink" title="CPU飙升原因排查"></a>CPU飙升原因排查</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/dennyzhangdd/p/11585971.html</span><br><span class="line">1. 使用系统监控工具：使用系统监控工具（如top、Task Manager等）来查看CPU的占用情况。观察哪些进程或线程占用了大量的CPU资源。</span><br><span class="line">2. 查看日志和堆栈信息：查看应用程序的日志和堆栈信息，寻找可能导致CPU飙高的代码。特别关注可能会导致CPU占用高的地方，如循环、递归、大量的计算等。</span><br><span class="line">3. 进行性能分析：使用性能分析工具（如VisualVM、jprofiler等）来分析应用程序的性能瓶颈。通过查看方法的执行时间和调用关系，找出耗时较长的方法和热点代码。</span><br><span class="line">4. 检查死循环和无限循环：检查代码中是否存在死循环或无限循环的情况。特别关注循环条件是否正确、循环变量是否更新等。</span><br><span class="line">5. 检查并发问题：如果程序中存在并发操作，检查是否存在竞争条件、死锁等问题。特别关注共享资源的访问和同步机制是否正确。</span><br><span class="line">6. 检查资源的释放：除了CPU资源外，还要确保程序中使用的其他资源（如文件、数据库连接、网络连接等）能够被正确释放。检查是否存在资源泄漏或未及时关闭的情况。</span><br><span class="line">7. 进行代码重构和优化：根据排查结果，进行代码重构和优化，修复性能问题。可以考虑使用缓存、异步处理、并发控制等机制来提高程序的性能。</span><br><span class="line">8. 进行压力测试：通过模拟大量并发请求或高负载情况，观察应用程序的CPU使用情况。如果CPU使用持续飙高或达到上限，可能存在性能问题。</span><br><span class="line">通过以上的排查方案和思路，可以帮助定位和解决CPU飙高的问题。同时，合理的代码编写和性能优化也是预防CPU飙高的重要手段。</span><br></pre></td></tr></table></figure>

<p>1.执行“top”命令<code>：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。</code></p>
<p>2.执行“top -Hp 进程号”命令：查看java进程下的所有线程占CPU的情况。</p>
<p>3.执行“printf “%x\n 10”命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf “%x\n 10-》打印：a，那么在jstack中线程号就是0xa.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">可能是服务器问题，需要排查网络、CPU使用率、内存使用率、磁盘使用率等。见：Java--线上问题排查--方法/步骤_IT利刃出鞘的博客-CSDN博客</span><br><span class="line"></span><br><span class="line">系统问题排查步骤</span><br><span class="line"></span><br><span class="line">以下按顺序进行</span><br><span class="line"></span><br><span class="line">是否CPU占用过高</span><br><span class="line">是否内存占用过高</span><br><span class="line">是否磁盘占用过高</span><br><span class="line">是否网络故障</span><br><span class="line">查看后台日志</span><br><span class="line">是否是数据库问题（比如：索引失效、死锁）</span><br><span class="line">是否是垃圾回收导致</span><br><span class="line">是否死锁等</span><br><span class="line">---------------</span><br><span class="line"></span><br><span class="line">步骤简述</span><br><span class="line"></span><br><span class="line">定位进程         （命令：top）</span><br><span class="line">定位线程         （命令：top -Hp 进程号）</span><br><span class="line">定位代码位置  （命令：jstack）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">java死锁</span><br><span class="line">简介</span><br><span class="line"></span><br><span class="line">有三种方法可排查死锁：jps+jstack、jconsole、jvisualvm</span><br><span class="line"></span><br><span class="line">法1：jps+jstack</span><br><span class="line"></span><br><span class="line">法2：jconsole</span><br><span class="line"></span><br><span class="line">法3：jvisualvm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">MySQL慢查询表现</span><br><span class="line">明显感觉到大部分的应用功能都变慢，但也不是完全不能工作，等待比较长的时间还是有响应的。但是整个系统看起来就非常的卡。</span><br></pre></td></tr></table></figure>



<h1 id="保证消息队列幂等性"><a href="#保证消息队列幂等性" class="headerlink" title="保证消息队列幂等性"></a>保证消息队列幂等性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">实现幂等性：</span><br><span class="line"></span><br><span class="line">   1. **唯一标识处理：** 对于每个消息，根据唯一标识（如消息ID）在处理前进行检查，确保消息在系统中只被处理一次。</span><br><span class="line"></span><br><span class="line">   2. **幂等性算法：** 设计幂等性处理算法，使得多次执行同一个操作对系统状态没有额外影响。比如，针对数据库操作，使用幂等性的SQL语句或者存储过程。</span><br><span class="line"></span><br><span class="line">   3. **版本控制：** 对于需要修改的数据，使用版本控制机制，确保对同一数据的重复操作不会改变其状态。</span><br><span class="line"></span><br><span class="line">   4. **补偿机制：** 设计补偿性操作，在消息重复消费时，通过补偿操作恢复系统状态到与处理一次消息相同的状态。</span><br><span class="line"></span><br><span class="line">   5. **消息处理日志：** 记录消息的处理状态，避免重复消费。比如，记录处理成功的消息ID或者处理结果。</span><br><span class="line"></span><br><span class="line">   在实际应用中，通常结合以上方法，根据具体业务和系统特点选择合适的方案。重要的是要在消息消费端和系统设计中考虑这些机制，以确保系统在面对消息重复消费时能够保持一致性和稳定性。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="cglib和jdk代理的区别-动态代理和静态代理的区别"><a href="#cglib和jdk代理的区别-动态代理和静态代理的区别" class="headerlink" title="cglib和jdk代理的区别 ,动态代理和静态代理的区别"></a>cglib和jdk代理的区别 ,动态代理和静态代理的区别</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">常见的代理方式 </span><br><span class="line">&#123;<span class="number">01</span>   dubbo没有使用cglib  而是使用JDK和Javassist来进行动态代理</span><br><span class="line"><span class="number">02</span>   spring扩展的事务机制代理对象 是使用cglib 和jdk两种方式 同时处理数据库事务， CGLib动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被<span class="keyword">final</span>关键字所修饰， 事务会失效，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口,,,定义横切逻辑（如：我们在方法执行前后打印的日志，本文只是为了演示，实际的应用一般不会只是简单的打印日志的），并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</span><br><span class="line"></span><br><span class="line">CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</span><br><span class="line"></span><br><span class="line">CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强；需要引入包asm.jar和cglib.jar。 使用AspectJ注入式切面和<span class="meta">@AspectJ</span>注解驱动的切面实际上底层也是通过动态代理实现的。</span><br><span class="line"></span><br><span class="line">在JDK1<span class="number">.8</span>的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了，但是JDK动态代理和CGLIB动态代理的适用场景还是不一样的哈！</span><br><span class="line"></span><br><span class="line">Java动态代理优缺点：</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>Java本身支持，不用担心依赖问题，随着版本稳定升级；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>代码实现简单；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>目标类必须实现某个接口，换言之，没有实现接口的类是不能生成代理对象的；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>代理的方法必须都声明在接口中，否则，无法代理；</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>执行速度性能相对cglib较低；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cglib优缺点：</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>代理的类无需实现接口；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>执行速度相对JDK动态代理较高；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>字节码库需要进行更新以保证在新版java上能运行；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>动态创建代理对象的代价相对JDK动态代理较高；</span><br><span class="line"></span><br><span class="line">Tips：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>代理的对象不能是<span class="keyword">final</span>关键字修饰的</span><br><span class="line">    </span><br><span class="line">    ————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/Death_Eric/article/details/98203329</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----静态代理动态代理对比</span><br><span class="line">    </span><br><span class="line">    Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。</span><br><span class="line"></span><br><span class="line">静态代理</span><br><span class="line">Java中的静态代理要求代理类(ProxySubject)和委托类(RealSubject)都实现同一个接口(Subject)。静态代理中代理类在编译期就已经确定，而动态代理则是JVM运行时动态生成，静态代理的效率相对动态代理来说相对高一些，但是静态代理代码冗余大，一单需要修改接口，代理类和委托类都需要修改。</span><br><span class="line"></span><br><span class="line">作者：zhong0316</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/f56e123817b5</span></span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    代理对象与目标对象一起实现相同的接口或者继承相同父类，由程序员创建或特定工具自动生成源代码，即在编译时就已经确定了接口，目标类，代理类等。在程序运行之前，代理类 的 .class 文件就已经生成  ，你可以简单认为代理对象写死持有目标对象。</span><br><span class="line">        </span><br><span class="line">--延申  动态代理细分  </span><br><span class="line"> &amp;&amp; 从实现原理上，我们又可以将动态代理划分为两大类：</span><br><span class="line">编译时增强。   （使用 AspectJ 时需要使用专门的编译器 ajc。  AspectJ 提供编译时织入和运行时织入两种方式来实现 AOP。编译时织入可以在编译应用程序时织入切面代码，因此会更加高效，而运行时织入需要在应用程序运行时动态织入切面代码，因此性能开销可能会更大。但是，AspectJ 本身是一个底层的 AOP 框架，因此相对于 Spring AOP 来说，它更精细和高效。）</span><br><span class="line">运行时增强。（jdk  和cglib）</span><br></pre></td></tr></table></figure>



<h1 id="了解下ASM的字节码技术-dubbo里面也是用这个-简单了解-ASM-技术"><a href="#了解下ASM的字节码技术-dubbo里面也是用这个-简单了解-ASM-技术" class="headerlink" title="了解下ASM的字节码技术 dubbo里面也是用这个(  简单了解 ASM　　技术)"></a>了解下ASM的字节码技术 dubbo里面也是用这个(  简单了解 ASM　　技术)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_53840353/article/details/140033143</span><br></pre></td></tr></table></figure>

<h1 id="面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？（面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？-简书-jianshu-com-）"><a href="#面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？（面试官：什么是AOP？Spring-AOP和AspectJ的区别是什么？-简书-jianshu-com-）" class="headerlink" title="面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？（面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？ - 简书 (jianshu.com)）"></a>面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9b107da30466">面试官：什么是AOP？Spring AOP和AspectJ的区别是什么？ - 简书 (jianshu.com)</a>）</h1><p><img src="/$%7Bimages%7D/springaop%E5%92%8CsaspectJ__%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240710163709.jpg" alt="springaop和saspectJ__微信图片_20240710163709"></p>
<p><img src="/$%7Bimages%7D/image-20240710162314124.png" alt="image-20240710162314124"></p>
<h1 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">AOP使用场景：</span><br><span class="line"></span><br><span class="line">Authentication 权限检查</span><br><span class="line"></span><br><span class="line">Caching 缓存</span><br><span class="line"></span><br><span class="line">Context passing 内容传递</span><br><span class="line"></span><br><span class="line">Error handling 错误处理</span><br><span class="line"></span><br><span class="line">Lazy loading　延迟加载</span><br><span class="line"></span><br><span class="line">Debugging　　调试</span><br><span class="line"></span><br><span class="line">logging, tracing, profiling and monitoring　日志记录，跟踪，优化，校准</span><br><span class="line"></span><br><span class="line">Performance optimization　性能优化，效率检查</span><br><span class="line"></span><br><span class="line">Persistence　　持久化</span><br><span class="line"></span><br><span class="line">Resource pooling　资源池</span><br><span class="line"></span><br><span class="line">Synchronization　同步</span><br><span class="line"></span><br><span class="line">Transactions 事务管理</span><br><span class="line"></span><br><span class="line">另外Filter的实现和struts2的拦截器的实现都是AOP思想的体现。</span><br><span class="line"></span><br><span class="line">我们是在使用Spring框架的过程中，其实就是为了使用IOC，依赖注入，和AOP，面向切面编程，这两个是Spring的灵魂。</span><br><span class="line"></span><br><span class="line">主要用到的设计模式有工厂模式和代理模式。</span><br><span class="line"></span><br><span class="line">IOC就是典型的工厂模式，通过sessionfactory去注入实例。</span><br><span class="line"></span><br><span class="line">AOP就是典型的代理模式的体现。</span><br><span class="line"></span><br><span class="line">代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</span><br></pre></td></tr></table></figure>

<h1 id="AQS-技术的使用ReentrantLock-底层原理实现"><a href="#AQS-技术的使用ReentrantLock-底层原理实现" class="headerlink" title="AQS 技术的使用ReentrantLock 底层原理实现"></a>AQS 技术的使用ReentrantLock 底层原理实现</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, Serializable </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReentrantLock底层使用了CAS+AQS队列实现  （ 增加了 轮询 超时 中断 公平锁和非公锁）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主要区别就在于锁的获取方式。公平锁会严格按照请求的先后顺序分配锁，等待时间最长的线程会优先获取锁，这样可以避免线程饥饿（线程饥饿指 一个线程长时间持有锁，其他线程不能持有锁 操作热点资源）的问题。而非公平锁则允许新的线程插队，如果新线程恰好在锁释放的瞬间请求锁，它有可能会在等待队列的前面获取到锁，这样可能会导致某一个线程己经在等待的线程等待更长时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">两种所使用的场景</span><br><span class="line">公平锁适合对线程执行顺序有严格要求的场景，比如任务调度。</span><br><span class="line">而非公平锁则适用于对并发性能要求比较高的场景，因为它允许新的线程插队，可能会减少线程切换的开销。但需要注意，使用非公平锁可能会导致某些线程等待时间过长。</span><br><span class="line"></span><br><span class="line">reentranLock可以显示的方式控制锁的获取和释放 就是lock()  unlock（） 方法， </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync(); //默认，非公平</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">// var1=true 公平锁</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync(); //根据参数创建</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. lock() 和 unlock() 的实现</span><br><span class="line"></span><br><span class="line"> final void lock() &#123; //非公平锁</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123; //公平锁</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    4.3 addWaiter()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ReentrantLock中tryLock()和lock()方法的区别</span><br><span class="line">1. trylock0表示会试加锁，可能加口到，也可能加口不到，该方法不会阻寨线程，如果加到锁则返回</span><br><span class="line">true，没有加到则返回false</span><br><span class="line">2. lockO表示阻塞加锁，线程会阻塞直到加到锁，方法也没有返回值</span><br><span class="line"></span><br><span class="line">当前线程加入AQS双向链表队列。</span><br><span class="line"></span><br><span class="line">写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))。</span><br><span class="line"></span><br><span class="line">首先判断队列是否为空，不为空时则将封装好的 Node 利用 CAS 写入队尾，如果出现并发写入失败就需要调用 enq(node); 来写入了。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">总结</span><br><span class="line">0.每一个ReentrantLock自身维护一个AQS队列记录申请锁的线程信息；</span><br><span class="line"></span><br><span class="line">1.通过大量CAS保证多个线程竞争锁的时候的并发安全；</span><br><span class="line"></span><br><span class="line">2.可重入的功能是通过维护state变量来记录重入次数实现的。</span><br><span class="line"></span><br><span class="line">3.公平锁需要维护队列，通过AQS队列的先后顺序获取锁，缺点是会造成大量线程上下文切换；</span><br><span class="line"></span><br><span class="line">4.非公平锁可以直接抢占，所以效率更高；</span><br><span class="line">5.  非公平锁性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。</span><br><span class="line">6.==使用场景的话呢，其实还是和他们的属性一一相关，举个栗子：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平(CAS)锁其实效率并不明显，但是用公平锁会给业务增强很多的可控制性。==</span><br><span class="line">----</span><br><span class="line">https://zhuanlan.zhihu.com/p/249147493</span><br><span class="line">--需要看 rent具体方法， 公平锁和非公平锁的实现为啥这样，如何选择</span><br><span class="line">--- CLH锁的而数据结构和实现</span><br><span class="line">CLH锁</span><br><span class="line">https://zhuanlan.zhihu.com/p/197840259#2%20%E4%BB%80%E4%B9%88%E6%98%AFclh%E9%94%81%EF%BC%9F</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240403210226504.png" alt="image-20240403210226504"></p>
<h1 id="ReentrantReadWriteLock和ReentrantLock-对比升级的是哪些方面"><a href="#ReentrantReadWriteLock和ReentrantLock-对比升级的是哪些方面" class="headerlink" title="ReentrantReadWriteLock和ReentrantLock  对比升级的是哪些方面"></a>ReentrantReadWriteLock和ReentrantLock  对比升级的是哪些方面</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock（可重入读写锁）是Java中另一种常用的锁，也是一种可重入锁。与ReentrantLock不同的是，ReentrantReadWriteLock既可以支持独占锁，也可以支持共享锁。共享锁是指同一时刻可以有多个线程读取共享资源，但只能有一个线程写入共享资源；独占锁是指同一时刻只能有一个线程获得锁，其他线程必须等待。因此，ReentrantReadWriteLock适用于读多写少的场景，可以提高并发读操作的效率。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            ##############阁下如果是抄袭，爬取文章作恶或误导他人的开发者,请阅读中国现行法律的相关处罚条例再动手，转载之前最好先验证############# </span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/java_wxid/article/details/132650101</span><br><span class="line">-----</span><br><span class="line">CopyOnWriteArrayList 适用于读多写少的并发场景，比如白名单，黑名单等场景</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="CountDownLatch使用方式原理"><a href="#CountDownLatch使用方式原理" class="headerlink" title="CountDownLatch使用方式原理"></a>CountDownLatch使用方式原理</h1><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/WINGZINGLIU/article/details/107227620">https://blog.csdn.net/WINGZINGLIU/article/details/107227620</a></p>
<p>CountDownLatch</p>
<p>CountDownLatch是一个可以使其他线程等待某些线程执行完毕后再进行执行的工具类。</p>
<p>用我个人的理解来说的话，就是它提供了一个await()方法来阻塞当前线程，</p>
<p>直到countDown()方法使得计数器递减到0之后对阻塞队列中线程进行唤醒，来达到一种等待的效果。</p>
<p><font  color="yellow">**CountDownLatch数据结构&#x2F;   CountDownLatch是利用AQS共享锁机制的同步器Sync来实现的</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享锁的概念  </span><br><span class="line">---共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。</span><br><span class="line">如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">--下面是源码的 部分解析</span><br><span class="line">public class CountDownLatch &#123;</span><br><span class="line">    // 继承AQS来实现同步器，</span><br><span class="line">    private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">	</span><br><span class="line">		// 通过state控制count</span><br><span class="line">        Sync(int count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">		// 重写AQS的tryAcquireShared，通过获取共享锁的方式实现等待</span><br><span class="line">        protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">			// 当state不为0时一直阻塞</span><br><span class="line">            return (getState() == 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">		// 释放共享锁</span><br><span class="line">        protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int c = getState();</span><br><span class="line">				</span><br><span class="line">				// 如果state为0，则不能再使用，</span><br><span class="line">                if (c == 0) return false;</span><br><span class="line">				// state减1</span><br><span class="line">                int nextc = c-1;</span><br><span class="line">				// 为0，释放共享锁，唤醒等待线程</span><br><span class="line">                if (compareAndSetState(c, nextc)) return nextc == 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	// 同步器变量</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    // 创建同步器，设置AQS的state变量为1</span><br><span class="line">    public CountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">        this.sync = new Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="显示锁和隐式锁-对比"><a href="#显示锁和隐式锁-对比" class="headerlink" title="显示锁和隐式锁 对比"></a><font  color="gree">显示锁和隐式锁 对比</font></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Java中隐式锁：synchronized；显式锁：lock</span><br><span class="line"></span><br><span class="line">---java锁体系：：</span><br><span class="line"></span><br><span class="line">1--synchronized是Java中的关键字，由JVM维护，是JVM层面的锁；</span><br><span class="line">而lock是JDK5之后才出现的具体的类，使用Lock是调用对应的API，是API层面的锁。</span><br><span class="line"></span><br><span class="line">2--显氏锁和隐式锁的区别在于：使用显式锁的时候，使用者需要手动去获取和释放锁</span><br><span class="line"></span><br><span class="line">3--synchronized关键字是不可中断的，除非抛出异常或者正常运行结束而Lock是可以中断的，中断方式：</span><br><span class="line">调用设置超时方法tryLock(Long timeout,timeUnit unit)</span><br><span class="line">调用lockInterruptibly()放到代码块中，然后调用interrupt()方法可以中断。</span><br><span class="line"></span><br><span class="line">4---synchronized是非公平锁；而lock两者都可以，默认创建是非公平锁。</span><br><span class="line"></span><br><span class="line">---mysql</span><br><span class="line">显示锁和隐式锁是MySQL中的两种不同的锁机制。 显示锁需要开发人员手动指定锁定的对象，包括共享锁和排他锁。 隐式锁是MySQL自动为事务提供的，根据事务的操作自动加锁，包括隐式共享锁和隐式排他锁。 使用显示锁可以更精细地控制锁的范围，提高并发性能。 而隐式锁相对于开发人员更加方便，但锁的范围相对较大，可能造成锁冲突</span><br></pre></td></tr></table></figure>



<h1 id="几种锁对比"><a href="#几种锁对比" class="headerlink" title="几种锁对比"></a>几种锁对比</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。</span><br><span class="line">排它锁，也称作独占锁，一个锁在某一时刻只cf能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。</span><br><span class="line">2. 独占锁和共享锁实例</span><br><span class="line">ReentrantLock就是一种排它锁。CountDownLatch是一种共享锁。这两类都是单纯的一类，即，要么是排它锁，要么是共享锁。 ReentrantReadWriteLock是同时包含 排他锁和共享锁特性的一种锁， 这里主要以ReentrantReadWriteLock为例来进行分析学习。我们使用ReentrantReadWriteLock的写锁时，使用的便是排它锁的特性；使用ReentrantReadWriteLock的读锁时，使用的便是共享锁的特性</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/u012184539/article/details/88561195</span><br><span class="line"></span><br><span class="line">--01  独占锁和共享</span><br><span class="line"></span><br><span class="line">--02  乐观 悲观</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---03 自旋锁和互斥锁的区别</span><br><span class="line">https://blog.csdn.net/qq_37935909/article/details/108625508</span><br><span class="line">1、互斥锁</span><br><span class="line">互斥锁是一种独占锁，当线程A加锁成功后，此时互斥锁已经被线程A独占了，只要线程A没有释放手中的锁，线程B就会失败，就会释放掉CPU给其他线程，线程B加锁的代码就会被阻塞。</span><br><span class="line"></span><br><span class="line">互斥锁加锁失败而阻塞是由操作系统内核实现的，当加锁失败后，内核将线程置为睡眠状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程加锁成功后就可以继续执行。&#123;  内核态和用户态 区别&#125;</span><br><span class="line">&#123;  结论  ：：  </span><br><span class="line">如果锁住的代码 业务中线程占用(处理)时间  比较短，可能上下文切换的时间比锁住的代码执行时间还要长。若是能确定被锁住的代码执行时间很短，应该选择自旋锁；  那么 如果执行的代码块  需要时间比较久  不要使用CAS自旋锁  至于是否使用互斥锁 目前不知，个人感觉感觉使用互斥锁也不是最好选择&#125;</span><br><span class="line"></span><br><span class="line">自旋锁通过CPU提供的CAS，在用户态完成加锁和解锁操作，不会主动产生线程上下文切换(没有用户态和内核态切换)，所以相比互斥锁来说，会快一些开销小一些。</span><br><span class="line">加锁过程：</span><br><span class="line"></span><br><span class="line">查看锁的状态，若是空闲的则执行2</span><br><span class="line">将锁设置为当前线程持有；</span><br><span class="line">使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会忙等待，直到拿到锁。忙等待可以通过while循环实现，不过最好是使用CPU提供的PAUSE指令来实现。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_37935909/article/details/108625508</span><br><span class="line"></span><br><span class="line">---04  同步锁和异步锁（redis分布式锁就是异步锁）</span><br><span class="line">同步锁：当在一个java虚拟机多个线程操作一个变量的时候就会出现线程安全问题，这个时候就会用到同步锁。  解决办法是使用 sync</span><br><span class="line">异步锁：就是多个java 虚拟机或者说是服务器，操作同一个变量是，会出现线程安全问题，使用需要使用异步锁来处理。</span><br><span class="line">       使用dubbo  zookeeper (共享锁，排它锁)，这里就根据自己的情况，共享锁还是会出现阻塞的情况，排它锁就是会生成很多临时的        节点，谁先获取最小的序号标识谁就先获取到锁</span><br></pre></td></tr></table></figure>





<h1 id="jvm本地缓存的原理和常用工具第三方组件"><a href="#jvm本地缓存的原理和常用工具第三方组件" class="headerlink" title="jvm本地缓存的原理和常用工具第三方组件"></a>jvm本地缓存的原理和常用工具第三方组件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/585557682</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JVM本地缓存的优点包括：</span><br><span class="line"></span><br><span class="line">提高性能：通过减少对外部资源或网络的访问，本地缓存可以显著提高应用程序的性能。</span><br><span class="line">降低延迟：由于减少了外部访问的需要，本地缓存可以降低应用程序的延迟。</span><br><span class="line">提高可用性：通过缓存数据，即使在外部资源不可用的情况下，应用程序也可以继续执行。</span><br><span class="line">然而，本地缓存也存在一些潜在问题：</span><br><span class="line"></span><br><span class="line">内存占用：如果缓存数据过多或不必要地占用内存，可能会导致内存不足的问题。这可能会影响应用程序的性能，甚至导致应用程序崩溃。</span><br><span class="line">数据过期：如果缓存的数据已经过期或不再有效，但仍然被用于后续操作，可能会导致错误的计算结果或行为。</span><br><span class="line">同步问题：在多线程环境下，如果多个线程同时访问和修改同一份缓存数据，可能会导致数据不一致或竞态条件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为了优化JVM本地缓存的性能，你可以考虑以下几点：</span><br><span class="line"></span><br><span class="line">合理配置堆大小：根据应用程序的需求和可用内存，合理配置堆的大小。过小的堆可能导致频繁的垃圾回收，而过大的堆可能导致内存溢出。</span><br><span class="line">利用垃圾回收机制：垃圾回收是JVM自动管理堆内存的一种机制。通过合理配置垃圾回收参数，可以降低内存泄漏和碎片化的风险，提高应用程序的性能。</span><br><span class="line">优化方法区使用：方法区的大小和配置对于JVM的性能具有重要影响。通过合理配置方法区的参数，可以避免方法区溢出或性能下降的问题。</span><br><span class="line">利用缓存淘汰策略：对于本地缓存数据，应该定期进行清理和淘汰。通过合理配置缓存淘汰策略，可以避免内存占用过高或数据过期的问题。</span><br><span class="line">同步和并发控制：在多线程环境下，应该注意对缓存数据的同步和并发控制。通过合理使用同步锁或并发控制工具，可以避免数据不一致或竞态条件的问题。</span><br></pre></td></tr></table></figure>

<h1 id="jvm缓存常用的工具（Java本地缓存技术选型（Guava-Cache、Caffeine、Encache）"><a href="#jvm缓存常用的工具（Java本地缓存技术选型（Guava-Cache、Caffeine、Encache）" class="headerlink" title="jvm缓存常用的工具（Java本地缓存技术选型（Guava Cache、Caffeine、Encache）"></a>jvm缓存常用的工具（Java本地缓存技术选型（Guava Cache、Caffeine、Encache）</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e5dc3a18dcb8">Java本地缓存技术选型（Guava Cache、Caffeine、Encache） - 简书 (jianshu.com)</a>）</p>
<p>{redis  megoDB  这两种都属于remote cache（分布式缓存}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">对一个java后台开发者而言，提到缓存，第一反应就是redis和memcache。利用这类缓存足以解决大多数的性能问题了，并且java针对这两者也都有非常成熟的api可供使用。但是我们也要知道，这两种都属于remote cache（分布式缓存），应用的进程和缓存的进程通常分布在不同的服务器上，不同进程之间通过RPC或HTTP的方式通信。这种缓存的优点是缓存和应用服务解耦，支持大数据量的存储，缺点是数据要经过网络传输，性能上会有一定损耗。</span><br><span class="line"></span><br><span class="line">与分布式缓存对应的是本地缓存，缓存的进程和应用进程是同一个，数据的读写都在一个进程内完成，这种方式的优点是没有网络开销，访问速度很快。缺点是受JVM内存的限制，不适合存放大数据。</span><br><span class="line">---01  自定义使用LinkedHashMap  和 ReentrantReadWriteLock</span><br><span class="line"></span><br><span class="line">---02</span><br><span class="line">2. 基于Guava Cache实现本地缓存</span><br><span class="line">Guava是Google团队开源的一款 Java 核心增强库，包含集合、并发原语、缓存、IO、反射等工具箱，性能和稳定性上都有保障，应用十分广泛。Guava Cache支持很多特性：</span><br><span class="line"></span><br><span class="line">支持最大容量限制</span><br><span class="line">支持两种过期删除策略（插入时间和访问时间）</span><br><span class="line">支持简单的统计功能</span><br><span class="line">基于LRU算法实现</span><br><span class="line">Guava Cache的使用非常简单，首先需要引入maven包</span><br><span class="line"></span><br><span class="line">--03 </span><br><span class="line">3. Caffeine</span><br><span class="line">Caffeine是基于java8实现的新一代缓存工具，缓存性能接近理论最优。可以看作是Guava Cache的增强版，功能上两者类似，不同的是Caffeine采用了一种结合LRU、LFU优点的算法：W-TinyLFU，在性能上有明显的优越性。Caffeine的使用，首先需要引入maven包：</span><br><span class="line"></span><br><span class="line">---04</span><br><span class="line"></span><br><span class="line">4. Encache</span><br><span class="line">Encache是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。同Caffeine和Guava Cache相比，Encache的功能更加丰富，扩展性更强：</span><br><span class="line"></span><br><span class="line">支持多种缓存淘汰算法，包括LRU、LFU和FIFO</span><br><span class="line">缓存支持堆内存储、堆外存储、磁盘存储（支持持久化）三种</span><br><span class="line">支持多种集群方案，解决数据共享问题</span><br><span class="line">Encache的使用，首先需要导入maven包：</span><br><span class="line"></span><br><span class="line">作者：程序员日志</span><br><span class="line">链接：https://www.jianshu.com/p/e5dc3a18dcb8</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>











<h1 id="强引用以及4个引用以及引用场景"><a href="#强引用以及4个引用以及引用场景" class="headerlink" title="强引用以及4个引用以及引用场景"></a>强引用以及4个引用以及引用场景</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.强引用（Strong Reference）：2. 软引用（Soft Reference）：3. 弱引用（Weak Reference）：4. 虚引用（Phantom Reference）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从JDK 1.2版本开始，对象的引用被划分为4种级别，这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。</span><br><span class="line"></span><br><span class="line">---01</span><br><span class="line">强引用（Strong Reference）   定义： 强引用（Strong Reference）是Java中最为普遍的引用类型。当一个对象被强引用关联时，垃圾回收器不会回收这个对象，即使系统内存不足也不会回收。只有当该对象的强引用被显式地释放，或者不再被任何引用关联时，该对象才会成为垃圾回收的候选对象。  // 创建一个对象并建立强引用常见的   Object obj = new Object(); // 强引用</span><br><span class="line"></span><br><span class="line">特点：：如果一个对象具有强引用，那就类似于必不可少的物品，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</span><br><span class="line">----02  软引用</span><br><span class="line">软引用用于描述一些还有用但并非必须的对象，在内存不足时可能被垃圾回收。  SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(largeObject);s</span><br><span class="line">使用场景 ：： 1.对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存  2. 当堆的使用率超过阈值时，才回去回收软引用中的对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---03   weak引用</span><br><span class="line">弱引用（Weak Reference）是Java中一种比强引用更弱的引用类型。当一个对象只被弱引用关联时，在下一次垃圾回收时，该对象就有可能被回收。垃圾回收器会在适当的时候回收仅被弱引用持有的对象，即使内存并不紧张，无论内存是否充足，都会回收被弱引用关联的对象</span><br><span class="line">使用场景：：： 这个类通常用于在某处保存对象引用，而又不干扰该对象被GC回收，通常用于Debug、内存监视工具等程序中。因为这类程序一般要求即要观察到对象，又不能影响该对象正常的GC过程    WeakReference&lt;Object&gt; weakRef = new WeakReference&lt;&gt;(obj)</span><br><span class="line"></span><br><span class="line">使用场景：：1.  WeakHashMap   当key只有弱引用时，GC发现后会自动清理键和值，作为简单的缓存表解决方案。</span><br><span class="line"></span><br><span class="line">2.   ThreadLocal</span><br><span class="line">     ThreadLocal.ThreadLocalMap.Entry 继承了弱引用，key为当前线程实例，和WeakHashMap基本相同。</span><br><span class="line"></span><br><span class="line">----04</span><br><span class="line">虚引用（Phantom Reference）是Java中最弱的引用类型之一，无法通过引用直接获取到对象实例。虚引用主要用于跟踪对象被垃圾回收的状态。当一个对象只被虚引用关联时，其实际上并不影响对象的生命周期，也就是说，垃圾回收器随时可能回收被虚引用关联的对象。</span><br><span class="line"> </span><br><span class="line"> 使用场景</span><br><span class="line"> ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = new PhantomReference&lt;&gt;(obj, referenceQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些对象具备一定的生命周期的话（比如内存不足时JVM就会自动回收某些对象从而避免OutOfMemory的错误）就需要用到软引用和弱引用了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="sync和-volatitle-关键字对比"><a href="#sync和-volatitle-关键字对比" class="headerlink" title="sync和 volatitle  关键字对比"></a>sync和 volatitle  关键字对比</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377423211">面试官：请详细说下synchronized的实现原理 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/567879393/answer/2978976437">(8 封私信 &#x2F; 80 条消息) synchronized 和 volatile 有什么区别？ - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356010805">Java面试常见问题：Monitor对象是什么？ - 知乎 (zhihu.com)</a></p>
<p>[(8 封私信 &#x2F; 80 条消息) synchronized 关键字可以保证可见性吗？ - 知乎 (zhihu.com)](https:&#x2F; &#x2F;<a target="_blank" rel="noopener" href="http://www.zhihu.com/question/48313299">www.zhihu.com/question/48313299</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">synchronized  在jdk1.6之前，synchronized被称为重量级锁，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了偏向锁和轻量级锁  </span><br><span class="line">是Java中的monitor是通过内置锁（也称为监视器锁）来实现的 ,  其他的rentanLock这种事使用的 显示锁。</span><br><span class="line"></span><br><span class="line">因为volatile不能保证变量操作的原子性，所以试图通过volatile来保证线程安全性是不靠谱的， volatile 修饰的变量 在两个线程一加一减的 相同次数 最后 ，结果可能出现 counter=1 ,也就是会出现 加减次数不一致问题。  不是原子操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----02</span><br><span class="line"></span><br><span class="line">synchronized 和 volatile 都是 Java 中用来实现多线程同步的机制，但是它们有一些不同，具体可以从以下几个方面进行比较：</span><br><span class="line"></span><br><span class="line">1. 变量特性：synchronized 是利用锁来保证同步的，而 volatile 是利用内存屏障来保证可见性和禁止指令重排的。</span><br><span class="line"></span><br><span class="line">2. 内存开销：synchronized 在使用时有一定的内存开销，需要进行锁的申请、释放、等待等操作，而 volatile 则没有锁的开销，通过 CPU 的缓存一致性实现了数据的可见性。</span><br><span class="line"></span><br><span class="line">3. 线程安全：synchronized 是线程安全的，可以保证多线程下数据的准确性，但是 volatile 是满足一定的条件才能保证原子性和可见性的。例如，对于 ++ 操作，需要使用AtomicInteger；对于多个 volatile 变量的分组操作，需要使用锁或者AtomicReference。</span><br><span class="line"></span><br><span class="line">4. 使用场景：synchronized 适用于需要在代码块或者方法上进行同步控制的场景，而 volatile 适用于只需要保证变量的可见性，而不需要保证多线程之间的原子性操作的场景。</span><br><span class="line"></span><br><span class="line">总之，synchronized 和 volatile 都是用来实现多线程同步的，synchronized 具有更加强大的功能，但同时也有一定的性能开销，适用于在多个线程之间需要同步共享变量的情况。而 volatile 能够更加轻量级地实现变量的可见性，适用于只需要保证某个变量的可见性，而不需要同步控制的场景。</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/m0_68464502/article/details/131107637</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">synchronized的缺点：</span><br><span class="line">1.无法判断获取锁的状态。</span><br><span class="line">2.虽然会自动释放锁，但如果如果锁的那个方法执行时间较长就会一直占用着不去释放，不能让使用同一把锁的方法继续执行，影响程序的运行如（例1）。（会锁住某一段程序，别的程序如果需要调用的话就必须等待，减少了速度、效率)。</span><br><span class="line">3.使用synchronized，当多个线程尝试获取锁时，未获取到锁的线程会不断的尝试获取锁，而不会发生中断，这样会造成性能消耗。</span><br><span class="line">4.有可能产生死锁，导致程序中断</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/qq_44978607/article/details/115270957</span><br></pre></td></tr></table></figure>





<h1 id="sync底层原理"><a href="#sync底层原理" class="headerlink" title="sync底层原理"></a>sync底层原理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">01--- 常提到 特性</span><br><span class="line">面试时经常拿synchronized关键字和volatile关键字的特性进行对比，synchronized关键字可以保证并发编程的三大特性：原子性、可见性、有序性，而volatile关键字只能保证可见性和有序性，不能保证原子性，也称为是轻量级的synchronized。</span><br><span class="line">原子性：一个或多个操作要么全部执行成功，要么全部执行失败。synchronized关键字可以保证只有一个线程拿到锁，访问共享资源。</span><br><span class="line">可见性：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized时，会对应执行 lock、unlock原子操作(synchronized在修改了本地内存中的变量后，解锁前会将本地内存修改的内容刷新到主内存中，确保了共享变量的值是最新的，也就保证了可见性。)，保证可见性。</span><br><span class="line">有序性：程序的执行顺序会按照代码的先后顺序执行。</span><br><span class="line">02---synchronized关键字可以实现什么类型的锁？</span><br><span class="line"></span><br><span class="line">悲观锁：synchronized关键字实现的是悲观锁，每次访问共享资源时都会上锁。</span><br><span class="line">非公平锁：synchronized关键字实现的是非公平锁，即线程获取锁的顺序并不一定是按照线程阻塞的顺序。</span><br><span class="line">可重入锁：synchronized关键字实现的是可重入锁，即已经获取锁的线程可以再次获取锁。</span><br><span class="line">独占锁或者排他锁：synchronized关键字实现的是独占锁，即该锁只能被一个线程所持有，其他线程均被阻塞。</span><br><span class="line"></span><br><span class="line">03--JDK1.6之前  底层加锁原理</span><br><span class="line">在jdk1.6之前，synchronized被称为重量级锁，</span><br><span class="line">其实是这样的，在JDK 1.6之前是重量级锁，线程进入同步代码块/方法 时候选者：monitor对象就会把当前进入线程的Id进行存储，</span><br><span class="line">设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中候选者：</span><br><span class="line">它加锁是依赖底层操作系统的 &#123;mutex 相关指令&#125;实现，所以会有用户态和内核态之间的切换，性能损耗十分明显候选者：</span><br><span class="line">而JDK1.6 以后引入偏向锁和轻量级锁在JVM层面实现加锁的逻辑，不依赖底层操作系统，就没有切换的消耗候选者：</span><br><span class="line">所以，Mark Word对锁的状态记录一共有4种：无锁、偏向锁、轻量级锁和重量级锁</span><br><span class="line"></span><br><span class="line">。下面先介绍jdk1.6之前的synchronized原理。</span><br><span class="line"></span><br><span class="line">在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：</span><br><span class="line">对象头、</span><br><span class="line">实例数据</span><br><span class="line">和填充对齐。</span><br><span class="line">----</span><br><span class="line">1，Mark Word</span><br><span class="line">2，指向类的指针</span><br><span class="line">3，数组长度（只有数组对象才有</span><br><span class="line">---</span><br><span class="line">因为synchronized用的锁是存在对象头里的，这里我们需要重点了解对象头</span><br><span class="line"></span><br><span class="line">在Hotspot虚拟机中，Monitor是由ObjectMonitor实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，a::代码块同步使用的是monitorenter和 monitorexit 指令实现的，b::而方法同步是通过Access flags后面的标识来确定该方法是否为同步方法(  下面两个图 就是处理的 标记)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">04 --JDK1.6之后    底层加锁原理</span><br><span class="line">  a---优化的原因（用户态和内核态的切换）</span><br><span class="line">因为Java虚拟机是通过进入和退出Monitor对象来实现代码块同步和方法同步的，而Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大。</span><br><span class="line"></span><br><span class="line">在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，锁的状态变成了四种，如下图所示。锁的状态会随着竞争激烈逐渐升级，但通常情况下，锁的状态只能升级不能降级。这种只能升级不能降级的策略是为了提高获得锁和释放锁的效率</span><br><span class="line"></span><br><span class="line">。。。。。。继续  https://zhuanlan.zhihu.com/p/377423211</span><br><span class="line"></span><br><span class="line">jclasslib Bytecode viewer---反编译工具  C语言级别工具</span><br><span class="line">javap -c  SynchronizedDemo.class  命令进行反编译</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240413191956124.png" alt="image-20240413191956124"><img src="/$%7Bimages%7D/image-20240413193340778.png" alt="image-20240413193340778"></p>
<h1 id="设计模式-（常用的和spring等框架的使用的总结）"><a href="#设计模式-（常用的和spring等框架的使用的总结）" class="headerlink" title="设计模式  （常用的和spring等框架的使用的总结）"></a>设计模式  （常用的和spring等框架的使用的总结）</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/634398640">并发专栏-队列同步器 AQS 以及 Reentrantlock 应用 - 知乎 (zhihu.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">01模板方法模式 （ 特点：： 模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码）</span><br><span class="line">ReentrantLock 、ReentrantReadWriteLock、 Semaphore、 CountDownLatch ，都是【聚合】了一个【队列同步器】的子类完成线程访问控制，  使用的就是模板方法模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">（1）创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</span><br><span class="line"></span><br><span class="line">（2）结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</span><br><span class="line"></span><br><span class="line">（3）行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="spring事务，线程和锁-关系总结，备注：：-spring-bean周期-，-spring事务-延申数据库事务-线程-和-表锁机制"><a href="#spring事务，线程和锁-关系总结，备注：：-spring-bean周期-，-spring事务-延申数据库事务-线程-和-表锁机制" class="headerlink" title="spring事务，线程和锁 关系总结，备注：：  spring bean周期 ， spring事务  延申数据库事务  线程 和 表锁机制"></a><font  color="skyblue">spring事务，线程和锁 关系总结，备注：：  spring bean周期 ， spring事务  延申数据库事务  线程 和 表锁机制</font></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ioc容器：实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、</span><br><span class="line">@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的</span><br><span class="line">bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创</span><br><span class="line">建对象放到map里。</span><br><span class="line">这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI(依赖)注入</span><br><span class="line">（autowired、resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性</span><br><span class="line">根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</span><br><span class="line"></span><br><span class="line">控制反转：</span><br><span class="line">没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须</span><br><span class="line">主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</span><br><span class="line">引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会</span><br><span class="line">主动创建一个对象B注入到对象A逻辑代码需要使用B的地方。</span><br><span class="line">通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒</span><br><span class="line">过来了，这就是“控制反转”这个名称的由来。</span><br><span class="line"></span><br><span class="line">  ##全部对象的控制权全部上缴给“第三方”IOC容器，##</span><br><span class="line"></span><br><span class="line">所以，IOC容器成了整个系统的关键核心，它起到了一</span><br><span class="line">种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对</span><br><span class="line">象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</span><br><span class="line"></span><br><span class="line">依赖注入：</span><br><span class="line">通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。 </span><br><span class="line">“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器</span><br><span class="line">主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对</span><br><span class="line">象之中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">IOC Map  创建、存储和管理对象</span><br><span class="line"></span><br><span class="line">那么，如何使用IoC容器呢？在传统的Java应用中，我们通常会手动创建和配置对象。但在Spring框架中，我们可以通过 配置文件或注解的方式将普通的Java类标记为Spring的配置类，从而将对象的管理权交给IoC容器</span><br><span class="line"></span><br><span class="line">此外，IoC容器还支持AOP（面向切面编程）和声明式事务等功能。这些功能都依赖于IoC容器的核心功能，即代码解耦和设计模式等问题。通过使用这些功能，我们可以更加方便地实现日志记录、事务管理和安全控制等功能。</span><br></pre></td></tr></table></figure>



<p>原因</p>
<p><img src="/$%7Bimages%7D/image-20240314203551117.png" alt="image-20240314203551117"></p>
<p><img src="/$%7Bimages%7D/image-20240315125856907.png" alt="image-20240315125856907"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,</span><br><span class="line">      @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) &#123;</span><br><span class="line"></span><br><span class="line">   BeanWrapperImpl bw = new BeanWrapperImpl();</span><br><span class="line">   this.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="springcloud负载均衡的顶级接口"><a href="#springcloud负载均衡的顶级接口" class="headerlink" title="springcloud负载均衡的顶级接口"></a>springcloud负载均衡的顶级接口</h1><p><img src="/$%7Bimages%7D/image-20240323100646189.png" alt="image-20240323100646189"></p>
<p><img src="/$%7Bimages%7D/image-20240323100653855.png" alt="image-20240323100653855"></p>
<p>MQ组成布冯</p>
<p><img src="/$%7Bimages%7D/image-20240323154251915.png" alt="image-20240323154251915"></p>
<p><img src="/$%7Bimages%7D/image-20240408133246137.png" alt="image-20240408133246137"></p>
<h1 id="java内存分配-从类的角度解释"><a href="#java内存分配-从类的角度解释" class="headerlink" title="java内存分配 从类的角度解释"></a>java内存分配 从类的角度解释</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">01    java 内存分配 </span><br><span class="line">1、基础数据类型看位置：：</span><br><span class="line">      </span><br><span class="line">   （1） 是全局变量   当声明的是基本类型的变量其变量名及其值放在堆内存中的，然而  引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</span><br><span class="line">  （2）在局部变量  不解释</span><br><span class="line">2、方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收; </span><br><span class="line">3、引用数据类型，需要用 new 来创建，既在栈空间分配一个地址空间，又在 </span><br><span class="line">堆空间分配对象的类变量;</span><br><span class="line"> </span><br><span class="line">4、方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当 </span><br><span class="line">方法调用完后从栈空间回收; </span><br><span class="line">5、局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周 </span><br><span class="line">期结束后，栈空间立刻被回收，堆空间区域等待 GC 回收; </span><br><span class="line">6、方法调用时传入的实际参数，先在栈空间分配，在方法调用完成后从栈空间释放; </span><br><span class="line">7、字符串常量在 DATA 区域分配 ， this 在堆空间分配; </span><br><span class="line">8、数组既在栈空间分配数组名称， 又在堆空间分配数组实际的大小。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">、JIT（just in time,即时编译技术）编译后的代码等数据</span><br><span class="line"></span><br><span class="line">通过反射获取到的类型、方法名、字段名称、访问修饰符等信息就是从方法区获取到的。在使用到CGLib对类进行增强时，增强的类越多，就需要越大的方法区类存储动态生成的Class信息，当存放方法区数据的内存溢出时，会报OutOfMemoryError异常。在jdk1.8中也就是Metaspace内存溢出，可以通过参数JVM参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize设置Metaspace的空间大小。jdk1.8后方法区（Method Area）被元空间(Metaspace)代替。3</span><br><span class="line"></span><br><span class="line">||</span><br><span class="line">StackOverflowError是由于调用栈溢出引起的错误，而OutOfMemoryError是由于无法分配更多的堆内存引起的错误</span><br><span class="line"></span><br><span class="line">JVM规范中规定, 除了程序计数器之外, 其他的运行时数据区域, 例如堆栈, 方法区, 都会出现OutOfMemoryError异常.</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265664787">彻底理解JVM内存模型 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javaqaaa/article/details/126438978">jvm基础知识_方法区中类静态属性引用的对象-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">01 --关于 本地方法栈和虚拟机栈对比</span><br><span class="line">本地方法栈</span><br><span class="line">本地方法栈和java虚拟机栈所发挥的作用是非常相似的，其区别就是</span><br><span class="line"></span><br><span class="line">java虚拟机栈为虚拟机执行Java方法（也就是字节码）服务</span><br><span class="line">本地方法栈则是为虚拟机使用到的本地方法服务</span><br><span class="line">StackOverflowError和OutOfMemoryError异常</span><br><span class="line">Java虚拟机栈</span><br><span class="line"></span><br><span class="line">如果线程请求的栈深度大于虚拟机所允许的深度，则会抛出StackOverflowError异常</span><br><span class="line">如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</span><br><span class="line">本地方法栈</span><br><span class="line">与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常</span><br><span class="line"></span><br><span class="line">本地方法栈：：：一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java方法：该方法的实现由非java语言实现</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/sx1999aaa/article/details/108553131</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/image-20240828220332689.png" alt="image-20240828220332689"></p>
<p><img src="/$%7Bimages%7D/image-20240412133722259.png" alt="image-20240412133722259"></p>
<p><img src="/$%7Bimages%7D/image-20240327202022883.png" alt="jdk1.7"></p>
<p><img src="/$%7Bimages%7D/image-20240828211441771.png" alt="jdk1.8  结构图"></p>
<p><img src="/$%7Bimages%7D/image-20240405094351170.png" alt="image-20240405094351170"></p>
<h1 id="拦截器和过滤器"><a href="#拦截器和过滤器" class="headerlink" title="拦截器和过滤器"></a>拦截器和过滤器</h1><img src="${images}/image-20250223174826081.png" alt="image-20250223174826081" style="zoom:33%;" />



<img src="${images}/image-20250223175057853.png" alt="image-20250223175057853" style="zoom:67%;" />





<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/376564740">面试必备：4种经典限流算法讲解 - 知乎</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>  固定窗口限流算法</span><br><span class="line">  | 首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。</span><br><span class="line"></span><br><span class="line">   当次数少于限流阀值，就允许访问，并且计数器+<span class="number">1</span></span><br><span class="line">   当次数大于限流阀值，就拒绝访问。</span><br><span class="line">   当前的时间窗口过去之后，计数器清零。</span><br><span class="line"><span class="number">02</span> 漏桶算法</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line"><span class="number">03</span> 令牌桶算法  （目前建议使用的）</span><br><span class="line">   Guava的RateLimiter限流组件，就是基于令牌桶算法实现的。</span><br></pre></td></tr></table></figure>





<h1 id="网关的作用，经常使用的组件"><a href="#网关的作用，经常使用的组件" class="headerlink" title="网关的作用，经常使用的组件"></a>网关的作用，经常使用的组件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  身份认证，权限鉴定</span><br><span class="line">2    服务路由转发  和负载均衡</span><br><span class="line">3   过滤器</span><br><span class="line">4   拦截器</span><br><span class="line">5   请求限流 sentinel</span><br><span class="line">6   网关可以是zuul也可以是gateway, 现在更喜欢使用gateWay</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="负载均衡的算法"><a href="#负载均衡的算法" class="headerlink" title="负载均衡的算法"></a>负载均衡的算法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务端负载均衡：：NGINX</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">负载均衡通器常有两种实现手段，一种是服务端负载均衡器，另一种是客户端负载均衡器，而我们今天的主角 Ribbon 就属于后者——客户端负载均衡器。</span><br><span class="line"></span><br><span class="line">7种负载均衡策略</span><br><span class="line">1.轮询策略</span><br><span class="line">2.权重策略</span><br><span class="line">3.随机策略</span><br><span class="line">4.最小连接数策略</span><br><span class="line">5.重试策略</span><br><span class="line">6.可用性敏感策略</span><br><span class="line">7.区域敏感策略</span><br><span class="line"></span><br><span class="line">Ribbon 为客户端负载均衡器，相比于服务端负载均衡器的统一负载均衡策略来说，它提供了更多的灵活性。Ribbon 内置了 7 种负载均衡策略：轮询策略、权重策略、随机策略、最小连接数策略、重试策略、可用性敏感策略、区域性敏感策略，并且用户可以通过继承 RoundRibbonRule 来实现自定义负载均衡策略。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">但是我们应该区别一下, 到底是因为内存泄漏还是内存溢出: </span><br><span class="line"></span><br><span class="line">内存泄漏,  创建了很多类的对象, 这类对象不是必要的, 并且这些类对象应该在被使用完之后被垃圾回收器回收, 但是因为某些疏忽导致没有被回收, 此种情况被成为内存泄漏, 一般会引起非常大的故障</span><br><span class="line">内存溢出则跟泄漏相近, 但是内存溢出创建的对象是有必要的, 创建的对象在运行期间一直需要, 但是再进行额外的创建的时候, 因为内存空间不够而抛出OOM异常, 就是内存溢出</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line">                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</span><br><span class="line">                        </span><br><span class="line">原文链接：https://blog.csdn.net/niceffking/article/details/142313709</span><br></pre></td></tr></table></figure>



<h1 id="ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因"><a href="#ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因" class="headerlink" title="ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因"></a>ConcurrentHashMap的读操作不需要加锁，线程并发安全的原因</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s?__biz=MzU3OTc1MDM1Mg==&amp;mid=2247500218&amp;idx=1&amp;sn=176abfecb79d02358eea5b15d1e2d9b3&amp;chksm=fd63d105ca1458131453ba890bb4e28e3fbf71ef4d53cddc80c68bc8e17d21241d192586fcc1&amp;scene=21#wechat_redirect</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/zxlp520/article/details/107074275</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">ConcurrentHashMap 主要使用的是 CAS+自旋+synchronized+多重check 来保证在初始化，新增，和扩容的时候线程安全，读取数据的时候则使用了 volatitle 让元素节点 在多线程之间 可见，从而达到获取最新的值</span><br></pre></td></tr></table></figure>



<h1 id="过滤器和拦截器的区别"><a href="#过滤器和拦截器的区别" class="headerlink" title="过滤器和拦截器的区别"></a>过滤器和拦截器的区别</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//调试日志</span><br><span class="line">private final static Logger logger = LoggerFactory.getLogger(RocketMQSendTest.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="放重复提交的处理方案"><a href="#放重复提交的处理方案" class="headerlink" title="放重复提交的处理方案"></a>放重复提交的处理方案</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33454058/article/details/125516310">java开发中 防止重复提交的几种方案_java防止重复提交-CSDN博客</a></p>
<p><img src="/$%7Bimages%7D/image-20250223171341206.png" alt="image-20250223171341206"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">什么是接口幂等性？？</span><br><span class="line"></span><br><span class="line">接口幂等性是指在分布式系统中，对于相同的请求，无论请求多少次，都应该返回相同的结果。这意味着，如果请求已经处理完毕，那么重复请求应该返回相同的响应，而不应该产生额外的副作用。这种特性对于确保系统的稳定性和一致性非常重要，尤其是在处理并发请求和网络异常的情况下。在编程中，可以通过一些特定的设计来实现接口幂等性，例如使用全局唯一的ID来标记请求，或者使用乐观锁机制来防止重复处理等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> https:<span class="comment">//www.cnblogs.com/vipstone/p/13328386.html</span></span><br><span class="line"><span class="number">02</span>   本地缓存设置一个集合HashMap  ,如果containKey(),存在值，说明已经请求过了，就拒绝。这个当然不适合，但是是一个基本雏形</span><br><span class="line"><span class="number">03</span>   在表单 session .token放入唯一标识符（UUID）,首次请求保存到本地缓存中，设置一定过期时间，保证设置的短暂时间</span><br><span class="line"><span class="number">04</span>   使用LRUMap  实现放重复提交</span><br><span class="line"><span class="comment">// 根据 LRU(Least Recently Used，最近最少使用)算法淘汰数据的 Map 集合，最大容量 100 个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUMap&lt;String, Integer&gt; reqCache = <span class="keyword">new</span> <span class="title class_">LRUMap</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 幂等性判断</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(String id, Object lockClass)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockClass) &#123;</span><br><span class="line">            <span class="comment">// 重复请求判断</span></span><br><span class="line">            <span class="keyword">if</span> (reqCache.containsKey(id)) &#123;</span><br><span class="line">                <span class="comment">// 重复请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请勿重复提交！！！&quot;</span> + id);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 非重复请求，存储请求 ID</span></span><br><span class="line">            reqCache.put(id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">05</span>  redis  分布式锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="LRUMap-实现原理分析"><a href="#LRUMap-实现原理分析" class="headerlink" title="LRUMap 实现原理分析"></a>LRUMap 实现原理分析</h1><h1 id="关于CAS理解和应用"><a href="#关于CAS理解和应用" class="headerlink" title="关于CAS理解和应用"></a>关于CAS理解和应用</h1><p><a target="_blank" rel="noopener" href="https://note.youdao.com/ynoteshare/index.html?id=60dbd623e3b9c51e673d2ba45722a1c2&type=note&_time=1743671182368">06-并发编程之深入理解CAS.note</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------</span><br><span class="line">CAS缺陷  3个</span><br><span class="line">CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：</span><br><span class="line">01  如果涉及库存超卖的场景 涉及redis操作， 自旋 CAS 长时间地不成功，空转 ，，，则会给 CPU 带来非常大的开销  </span><br><span class="line">----解决办法  ：：使用reenTranLock </span><br><span class="line">02  只能保证一个共享变量原子操作   ---- 解决办法 ：； 使用 AtomicReference </span><br><span class="line">03  ABA 问题     --- 解决ABA问题可以使用 AtomicStampedReference类，使用内封装一个版本号version</span><br></pre></td></tr></table></figure>





<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>[发现更多精彩视频 - 抖音搜索](<a target="_blank" rel="noopener" href="https://www.douyin.com/discover/search/concurrentHashMap">https://www.douyin.com/discover/search/concurrentHashMap</a> 流程?aid&#x3D;c36a335a-7438-4183-b5c5-95ee1d2b6395&amp;modal_id&#x3D;7112094067030330665&amp;type&#x3D;general)</p>
<h1 id="分段累加技术如何实现，逻辑"><a href="#分段累加技术如何实现，逻辑" class="headerlink" title="分段累加技术如何实现，逻辑"></a>分段累加技术如何实现，逻辑</h1><h1 id="最新JDK17和22-的新特点"><a href="#最新JDK17和22-的新特点" class="headerlink" title="最新JDK17和22 的新特点"></a>最新JDK17和22 的新特点</h1><h1 id="支付系统的幂等性（常见处理方法）"><a href="#支付系统的幂等性（常见处理方法）" class="headerlink" title="支付系统的幂等性（常见处理方法）"></a>支付系统的幂等性（常见处理方法）</h1><p><img src="/$%7Bimages%7D/image-20250506103831201.png" alt="image-20250506103831201"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">5.4</span> </span><br><span class="line">   <span class="number">5.4</span>一锁判三更新</span><br><span class="line">在高并发场景中，支付宝团队提出了一种综合性的幕等解决方案：”一锁二判三更新”：</span><br><span class="line"><span class="number">1</span>：先加锁：使用Redis分布式锁，确保在处理请求时不会有其他请求干扰。</span><br><span class="line"><span class="number">2</span>：进行幕等性判断：检查请求是否已被处理，可以基于状态机、唯一性索引等进行判断</span><br><span class="line"><span class="number">3</span>，数据更新：如果判断通过，执行数据更新操作，并在完成后释放锁</span><br></pre></td></tr></table></figure>

<p><img src="/$%7Bimages%7D/%E9%98%BF%E9%87%8C%E6%94%AF%E4%BB%98%E5%B9%82%E7%AD%89%E6%80%A7%E9%80%BB%E8%BE%91%E5%9B%BE.drawio.png" alt="阿里支付幂等性逻辑图.drawio"></p>
<h1 id="springboot配置文件加载优先级"><a href="#springboot配置文件加载优先级" class="headerlink" title="springboot配置文件加载优先级"></a>springboot配置文件加载优先级</h1><h1 id="springweb和springwebmvc区别"><a href="#springweb和springwebmvc区别" class="headerlink" title="springweb和springwebmvc区别"></a>springweb和springwebmvc区别</h1>
      </div>
      
      
      
    </div>
  <ul class="breadcrumb">
            <li><a href="/_posts/">_POSTS</a></li>
            <li><a href="/_posts/interSummary/">INTERSUMMARY</a></li>
            <li>INTERVWSUMMARY2</li>
  </ul>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zyunfei</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  <!--  km 多级目录 -->
      <script type="text/javascript" src="/js/category.js"></script>

</body>
</html>
